{"ast":null,"code":"/*\nCopyright (c) NAVER Corp.\nname: @egjs/react-infinitegrid\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-infinitegrid\nversion: 3.0.3\n*/\nimport { createElement, Children, Component } from 'react';\nimport NativeInfiniteGrid, { categorize, ItemManager, INFINITEGRID_EVENTS, CONTAINER_CLASSNAME, GridLayout as GridLayout$1, withInfiniteGridMethods, JustifiedLayout as JustifiedLayout$1, FrameLayout as FrameLayout$1, SquareLayout as SquareLayout$1, PackingLayout as PackingLayout$1 } from '@egjs/infinitegrid';\nimport { findDOMNode } from 'react-dom';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction LoadingBar(props) {\n  return props.loading;\n}\n\nfunction camelize(str) {\n  return str.replace(/[\\s-_]([a-z])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\n\nvar InfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGrid, _super);\n\n  function InfiniteGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      layout: \"\"\n    };\n    return _this;\n  }\n\n  var __proto = InfiniteGrid.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var attributes = {};\n    var items = this.toItems();\n    var Tag = this.props.tag;\n\n    for (var name in props) {\n      if (name in InfiniteGrid.defaultProps) {\n        continue;\n      }\n\n      attributes[name] = props[name];\n    }\n\n    var visibleChildren = [];\n    var ig = this.ig;\n\n    if (ig) {\n      var state = this.state;\n      var result = ig.beforeSync(items);\n      state.layout = result === \"relayout\" ? result : state.layout || result;\n      visibleChildren = ig.getRenderingItems().map(function (item) {\n        return item.jsx;\n      });\n\n      if (this.props.loading) {\n        visibleChildren.push(createElement(LoadingBar, {\n          key: \"loadingBar\",\n          loading: this.props.loading\n        }));\n      }\n    } else {\n      var groups = categorize(items);\n\n      if (props.status) {\n        var _a = props.status._infinite,\n            startCursor = _a.startCursor,\n            endCursor = _a.endCursor;\n        visibleChildren = ItemManager.pluck(groups.slice(startCursor, endCursor + 1), \"items\").map(function (item) {\n          return item.jsx;\n        });\n      } else if (props.useFirstRender && groups[0]) {\n        visibleChildren = groups[0].items.map(function (item) {\n          return item.jsx;\n        });\n      }\n    }\n\n    return createElement(Tag, __assign({}, attributes), this.renderContainer(visibleChildren));\n  };\n\n  __proto.componentDidUpdate = function () {\n    var ig = this.ig;\n    var state = this.state;\n    var layout = state.layout;\n    var elements = this.getElements();\n    this.setLoadingElement();\n    ig.sync(elements);\n\n    if (layout) {\n      state.layout = \"\";\n      ig.layout(layout === \"relayout\");\n    }\n  };\n\n  __proto.componentDidMount = function () {\n    var _this = this;\n\n    this.wrapperElement = findDOMNode(this);\n    this.ig = new NativeInfiniteGrid(this.wrapperElement, __assign(__assign({}, this.props.options), {\n      renderExternal: true\n    })).on(\"render\", function (_a) {\n      var next = _a.next;\n\n      _this.forceUpdate(function () {\n        next();\n      });\n    });\n    var ig = this.ig;\n    INFINITEGRID_EVENTS.forEach(function (name) {\n      var eventName = camelize(\"on \" + name);\n      ig.on(name, function (e) {\n        _this.props[eventName](__assign(__assign({}, e), {\n          currentTarget: _this\n        }));\n      });\n    });\n    ig.setLayout(this.props.layoutType, this.props.layoutOptions);\n    var elements = this.getElements();\n    this.setLoadingElement();\n\n    if (this.props.status) {\n      ig.setStatus(this.props.status, true, elements);\n    } else {\n      ig.beforeSync(this.toItems());\n      ig.layout(true);\n    }\n  };\n\n  __proto.componentWillUnmount = function () {\n    this.ig.destroy();\n  };\n\n  __proto.isLoading = function () {\n    return this.ig.isLoading();\n  };\n\n  __proto.renderContainer = function (children) {\n    var _this = this;\n\n    var props = this.props;\n    var isOverflowScroll = props.options.isOverflowScroll;\n\n    if (!isOverflowScroll) {\n      return children;\n    }\n\n    var ContainerTag = props.containerTag;\n    return createElement(ContainerTag, {\n      className: CONTAINER_CLASSNAME,\n      ref: function (e) {\n        e && (_this.containerElement = e);\n      }\n    }, children);\n  };\n\n  __proto.toItems = function () {\n    var _a = this.props,\n        children = _a.children,\n        groupBy = _a.groupBy;\n    var reactChildren = Children.toArray(children);\n    return reactChildren.map(function (child, i) {\n      var groupKey = groupBy(child, i);\n      var itemKey = child.key;\n      return {\n        groupKey: groupKey,\n        itemKey: itemKey,\n        jsx: child\n      };\n    });\n  };\n\n  __proto.getElements = function () {\n    var elements = [].slice.call((this.containerElement || this.wrapperElement).children);\n\n    if (this.props.loading) {\n      return elements.slice(0, -1);\n    }\n\n    return elements;\n  };\n\n  __proto.setLoadingElement = function () {\n    var ig = this.ig;\n\n    if (this.props.loading) {\n      var loadingElement = (this.containerElement || this.wrapperElement).lastElementChild;\n\n      if (loadingElement) {\n        ig.setLoadingBar({\n          append: loadingElement,\n          prepend: loadingElement\n        });\n        return;\n      }\n    }\n\n    ig.setLoadingBar();\n  };\n\n  InfiniteGrid.defaultProps = {\n    tag: \"div\",\n    containerTag: \"div\",\n    layoutType: GridLayout$1,\n    options: {},\n    layoutOptions: {},\n    useFirstRender: true,\n    status: null,\n    loading: null,\n    groupBy: function (item, index) {\n      var props = item.props;\n\n      if (\"data-groupkey\" in props) {\n        return props[\"data-groupkey\"];\n      } else if (\"groupKey\" in props) {\n        return props.groupKey;\n      } else {\n        return \"\";\n      }\n    },\n    onAppend: function () {},\n    onPrepend: function () {},\n    onLayoutComplete: function () {},\n    onImageError: function () {},\n    onChange: function () {}\n  };\n\n  __decorate([withInfiniteGridMethods], InfiniteGrid.prototype, \"ig\", void 0);\n\n  return InfiniteGrid;\n}(Component);\n\nvar GridLayout = /*#__PURE__*/function (_super) {\n  __extends(GridLayout, _super);\n\n  function GridLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GridLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {\n    layoutType: GridLayout$1\n  });\n  return GridLayout;\n}(InfiniteGrid);\n\nvar JustifiedLayout = /*#__PURE__*/function (_super) {\n  __extends(JustifiedLayout, _super);\n\n  function JustifiedLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  JustifiedLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {\n    layoutType: JustifiedLayout$1\n  });\n  return JustifiedLayout;\n}(InfiniteGrid);\n\nvar FrameLayout = /*#__PURE__*/function (_super) {\n  __extends(FrameLayout, _super);\n\n  function FrameLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FrameLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {\n    layoutType: FrameLayout$1\n  });\n  return FrameLayout;\n}(InfiniteGrid);\n\nvar SquareLayout = /*#__PURE__*/function (_super) {\n  __extends(SquareLayout, _super);\n\n  function SquareLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SquareLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {\n    layoutType: SquareLayout$1\n  });\n  return SquareLayout;\n}(InfiniteGrid);\n\nvar PackingLayout = /*#__PURE__*/function (_super) {\n  __extends(PackingLayout, _super);\n\n  function PackingLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PackingLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {\n    layoutType: PackingLayout$1\n  });\n  return PackingLayout;\n}(InfiniteGrid);\n\nexport default InfiniteGrid;\nexport { FrameLayout, GridLayout, JustifiedLayout, PackingLayout, SquareLayout };","map":{"version":3,"sources":["../src/react-infinitegrid/LoadingBar.tsx","../src/react-infinitegrid/utils.ts","../src/react-infinitegrid/InfiniteGrid.tsx","../src/react-infinitegrid/layouts/GridLayout.tsx","../src/react-infinitegrid/layouts/JustifiedLayout.tsx","../src/react-infinitegrid/layouts/FrameLayout.tsx","../src/react-infinitegrid/layouts/SquareLayout.tsx","../src/react-infinitegrid/layouts/PackingLayout.tsx"],"names":["LoadingBar","props","camelize","str","letter","__extends","InfiniteGrid","tag","containerTag","layoutType","options","layoutOptions","useFirstRender","status","loading","groupBy","item","onAppend","onPrepend","onLayoutComplete","onImageError","onChange","_this","layout","withInfiniteGridMethods","__decorate","attributes","items","Tag","name","visibleChildren","ig","state","result","key","groups","categorize","_a","startCursor","endCursor","React","elements","findDOMNode","renderExternal","next","INFINITEGRID_EVENTS","eventName","e","currentTarget","isOverflowScroll","ContainerTag","className","CONTAINER_CLASSNAME","ref","children","reactChildren","groupKey","itemKey","child","jsx","loadingElement","append","prepend","GridLayout","defaultProps","LayoutType","JustifiedLayout","FrameLayout","SquareLayout","PackingLayout"],"mappings":"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","sourcesContent":["export default function LoadingBar(props: { loading: React.ReactElement }) {\n\treturn props.loading;\n}\n","export function camelize(str: string) {\n\treturn str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n","import * as React from \"react\";\nimport NativeInfiniteGrid, {\n\tGridLayout,\n\tILayout,\n\tcategorize,\n\tCONTAINER_CLASSNAME,\n\tItemManager,\n\tIItem,\n\tINFINITEGRID_EVENTS,\n\twithInfiniteGridMethods,\n} from \"@egjs/infinitegrid\";\nimport { findDOMNode } from \"react-dom\";\nimport { InfiniteGridProps, InfiniteGridType } from \"./types\";\nimport LoadingBar from \"./LoadingBar\";\nimport { camelize } from \"./utils\";\n\nexport default class InfiniteGrid<T extends ILayout = GridLayout> extends React.Component<InfiniteGridProps<T>, {\n\tlayout: string;\n}> {\n\tpublic static defaultProps: Required<InfiniteGridProps> = {\n\t\ttag: \"div\",\n\t\tcontainerTag: \"div\",\n\t\tlayoutType: GridLayout,\n\t\toptions: {},\n\t\tlayoutOptions: {},\n\t\tuseFirstRender: true,\n\t\tstatus: null,\n\t\tloading: null,\n\t\tgroupBy: (item: any, index: number) => {\n\t\t\tconst props = item.props;\n\n\t\t\tif (\"data-groupkey\" in props) {\n\t\t\t\treturn props[\"data-groupkey\"];\n\t\t\t} else if (\"groupKey\" in props) {\n\t\t\t\treturn props.groupKey;\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t},\n\t\tonAppend: () => { },\n\t\tonPrepend: () => { },\n\t\tonLayoutComplete: () => { },\n\t\tonImageError: () => { },\n\t\tonChange: () => { },\n\t};\n\tpublic state = {\n\t\tlayout: \"\",\n\t};\n\t@withInfiniteGridMethods\n\tprivate ig!: NativeInfiniteGrid;\n\tprivate wrapperElement!: HTMLElement;\n\tprivate containerElement!: HTMLElement;\n\n\tpublic render() {\n\t\tconst props = this.props;\n\t\tconst attributes = {};\n\t\tconst items = this.toItems();\n\t\tconst Tag = this.props.tag as any;\n\n\t\tfor (const name in props) {\n\t\t\tif (name in InfiniteGrid.defaultProps) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattributes[name] = props[name];\n\t\t}\n\n\t\tlet visibleChildren: React.ReactElement[] = [];\n\t\tconst ig = this.ig;\n\n\t\tif (ig) {\n\t\t\tconst state = this.state;\n\t\t\tconst result = ig.beforeSync(items);\n\t\t\tstate.layout = result === \"relayout\" ? result : state.layout || result;\n\n\t\t\tvisibleChildren = ig.getRenderingItems().map((item: IItem) => item.jsx);\n\n\t\t\tif (this.props.loading) {\n\t\t\t\tvisibleChildren.push(<LoadingBar key=\"loadingBar\" loading={this.props.loading!} />);\n\t\t\t}\n\t\t} else {\n\t\t\tconst groups = categorize(items);\n\t\t\tif (props.status) {\n\t\t\t\tconst { startCursor, endCursor } = props.status._infinite;\n\n\t\t\t\tvisibleChildren = ItemManager.pluck(\n\t\t\t\t\tgroups.slice(startCursor, endCursor + 1),\n\t\t\t\t\t\"items\",\n\t\t\t\t).map((item: IItem) => item.jsx);\n\t\t\t} else if (props.useFirstRender && groups[0]) {\n\t\t\t\tvisibleChildren = groups[0].items.map((item: IItem) => item.jsx);\n\t\t\t}\n\t\t}\n\t\treturn <Tag {...attributes}>{this.renderContainer(visibleChildren)}</Tag>;\n\t}\n\tpublic componentDidUpdate() {\n\t\tconst ig = this.ig;\n\t\tconst state = this.state;\n\t\tconst layout = state.layout;\n\t\tconst elements = this.getElements();\n\n\t\tthis.setLoadingElement();\n\t\tig.sync(elements);\n\n\t\tif (layout) {\n\t\t\tstate.layout = \"\";\n\t\t\tig.layout(layout === \"relayout\");\n\t\t}\n\t}\n\tpublic componentDidMount() {\n\t\tthis.wrapperElement = findDOMNode(this) as HTMLElement;\n\n\t\tthis.ig = new NativeInfiniteGrid(this.wrapperElement, {\n\t\t\t...this.props.options,\n\t\t\trenderExternal: true,\n\t\t}).on(\"render\", ({ next }) => {\n\t\t\tthis.forceUpdate(() => {\n\t\t\t\tnext();\n\t\t\t});\n\t\t});\n\t\tconst ig = this.ig;\n\n\t\tINFINITEGRID_EVENTS.forEach((name: string) => {\n\t\t\tconst eventName = camelize(`on ${name}`);\n\t\t\tig.on(name, (e: any) => {\n\t\t\t\tthis.props[eventName]!({ ...e, currentTarget: this });\n\t\t\t});\n\t\t});\n\n\t\tig.setLayout(this.props.layoutType, this.props.layoutOptions);\n\n\t\tconst elements = this.getElements();\n\n\t\tthis.setLoadingElement();\n\t\tif (this.props.status) {\n\t\t\tig.setStatus(this.props.status, true, elements);\n\t\t} else {\n\t\t\tig.beforeSync(this.toItems());\n\t\t\tig.layout(true);\n\t\t}\n\t}\n\tpublic componentWillUnmount() {\n\t\tthis.ig.destroy();\n\t}\n\tpublic isLoading() {\n\t\treturn this.ig.isLoading();\n\t}\n\tprivate renderContainer(children: React.ReactElement[]) {\n\t\tconst props = this.props;\n\t\tconst { isOverflowScroll } = props.options;\n\n\t\tif (!isOverflowScroll) {\n\t\t\treturn children;\n\t\t}\n\t\tconst ContainerTag = props.containerTag as any;\n\n\t\treturn <ContainerTag className={CONTAINER_CLASSNAME} ref={(e: any) => {\n\t\t\te && (this.containerElement = e);\n\t\t}}>\n\t\t\t{children}\n\t\t</ContainerTag>;\n\t}\n\tprivate toItems() {\n\t\tconst {\n\t\t\tchildren,\n\t\t\tgroupBy,\n\t\t} = this.props;\n\t\tconst reactChildren = React.Children.toArray(children);\n\t\treturn reactChildren.map((child: React.ReactElement, i) => {\n\t\t\tconst groupKey = groupBy(child, i);\n\t\t\tconst itemKey = child.key;\n\n\t\t\treturn { groupKey, itemKey, jsx: child };\n\t\t});\n\t}\n\tprivate getElements(): HTMLElement[] {\n\t\tconst elements = [].slice.call((this.containerElement || this.wrapperElement).children);\n\n\t\tif (this.props.loading) {\n\t\t\treturn elements.slice(0, -1);\n\t\t}\n\t\treturn elements;\n\t}\n\tprivate setLoadingElement() {\n\t\tconst ig = this.ig;\n\n\t\tif (this.props.loading) {\n\t\t\tconst loadingElement = (this.containerElement || this.wrapperElement).lastElementChild as HTMLElement;\n\n\t\t\tif (loadingElement) {\n\t\t\t\tig.setLoadingBar({\n\t\t\t\t\tappend: loadingElement,\n\t\t\t\t\tprepend: loadingElement,\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tig.setLoadingBar();\n\t}\n}\n\nexport default interface InfiniteGrid extends InfiniteGridType<InfiniteGrid> { }\n","import { GridLayout as LayoutType } from \"@egjs/infinitegrid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridProps } from \"../types\";\n\nexport default class GridLayout extends InfiniteGrid<LayoutType> {\n\tpublic static defaultProps: Required<InfiniteGridProps<LayoutType>> = {\n\t\t...InfiniteGrid.defaultProps,\n\t\tlayoutType: LayoutType,\n\t};\n}\n","import { JustifiedLayout as LayoutType } from \"@egjs/infinitegrid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridProps } from \"../types\";\n\nexport default class JustifiedLayout extends InfiniteGrid<LayoutType> {\n\tpublic static defaultProps: Required<InfiniteGridProps<LayoutType>> = {\n\t\t...InfiniteGrid.defaultProps,\n\t\tlayoutType: LayoutType,\n\t};\n}\n","import { FrameLayout as LayoutType } from \"@egjs/infinitegrid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridProps } from \"../types\";\n\nexport default class FrameLayout extends InfiniteGrid<LayoutType> {\n\tpublic static defaultProps: Required<InfiniteGridProps<LayoutType>> = {\n\t\t...InfiniteGrid.defaultProps,\n\t\tlayoutType: LayoutType,\n\t};\n}\n","import { SquareLayout as LayoutType } from \"@egjs/infinitegrid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridProps } from \"../types\";\n\nexport default class SquareLayout extends InfiniteGrid<LayoutType> {\n\tpublic static defaultProps: Required<InfiniteGridProps<LayoutType>> = {\n\t\t...InfiniteGrid.defaultProps,\n\t\tlayoutType: LayoutType,\n\t};\n}\n","import { PackingLayout as LayoutType } from \"@egjs/infinitegrid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridProps } from \"../types\";\n\nexport default class PackingLayout extends InfiniteGrid<LayoutType> {\n\tpublic static defaultProps: Required<InfiniteGridProps<LayoutType>> = {\n\t\t...InfiniteGrid.defaultProps,\n\t\tlayoutType: LayoutType,\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}