{"ast":null,"code":"const RED = 0;\nconst BLACK = 1;\nconst NIL = 2;\nconst DELETE = 0;\nconst KEEP = 1;\n\nconst addInterval = (treeNode, high, index) => {\n  let node = treeNode.list;\n  let prevNode;\n\n  while (node) {\n    if (node.index === index) return false;\n    if (high > node.high) break;\n    prevNode = node;\n    node = node.next;\n  }\n\n  if (!prevNode) treeNode.list = {\n    index,\n    high,\n    next: node\n  };\n  if (prevNode) prevNode.next = {\n    index,\n    high,\n    next: prevNode.next\n  };\n  return true;\n};\n\nconst removeInterval = (treeNode, index) => {\n  let node = treeNode.list;\n\n  if (node.index === index) {\n    if (node.next === null) return DELETE;\n    treeNode.list = node.next;\n    return KEEP;\n  }\n\n  let prevNode = node;\n  node = node.next;\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next;\n      return KEEP;\n    }\n\n    prevNode = node;\n    node = node.next;\n  }\n};\n\nconst NULL_NODE = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-ignore\n  P: undefined,\n  // @ts-ignore\n  R: undefined,\n  // @ts-ignore\n  L: undefined,\n  // @ts-ignore\n  list: undefined\n};\nNULL_NODE.P = NULL_NODE;\nNULL_NODE.L = NULL_NODE;\nNULL_NODE.R = NULL_NODE;\n\nconst updateMax = node => {\n  const max = node.high;\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max;else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max);else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max);else node.max = Math.max(Math.max(node.L.max, node.R.max), max);\n};\n\nconst updateMaxUp = node => {\n  let x = node;\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P);\n    x = x.P;\n  }\n};\n\nconst rotateLeft = (tree, x) => {\n  if (x.R === NULL_NODE) return;\n  const y = x.R;\n  x.R = y.L;\n  if (y.L !== NULL_NODE) y.L.P = x;\n  y.P = x.P;\n  if (x.P === NULL_NODE) tree.root = y;else {\n    if (x === x.P.L) x.P.L = y;else x.P.R = y;\n  }\n  y.L = x;\n  x.P = y;\n  updateMax(x);\n  updateMax(y);\n};\n\nconst rotateRight = (tree, x) => {\n  if (x.L === NULL_NODE) return;\n  const y = x.L;\n  x.L = y.R;\n  if (y.R !== NULL_NODE) y.R.P = x;\n  y.P = x.P;\n  if (x.P === NULL_NODE) tree.root = y;else {\n    if (x === x.P.R) x.P.R = y;else x.P.L = y;\n  }\n  y.R = x;\n  x.P = y;\n  updateMax(x);\n  updateMax(y);\n};\n\nconst replaceNode = (tree, x, y) => {\n  if (x.P === NULL_NODE) tree.root = y;else if (x === x.P.L) x.P.L = y;else x.P.R = y;\n  y.P = x.P;\n};\n\nconst fixRemove = (tree, x) => {\n  let w;\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateLeft(tree, x.P);\n        w = x.P.R;\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK;\n          w.C = RED;\n          rotateRight(tree, w);\n          w = x.P.R;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.R.C = BLACK;\n        rotateLeft(tree, x.P);\n        x = tree.root;\n      }\n    } else {\n      w = x.P.L;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateRight(tree, x.P);\n        w = x.P.L;\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK;\n          w.C = RED;\n          rotateLeft(tree, w);\n          w = x.P.L;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.L.C = BLACK;\n        rotateRight(tree, x.P);\n        x = tree.root;\n      }\n    }\n  }\n\n  x.C = BLACK;\n};\n\nconst minimumTree = x => {\n  while (x.L !== NULL_NODE) x = x.L;\n\n  return x;\n};\n\nconst fixInsert = (tree, z) => {\n  let y;\n\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.R) {\n          z = z.P;\n          rotateLeft(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateRight(tree, z.P.P);\n      }\n    } else {\n      y = z.P.P.L;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.L) {\n          z = z.P;\n          rotateRight(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateLeft(tree, z.P.P);\n      }\n    }\n  }\n\n  tree.root.C = BLACK;\n};\n\nconst IntervalTree = () => {\n  const tree = {\n    root: NULL_NODE,\n    size: 0\n  }; // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n\n  const indexMap = {};\n  return {\n    insert(low, high, index) {\n      let x = tree.root;\n      let y = NULL_NODE;\n\n      while (x !== NULL_NODE) {\n        y = x;\n        if (low === y.low) break;\n        if (low < x.low) x = x.L;else x = x.R;\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return;\n        y.high = Math.max(y.high, high);\n        updateMax(y);\n        updateMaxUp(y);\n        indexMap[index] = y;\n        tree.size++;\n        return;\n      }\n\n      const z = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: {\n          index,\n          high,\n          next: null\n        }\n      };\n\n      if (y === NULL_NODE) {\n        tree.root = z;\n      } else {\n        if (z.low < y.low) y.L = z;else y.R = z;\n        updateMaxUp(z);\n      }\n\n      fixInsert(tree, z);\n      indexMap[index] = z;\n      tree.size++;\n    },\n\n    remove(index) {\n      const z = indexMap[index];\n      if (z === void 0) return;\n      delete indexMap[index];\n      const intervalResult = removeInterval(z, index);\n      if (intervalResult === void 0) return;\n\n      if (intervalResult === KEEP) {\n        z.high = z.list.high;\n        updateMax(z);\n        updateMaxUp(z);\n        tree.size--;\n        return;\n      }\n\n      let y = z;\n      let originalYColor = y.C;\n      let x;\n\n      if (z.L === NULL_NODE) {\n        x = z.R;\n        replaceNode(tree, z, z.R);\n      } else if (z.R === NULL_NODE) {\n        x = z.L;\n        replaceNode(tree, z, z.L);\n      } else {\n        y = minimumTree(z.R);\n        originalYColor = y.C;\n        x = y.R;\n\n        if (y.P === z) {\n          x.P = y;\n        } else {\n          replaceNode(tree, y, y.R);\n          y.R = z.R;\n          y.R.P = y;\n        }\n\n        replaceNode(tree, z, y);\n        y.L = z.L;\n        y.L.P = y;\n        y.C = z.C;\n      }\n\n      updateMax(x);\n      updateMaxUp(x);\n      if (originalYColor === BLACK) fixRemove(tree, x);\n      tree.size--;\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node === NULL_NODE || low > node.max) continue;\n        if (node.L !== NULL_NODE) stack.push(node.L);\n        if (node.R !== NULL_NODE) stack.push(node.R);\n\n        if (node.low <= high && node.high >= low) {\n          let curr = node.list;\n\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low);\n            curr = curr.next;\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size;\n    }\n\n  };\n};\n\nexport default IntervalTree;","map":{"version":3,"sources":["C:/Users/Work/Desktop/Wild Code School/Projects/art-gallery-react-project2/bucharest-project2-art-gallery/node_modules/masonic/dist/module/IntervalTree.js"],"names":["RED","BLACK","NIL","DELETE","KEEP","addInterval","treeNode","high","index","node","list","prevNode","next","removeInterval","NULL_NODE","low","max","C","P","undefined","R","L","updateMax","Math","updateMaxUp","x","rotateLeft","tree","y","root","rotateRight","replaceNode","fixRemove","w","minimumTree","fixInsert","z","IntervalTree","size","indexMap","insert","remove","intervalResult","originalYColor","search","callback","stack","length","pop","push","curr"],"mappings":"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","sourcesContent":["const RED = 0\nconst BLACK = 1\nconst NIL = 2\nconst DELETE = 0\nconst KEEP = 1\n\nconst addInterval = (treeNode, high, index) => {\n  let node = treeNode.list\n  let prevNode\n\n  while (node) {\n    if (node.index === index) return false\n    if (high > node.high) break\n    prevNode = node\n    node = node.next\n  }\n\n  if (!prevNode)\n    treeNode.list = {\n      index,\n      high,\n      next: node,\n    }\n  if (prevNode)\n    prevNode.next = {\n      index,\n      high,\n      next: prevNode.next,\n    }\n  return true\n}\n\nconst removeInterval = (treeNode, index) => {\n  let node = treeNode.list\n\n  if (node.index === index) {\n    if (node.next === null) return DELETE\n    treeNode.list = node.next\n    return KEEP\n  }\n\n  let prevNode = node\n  node = node.next\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next\n      return KEEP\n    }\n\n    prevNode = node\n    node = node.next\n  }\n}\n\nconst NULL_NODE = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-ignore\n  P: undefined,\n  // @ts-ignore\n  R: undefined,\n  // @ts-ignore\n  L: undefined,\n  // @ts-ignore\n  list: undefined,\n}\nNULL_NODE.P = NULL_NODE\nNULL_NODE.L = NULL_NODE\nNULL_NODE.R = NULL_NODE\n\nconst updateMax = (node) => {\n  const max = node.high\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max)\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max)\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max)\n}\n\nconst updateMaxUp = (node) => {\n  let x = node\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P)\n    x = x.P\n  }\n}\n\nconst rotateLeft = (tree, x) => {\n  if (x.R === NULL_NODE) return\n  const y = x.R\n  x.R = y.L\n  if (y.L !== NULL_NODE) y.L.P = x\n  y.P = x.P\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.L) x.P.L = y\n    else x.P.R = y\n  }\n  y.L = x\n  x.P = y\n  updateMax(x)\n  updateMax(y)\n}\n\nconst rotateRight = (tree, x) => {\n  if (x.L === NULL_NODE) return\n  const y = x.L\n  x.L = y.R\n  if (y.R !== NULL_NODE) y.R.P = x\n  y.P = x.P\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.R) x.P.R = y\n    else x.P.L = y\n  }\n  y.R = x\n  x.P = y\n  updateMax(x)\n  updateMax(y)\n}\n\nconst replaceNode = (tree, x, y) => {\n  if (x.P === NULL_NODE) tree.root = y\n  else if (x === x.P.L) x.P.L = y\n  else x.P.R = y\n  y.P = x.P\n}\n\nconst fixRemove = (tree, x) => {\n  let w\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateLeft(tree, x.P)\n        w = x.P.R\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK\n          w.C = RED\n          rotateRight(tree, w)\n          w = x.P.R\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.R.C = BLACK\n        rotateLeft(tree, x.P)\n        x = tree.root\n      }\n    } else {\n      w = x.P.L\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateRight(tree, x.P)\n        w = x.P.L\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK\n          w.C = RED\n          rotateLeft(tree, w)\n          w = x.P.L\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.L.C = BLACK\n        rotateRight(tree, x.P)\n        x = tree.root\n      }\n    }\n  }\n\n  x.C = BLACK\n}\n\nconst minimumTree = (x) => {\n  while (x.L !== NULL_NODE) x = x.L\n\n  return x\n}\n\nconst fixInsert = (tree, z) => {\n  let y\n\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.R) {\n          z = z.P\n          rotateLeft(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateRight(tree, z.P.P)\n      }\n    } else {\n      y = z.P.P.L\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.L) {\n          z = z.P\n          rotateRight(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateLeft(tree, z.P.P)\n      }\n    }\n  }\n\n  tree.root.C = BLACK\n}\n\nconst IntervalTree = () => {\n  const tree = {\n    root: NULL_NODE,\n    size: 0,\n  } // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n\n  const indexMap = {}\n  return {\n    insert(low, high, index) {\n      let x = tree.root\n      let y = NULL_NODE\n\n      while (x !== NULL_NODE) {\n        y = x\n        if (low === y.low) break\n        if (low < x.low) x = x.L\n        else x = x.R\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return\n        y.high = Math.max(y.high, high)\n        updateMax(y)\n        updateMaxUp(y)\n        indexMap[index] = y\n        tree.size++\n        return\n      }\n\n      const z = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: {\n          index,\n          high,\n          next: null,\n        },\n      }\n\n      if (y === NULL_NODE) {\n        tree.root = z\n      } else {\n        if (z.low < y.low) y.L = z\n        else y.R = z\n        updateMaxUp(z)\n      }\n\n      fixInsert(tree, z)\n      indexMap[index] = z\n      tree.size++\n    },\n\n    remove(index) {\n      const z = indexMap[index]\n      if (z === void 0) return\n      delete indexMap[index]\n      const intervalResult = removeInterval(z, index)\n      if (intervalResult === void 0) return\n\n      if (intervalResult === KEEP) {\n        z.high = z.list.high\n        updateMax(z)\n        updateMaxUp(z)\n        tree.size--\n        return\n      }\n\n      let y = z\n      let originalYColor = y.C\n      let x\n\n      if (z.L === NULL_NODE) {\n        x = z.R\n        replaceNode(tree, z, z.R)\n      } else if (z.R === NULL_NODE) {\n        x = z.L\n        replaceNode(tree, z, z.L)\n      } else {\n        y = minimumTree(z.R)\n        originalYColor = y.C\n        x = y.R\n\n        if (y.P === z) {\n          x.P = y\n        } else {\n          replaceNode(tree, y, y.R)\n          y.R = z.R\n          y.R.P = y\n        }\n\n        replaceNode(tree, z, y)\n        y.L = z.L\n        y.L.P = y\n        y.C = z.C\n      }\n\n      updateMax(x)\n      updateMaxUp(x)\n      if (originalYColor === BLACK) fixRemove(tree, x)\n      tree.size--\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root]\n\n      while (stack.length !== 0) {\n        const node = stack.pop()\n        if (node === NULL_NODE || low > node.max) continue\n        if (node.L !== NULL_NODE) stack.push(node.L)\n        if (node.R !== NULL_NODE) stack.push(node.R)\n\n        if (node.low <= high && node.high >= low) {\n          let curr = node.list\n\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low)\n            curr = curr.next\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size\n    },\n  }\n}\n\nexport default IntervalTree\n"]},"metadata":{},"sourceType":"module"}