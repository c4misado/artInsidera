{"ast":null,"code":"const createCache = obj => {\n  try {\n    // @ts-ignore\n    return new obj();\n  } catch (e) {\n    const cache = {};\n    return {\n      set(k, v) {\n        cache[k] = v;\n      },\n\n      get(k) {\n        return cache[k];\n      }\n\n    };\n  }\n};\n\nconst memo = constructors => {\n  const depth = constructors.length,\n        baseCache = createCache(constructors[0]);\n  let base;\n  let map;\n  let i;\n  let node;\n  const one = depth === 1; // quicker access for one and two-argument functions\n\n  const g1 = args => (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1]);\n\n  const s1 = (args, value) => {\n    if (one) baseCache.set(args[0], value);else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1]);\n        map.set(args[1], value);\n        baseCache.set(args[0], map);\n      } else {\n        base.set(args[1], value);\n      }\n    }\n    return value;\n  };\n\n  const g2 = args => {\n    node = baseCache;\n\n    for (i = 0; i < depth; i++) if ((node = node.get(args[i])) === void 0) return;\n\n    return node;\n  };\n\n  const s2 = (args, value) => {\n    node = baseCache;\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1]);\n        node.set(args[i], map);\n        node = map;\n      } else {\n        node = map;\n      }\n    }\n\n    node.set(args[depth - 1], value);\n    return value;\n  };\n\n  return depth < 3 ? {\n    g: g1,\n    s: s1\n  } : {\n    g: g2,\n    s: s2\n  };\n};\n\nconst memoize = (mapConstructors, fn) => {\n  let item;\n  const {\n    g,\n    s\n  } = memo(mapConstructors);\n  return function () {\n    return (item = g(arguments)) === void 0 ? s(arguments, fn.apply(null, arguments)) : item;\n  };\n};\n\nexport default memoize;","map":{"version":3,"sources":["C:/Users/Work/Desktop/Wild Code School/Projects/art-gallery-react-project2/bucharest-project2-art-gallery/node_modules/trie-memoize/dist/module/index.js"],"names":["createCache","obj","e","cache","set","k","v","get","memo","constructors","depth","length","baseCache","base","map","i","node","one","g1","args","s1","value","g2","s2","g","s","memoize","mapConstructors","fn","item","arguments","apply"],"mappings":"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","sourcesContent":["const createCache = (obj) => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache = {}\n    return {\n      set(k, v) {\n        cache[k] = v\n      },\n\n      get(k) {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (constructors) => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base\n  let map\n  let i\n  let node\n  const one = depth === 1 // quicker access for one and two-argument functions\n\n  const g1 = (args) =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n\n  const s1 = (args, value) => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n    return value\n  }\n\n  const g2 = (args) => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args, value) => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3\n    ? {\n        g: g1,\n        s: s1,\n      }\n    : {\n        g: g2,\n        s: s2,\n      }\n}\n\nconst memoize = (mapConstructors, fn) => {\n  let item\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments))\n      : item\n  }\n}\n\nexport default memoize\n"]},"metadata":{},"sourceType":"module"}