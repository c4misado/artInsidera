{"ast":null,"code":"/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/infinitegrid\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-infinitegrid\nversion: 3.6.2\n*/\nimport Component from '@egjs/component';\nimport { diff } from '@egjs/list-differ';\nimport { check, removeAutoSizer } from '@egjs/lazyloaded';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {\n    document: {},\n    navigator: {\n      userAgent: \"\"\n    }\n  };\n} else {\n  win = window;\n}\n\nvar document = win.document;\n\nvar _a;\n\nvar ua = win.navigator.userAgent;\nvar SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in win);\nvar SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\n\nvar SUPPORT_PASSIVE = function () {\n  var supportsPassiveOption = false;\n\n  try {\n    if (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n      // tslint:disable-next-line: no-empty\n      document.addEventListener(\"test\", function () {}, Object.defineProperty({}, \"passive\", {\n        get: function () {\n          supportsPassiveOption = true;\n        }\n      }));\n    }\n  } catch (e) {//\n  }\n\n  return supportsPassiveOption;\n}();\n\nvar IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar IS_IOS = /iPhone|iPad/.test(ua);\nvar IS_ANDROID2 = /Android 2\\./.test(ua);\nvar CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nvar IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nvar TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar DUMMY_POSITION = -100000;\nvar GROUPKEY_ATT = \"data-groupkey\";\nvar DEFAULT_OPTIONS = {\n  itemSelector: \"*\",\n  isOverflowScroll: false,\n  threshold: 100,\n  isEqualSize: false,\n  isConstantSize: false,\n  useRecycle: true,\n  horizontal: false,\n  transitionDuration: 0,\n  useFit: true,\n  attributePrefix: \"data-\",\n  renderExternal: false\n};\nvar DEFAULT_LAYOUT_OPTIONS = {\n  horizontal: false,\n  margin: 0\n};\nvar agent = ua.toLowerCase();\nvar isMobile = /mobi|ios|android/.test(agent);\nvar ALIGN = {\n  START: \"start\",\n  CENTER: \"center\",\n  END: \"end\",\n  JUSTIFY: \"justify\"\n};\nvar IDLE = 0;\nvar LOADING_APPEND = 1;\nvar LOADING_PREPEND = 2;\nvar PROCESSING = 4;\nvar webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\nvar WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;\nvar DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;\nvar ITEM_KEYS = [\"content\", \"groupKey\", \"itemKey\", \"orgSize\", \"mounted\", \"prevRect\", \"rect\", \"size\"];\nvar TRANSFORM = (_a = function () {\n  var properties = {\n    transitionend: \"\",\n    webkitTransitionEnd: \"-webkit-\",\n    MSTransitionEnd: \"-ms-\",\n    oTransitionEnd: \"-o-\",\n    mozTransitionEnd: \"-moz-\"\n  };\n\n  for (var property in properties) {\n    var prefix = properties[property];\n\n    if (\"on\" + property.toLowerCase() in win) {\n      return [prefix + \"transform\", prefix + \"transition\", property];\n    }\n  }\n\n  return [];\n}(), _a[0]),\n    TRANSITION = _a[1],\n    TRANSITION_END = _a[2];\nvar INFINITEGRID_EVENTS = [\"append\", \"prepend\", \"imageError\", \"change\", \"layoutComplete\"]; // It's for making mistakes.\n// Whenever you add a public method, you must add the corresponding method name to an array or object.\n// An additional error may occur if not added.\n\nvar INFINITEGRID_METHODS = {\n  getLoadingBar: true,\n  getItem: true,\n  getItems: true,\n  layout: true,\n  getGroupKeys: true,\n  getStatus: true,\n  setStatus: true,\n  isProcessing: true,\n  startLoading: true,\n  endLoading: true,\n  isLoading: true,\n  updateItem: true,\n  updateItems: true,\n  moveTo: true\n};\n\nfunction toArray(nodes) {\n  // SCRIPT5014 in IE8\n  var array = [];\n\n  if (nodes) {\n    var length = nodes.length;\n\n    for (var i = 0; i < length; i++) {\n      array.push(nodes[i]);\n    }\n  }\n\n  return array;\n}\n\nfunction matchHTML(html) {\n  return html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n\nfunction $(param, multi) {\n  if (multi === void 0) {\n    multi = false;\n  }\n\n  var el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    var match = matchHTML(param); // creating element\n\n    if (match) {\n      // HTML\n      var dummy = document.createElement(\"div\");\n      dummy.innerHTML = param;\n      el = dummy.childNodes;\n    } else {\n      // Selector\n      el = document.querySelectorAll(param);\n    }\n\n    if (multi) {\n      return toArray(el);\n    } else {\n      return el && el[0];\n    }\n  } else if (isWindow(param)) {\n    // window\n    el = param;\n  } else if (isJQuery(param)) {\n    // jQuery\n    el = multi ? $(param.toArray(), true) : $(param.get(0), false);\n  } else if (Array.isArray(param)) {\n    el = param.map(function (v) {\n      return $(v);\n    });\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else {\n    el = [].slice.call(el);\n  }\n\n  return el;\n}\n\nfunction addEvent(element, type, handler, eventListenerOptions) {\n  if (SUPPORT_ADDEVENTLISTENER) {\n    var options = eventListenerOptions || false;\n\n    if (typeof eventListenerOptions === \"object\") {\n      options = SUPPORT_PASSIVE ? eventListenerOptions : false;\n    }\n\n    element.addEventListener(type, handler, options);\n  } else if (element.attachEvent) {\n    element.attachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = handler;\n  }\n}\n\nfunction removeEvent(element, type, handler) {\n  if (element.removeEventListener) {\n    element.removeEventListener(type, handler, false);\n  } else if (element.detachEvent) {\n    element.detachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = null;\n  }\n}\n\nfunction addOnceEvent(element, type, handler, eventListenerOptions) {\n  var callback = function (e) {\n    removeEvent(element, type, callback);\n    handler(e);\n  };\n\n  addEvent(element, type, callback, eventListenerOptions);\n}\n\nfunction scroll(el, horizontal) {\n  if (horizontal === void 0) {\n    horizontal = false;\n  }\n\n  var prop = \"scroll\" + (horizontal ? \"Left\" : \"Top\");\n\n  if (isWindow(el)) {\n    return win[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n  } else {\n    return el[prop];\n  }\n}\n\nfunction scrollTo(el, x, y) {\n  if (isWindow(el)) {\n    el.scroll(x, y);\n  } else {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n}\n\nfunction scrollBy(el, x, y) {\n  if (isWindow(el)) {\n    el.scrollBy(x, y);\n  } else {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n}\n\nfunction getStyles(el) {\n  return (SUPPORT_COMPUTEDSTYLE ? win.getComputedStyle(el) : el.currentStyle) || {};\n}\n\nfunction _getSize(el, name, isOffset) {\n  if (isWindow(el)) {\n    // WINDOW\n    return win[\"inner\" + name] || document.body[\"client\" + name];\n  } else if (isDocument(el)) {\n    // DOCUMENT_NODE\n    var doc = el.documentElement;\n    var body = el.body;\n    return Math.max(body[\"scroll\" + name], doc[\"scroll\" + name], body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n  } else {\n    // NODE\n    var size = 0;\n\n    if (isOffset) {\n      var clientRect = el.getBoundingClientRect();\n      size = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n    } else {\n      size = el[\"client\" + name] || el[\"offset\" + name];\n    }\n\n    if (size) {\n      return size;\n    }\n\n    var cssSize = getStyles(el)[name.toLowerCase()];\n    return ~cssSize.indexOf(\"px\") && parseFloat(cssSize) || 0;\n  }\n}\n\nfunction innerWidth(el) {\n  return _getSize(el, \"Width\", false);\n}\n\nfunction innerHeight(el) {\n  return _getSize(el, \"Height\", false);\n}\n\nfunction outerWidth(el) {\n  return _getSize(el, \"Width\", true);\n}\n\nfunction outerHeight(el) {\n  return _getSize(el, \"Height\", true);\n}\n\nfunction getSize(el) {\n  return {\n    width: outerWidth(el),\n    height: outerHeight(el)\n  };\n}\n\nvar STYLE = {\n  vertical: {\n    startPos1: \"top\",\n    endPos1: \"bottom\",\n    size1: \"height\",\n    startPos2: \"left\",\n    endPos2: \"right\",\n    size2: \"width\"\n  },\n  horizontal: {\n    startPos1: \"left\",\n    endPos1: \"right\",\n    size1: \"width\",\n    startPos2: \"top\",\n    endPos2: \"bottom\",\n    size2: \"height\"\n  }\n};\n\nfunction getStyleNames(isHorizontal) {\n  return STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\n\nfunction assign(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\n\nfunction assignOptions(defaultOptions, options) {\n  return assign({}, DEFAULT_LAYOUT_OPTIONS, defaultOptions, options);\n}\n\nfunction toZeroArray(outline) {\n  if (!outline || !outline.length) {\n    return [0];\n  }\n\n  return outline;\n}\n\nfunction cloneItems(items) {\n  return items.map(function (item) {\n    return assign({}, item);\n  });\n}\n\nfunction isJQuery(el) {\n  return typeof win.jQuery === \"function\" && el instanceof win.jQuery || el.constructor.prototype.jquery && el.toArray;\n}\n\nfunction isWindow(el) {\n  return el === win;\n}\n\nfunction isDocument(el) {\n  return el.nodeType === 9;\n}\n\nfunction fill(arr, value) {\n  var length = arr.length;\n\n  for (var i = length - 1; i >= 0; --i) {\n    arr[i] = value;\n  }\n\n  return arr;\n}\n\nfunction isUndefined(target) {\n  return typeof target === \"undefined\";\n}\n\nfunction find(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nfunction findLast(arr, callback) {\n  var length = arr.length;\n\n  for (var i = length - 1; i >= 0; --i) {\n    if (callback(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nfunction categorize(newItems) {\n  var newGroups = [];\n  var groupKeys = {};\n  newItems.forEach(function (item) {\n    var groupKey = item.groupKey;\n    var group = groupKeys[groupKey];\n\n    if (!group) {\n      group = {\n        groupKey: groupKey,\n        items: []\n      };\n      groupKeys[groupKey] = group;\n      newGroups.push(group);\n    }\n\n    group.items.push(item);\n  });\n  return newGroups;\n}\n\nfunction resetSize(item) {\n  item.orgSize = null;\n  item.size = null;\n}\n\nfunction makeItem(groupKey, el) {\n  return {\n    el: el,\n    groupKey: groupKey,\n    mounted: false,\n    content: el ? el.outerHTML : \"\",\n    rect: {\n      top: DUMMY_POSITION,\n      left: DUMMY_POSITION\n    }\n  };\n}\n/**\n * Decorator that makes the method of infinitegrid available in the framework.\n * @ko 프레임워크에서 인피니트그리드의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.InfiniteGrid\n * @private\n * @example\n * ```js\n * import NativeInfiniteGrid, { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class InfiniteGrid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private infinitegrid: NativeInfiniteGrid;\n * }\n * ```\n */\n\n\nfunction withInfiniteGridMethods(prototype, infinitegridName) {\n  Object.keys(INFINITEGRID_METHODS).forEach(function (name) {\n    if (prototype[name]) {\n      return;\n    }\n\n    prototype[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var _a;\n\n      var result = (_a = this[infinitegridName])[name].apply(_a, args); // fix `this` type to return your own `infinitegrid` instance to the instance using the decorator.\n\n\n      if (result === this[infinitegridName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n\n  return !!element.className.match(new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n}\n\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += \" \" + className;\n  }\n}\n\nvar ItemManager = /*#__PURE__*/function () {\n  function ItemManager() {\n    // groups\n    this._groups = []; // group keys\n\n    this._groupKeys = {};\n  }\n\n  var __proto = ItemManager.prototype;\n\n  ItemManager.toItems = function (elements, groupKey) {\n    return elements.map(function (el) {\n      return makeItem(groupKey, el);\n    });\n  };\n\n  ItemManager.pluck = function (data, property) {\n    return data.reduce(function (acc, v) {\n      return acc.concat(v[property]);\n    }, []);\n  };\n\n  __proto.clear = function () {\n    this._groups = [];\n    this._groupKeys = {};\n  };\n\n  __proto.getStatus = function (startKey, endKey) {\n    var datas = this._groups;\n    var startIndex = Math.max(this.indexOf(startKey), 0);\n    var endIndex = this.indexOf(endKey) + 1 || datas.length;\n    return {\n      _data: datas.slice(startIndex, endIndex).map(function (data) {\n        var items = data.items.map(function (item) {\n          var item2 = {};\n          ITEM_KEYS.forEach(function (key) {\n            if (key in item) {\n              item2[key] = item[key];\n            }\n          });\n          return item2;\n        });\n        var data2 = assign({}, data);\n        data2.items = items;\n        return data2;\n      })\n    };\n  };\n\n  __proto.setStatus = function (status) {\n    var _this = this;\n\n    var data = status._data;\n    this.clear();\n    data.forEach(function (group, i) {\n      _this.insertGroup(group, i);\n    });\n  };\n\n  __proto.size = function () {\n    return this._groups.length;\n  };\n\n  __proto.fit = function (base, horizontal) {\n    var groups = this._groups;\n\n    if (!groups.length) {\n      return;\n    }\n\n    var property = horizontal ? \"left\" : \"top\";\n\n    if (base !== 0) {\n      groups.forEach(function (group) {\n        var items = group.items,\n            outlines = group.outlines;\n        items.forEach(function (item) {\n          item.rect[property] -= base;\n        });\n        outlines.start = outlines.start.map(function (start) {\n          return start - base;\n        });\n        outlines.end = outlines.end.map(function (end) {\n          return end - base;\n        });\n      });\n    }\n  };\n\n  __proto.pluck = function (property, start, end) {\n    var data = isUndefined(start) ? this._groups : this.sliceGroups(start, (isUndefined(end) ? start : end) + 1);\n    return ItemManager.pluck(data, property);\n  };\n\n  __proto.getOutline = function (index, property) {\n    var data = this._groups[index];\n    return data ? data.outlines[property] : [];\n  };\n\n  __proto.getEdgeIndex = function (cursor, start, end) {\n    var prop = cursor === \"start\" ? \"min\" : \"max\";\n    var index = -1;\n    var targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n    for (var i = start; i <= end; i++) {\n      var value = Math[prop].apply(Math, this.getOutline(i, cursor));\n\n      if (cursor === \"start\" && targetValue > value || cursor === \"end\" && targetValue < value) {\n        targetValue = value;\n        index = i;\n      }\n    }\n\n    return index;\n  };\n\n  __proto.getEdgeValue = function (cursor, start, end) {\n    var group = this.getGroup(this.getEdgeIndex(cursor, start, end));\n\n    if (group) {\n      var outlines = group.outlines[cursor];\n\n      if (outlines.length) {\n        return Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines);\n      }\n    }\n\n    return 0;\n  };\n\n  __proto.clearOutlines = function (startCursor, endCursor) {\n    if (startCursor === void 0) {\n      startCursor = -1;\n    }\n\n    if (endCursor === void 0) {\n      endCursor = -1;\n    }\n\n    var datas = this.getGroups();\n    datas.forEach(function (group, cursor) {\n      if (startCursor <= cursor && cursor <= endCursor) {\n        return;\n      }\n\n      group.items.forEach(function (item) {\n        item.rect.top = DUMMY_POSITION;\n        item.rect.left = DUMMY_POSITION;\n      });\n      group.outlines.start = [];\n      group.outlines.end = [];\n    });\n  };\n\n  __proto.getMaxEdgeValue = function () {\n    var groups = this._groups;\n    var length = groups.length;\n\n    for (var i = length - 1; i >= 0; --i) {\n      var end = groups[i].outlines.end;\n\n      if (end.length) {\n        var pos = Math.max.apply(Math, end);\n        return pos;\n      }\n    }\n\n    return 0;\n  };\n\n  __proto.prependGroup = function (group) {\n    return this.insertGroup(group, 0);\n  };\n\n  __proto.appendGroup = function (group) {\n    return this.insertGroup(group, this._groups.length);\n  };\n\n  __proto.insertGroup = function (group, groupIndex) {\n    var _this = this;\n\n    if (groupIndex < 0) {\n      return null;\n    }\n\n    var prevItems = group.items || [];\n\n    var newGroup = __assign({\n      outlines: {\n        start: [],\n        end: []\n      }\n    }, group, {\n      items: []\n    });\n\n    this._groups.splice(groupIndex, 0, newGroup);\n\n    this._groupKeys[newGroup.groupKey] = newGroup;\n    prevItems.forEach(function (item, i) {\n      _this.insert(item, groupIndex, i);\n    });\n    return newGroup;\n  };\n\n  __proto.sync = function (items) {\n    var _this = this;\n\n    var groups = this._groups;\n    var groupKeys = this._groupKeys;\n    var newGroups = categorize(items);\n    var result = diff(groups, newGroups, function (group) {\n      return group.groupKey;\n    });\n    var removed = result.removed,\n        added = result.added,\n        maintained = result.maintained;\n    removed.forEach(function (removedIndex) {\n      var group = groups[removedIndex];\n\n      if (!group) {\n        return;\n      }\n\n      delete groupKeys[group.groupKey];\n    });\n    var nextGroups = [];\n    maintained.forEach(function (_a) {\n      var fromIndex = _a[0];\n      nextGroups.push(groups[fromIndex]);\n    });\n    this._groups = nextGroups;\n    added.forEach(function (addedIndex) {\n      _this.insertGroup(newGroups[addedIndex], addedIndex);\n    });\n    maintained.reverse().forEach(function (_a) {\n      var toIndex = _a[1];\n\n      _this.syncItems(toIndex, newGroups[toIndex].items);\n    });\n    return result;\n  };\n\n  __proto.insert = function (newItem, groupIndex, itemIndex) {\n    if (groupIndex === void 0) {\n      groupIndex = -1;\n    }\n\n    if (itemIndex === void 0) {\n      itemIndex = -1;\n    }\n\n    var groupKey = newItem.groupKey;\n    var groups = this._groups;\n    var groupKeys = this._groupKeys;\n    var group = (groupIndex > -1 ? groups[groupIndex] : groupKeys[groupKey]) || this.insertGroup({\n      groupKey: groupKey\n    }, groupIndex);\n\n    if (!group) {\n      return null;\n    }\n\n    var groupItem = __assign({\n      content: \"\",\n      mounted: false,\n      rect: {\n        top: DUMMY_POSITION,\n        left: DUMMY_POSITION\n      }\n    }, newItem);\n\n    var groupItems = group.items;\n\n    if (itemIndex === -1) {\n      groupItems.push(groupItem);\n    } else {\n      groupItems.splice(itemIndex, 0, groupItem);\n    }\n\n    return groupItem;\n  };\n\n  __proto.removeGroup = function (groupIndex) {\n    var group = this._groups.splice(groupIndex, 1)[0];\n\n    if (!group) {\n      return null;\n    }\n\n    delete this._groupKeys[group.groupKey];\n    return group;\n  };\n\n  __proto.remove = function (groupIndex, itemIndex) {\n    var data = this.getGroup(groupIndex);\n    var group = null;\n    var items = [];\n\n    if (!data) {\n      return {\n        items: items,\n        group: group\n      };\n    } // remove item information\n\n\n    items = data.items.splice(itemIndex, 1);\n\n    if (!data.items.length) {\n      group = this.removeGroup(groupIndex);\n    }\n\n    return {\n      items: items,\n      group: group\n    };\n  };\n\n  __proto.indexOf = function (data) {\n    if (typeof data === \"undefined\") {\n      return -1;\n    }\n\n    var groupKey = \"\" + (typeof data === \"object\" ? data.groupKey : data);\n    var datas = this._groups;\n    var length = datas.length;\n\n    for (var i = 0; i < length; ++i) {\n      if (groupKey === \"\" + datas[i].groupKey) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  __proto.indexesOfElement = function (element) {\n    var groupKey = element.getAttribute(GROUPKEY_ATT);\n    var groupIndex = this.indexOf({\n      groupKey: groupKey\n    });\n    var itemIndex = -1;\n\n    if (groupIndex > -1) {\n      var data = this.getGroup(groupIndex);\n      var length = data.items.length;\n\n      for (var i = 0; i < length; i++) {\n        if (data.items[i].el === element) {\n          itemIndex = i;\n          break;\n        }\n      }\n    }\n\n    return {\n      groupIndex: groupIndex,\n      itemIndex: itemIndex\n    };\n  };\n\n  __proto.sliceGroups = function (start, end) {\n    return this._groups.slice(start, end);\n  };\n\n  __proto.getGroups = function () {\n    return this._groups;\n  };\n\n  __proto.getGroupByKey = function (key) {\n    return this._groupKeys[key];\n  };\n\n  __proto.getGroup = function (index) {\n    return this._groups[index];\n  };\n\n  __proto.syncItems = function (groupIndex, newItems) {\n    var _this = this;\n\n    if (!newItems.length) {\n      this.removeGroup(groupIndex);\n      return;\n    }\n\n    var items = this.getGroup(groupIndex).items;\n\n    var _a = diff(items, newItems, function (item) {\n      return item.itemKey;\n    }),\n        added = _a.added,\n        maintained = _a.maintained;\n\n    var group = this._groups[groupIndex];\n    var nextItems = [];\n    maintained.forEach(function (_a) {\n      var fromIndex = _a[0],\n          nextIndex = _a[1];\n      var item = items[fromIndex];\n      var newItem = newItems[nextIndex];\n      assign(item, newItem);\n      nextItems.push(item);\n    });\n    group.items = nextItems;\n    added.forEach(function (addedIndex) {\n      _this.insert(newItems[addedIndex], groupIndex, addedIndex);\n    });\n  };\n\n  return ItemManager;\n}();\n\nfunction removeTransition(styles) {\n  styles[TRANSITION + \"-property\"] = \"\";\n  styles[TRANSITION + \"-duration\"] = \"\";\n  styles[TRANSFORM] = \"\";\n}\n\nfunction setTransition(styles, transitionDuration, pos1, pos2) {\n  if (!transitionDuration) {\n    removeTransition(styles);\n    return false;\n  }\n\n  if (pos1.left === pos2.left && pos1.top === pos2.top) {\n    return false;\n  }\n\n  styles[TRANSITION + \"-property\"] = TRANSFORM + \",width,height\";\n  styles[TRANSITION + \"-duration\"] = transitionDuration + \"s\";\n  styles[TRANSFORM] = \"translate(\" + (pos1.left - pos2.left) + \"px,\" + (pos1.top - pos2.top) + \"px)\";\n  return true;\n}\n\nfunction createContainer(element) {\n  var selectContainer = element.querySelector(\".\" + CONTAINER_CLASSNAME);\n\n  if (selectContainer) {\n    selectContainer.style.position = \"relative\";\n    selectContainer.style.height = \"100%\";\n    return selectContainer;\n  }\n\n  var container = document.createElement(\"div\");\n  container.className = CONTAINER_CLASSNAME;\n  container.style.position = \"relative\";\n  container.style.height = \"100%\";\n  var children = element.children;\n  var length = children.length; // for IE8\n\n  for (var i = 0; i < length; i++) {\n    container.appendChild(children[0]);\n  }\n\n  element.appendChild(container);\n  return container;\n}\n\nfunction render(properties, rect, styles) {\n  properties.forEach(function (p) {\n    p in rect && (styles[p] = rect[p] + \"px\");\n  });\n}\n\nvar DOMRenderer = /*#__PURE__*/function () {\n  function DOMRenderer(element, options) {\n    this.options = {\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false,\n      container: false\n    };\n    this._size = {\n      container: -1,\n      view: -1,\n      viewport: -1,\n      item: null\n    };\n    this._orgStyle = {};\n    assign(this.options, options);\n\n    this._init(element);\n\n    this.resize();\n  }\n\n  var __proto = DOMRenderer.prototype;\n\n  DOMRenderer.renderItem = function (item, rect, transitionDuration) {\n    if (!item.el) {\n      return;\n    }\n\n    var el = item.el,\n        prevRect = item.prevRect;\n    var styles = el.style; // for debugging\n\n    el.setAttribute(GROUPKEY_ATT, \"\" + item.groupKey);\n    styles.position = \"absolute\";\n    render([\"width\", \"height\"], rect, styles);\n\n    if (transitionDuration && TRANSITION && prevRect) {\n      setTransition(styles, transitionDuration, rect, prevRect);\n\n      if (el[TRANSITION_NAME]) {\n        return;\n      }\n\n      el[TRANSITION_NAME] = true;\n      addOnceEvent(el, TRANSITION_END, function () {\n        var itemRect = item.rect;\n        removeTransition(styles);\n        render([\"left\", \"top\"], itemRect, styles);\n        item.prevRect = itemRect;\n        el[TRANSITION_NAME] = false;\n      });\n    } else {\n      render([\"left\", \"top\"], rect, styles);\n      item.prevRect = rect;\n    }\n  };\n\n  DOMRenderer.renderItems = function (items, transitionDuration) {\n    items.forEach(function (item) {\n      DOMRenderer.renderItem(item, item.rect, transitionDuration);\n    });\n  };\n\n  DOMRenderer.removeItems = function (items) {\n    items.forEach(function (item) {\n      if (item.el) {\n        DOMRenderer.removeElement(item.el);\n        item.el = null;\n      }\n    });\n  };\n\n  DOMRenderer.removeElement = function (element) {\n    var parentNode = element && element.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    parentNode.removeChild(element);\n  };\n\n  DOMRenderer.createElements = function (items) {\n    if (!items.length) {\n      return;\n    }\n\n    var noElementItems = items.filter(function (item) {\n      return !item.el;\n    });\n\n    if (!noElementItems.length) {\n      return;\n    }\n\n    var elements = $(noElementItems.map(function (_a) {\n      var content = _a.content;\n      return content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\");\n    }).join(\"\"), true);\n    noElementItems.forEach(function (item, index) {\n      item.el = elements[index];\n    });\n  };\n\n  __proto.getStatus = function () {\n    return {\n      cssText: this.container.style.cssText,\n      _size: assign({}, this._size)\n    };\n  };\n\n  __proto.setStatus = function (status) {\n    this.container.style.cssText = status.cssText;\n    assign(this._size, status._size);\n  };\n\n  __proto.updateSize = function (items) {\n    var _a = this.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize;\n    var size = this._size;\n    return items.map(function (item) {\n      if (!item.el) {\n        return item;\n      }\n\n      if (isEqualSize && !size.item) {\n        size.item = getSize(item.el);\n      }\n\n      item.size = isEqualSize && assign({}, size.item) || isConstantSize && item.orgSize && item.orgSize.width && assign({}, item.orgSize) || getSize(item.el);\n\n      if (!item.orgSize || !item.orgSize.width || !item.orgSize.height) {\n        item.orgSize = assign({}, item.size);\n      }\n\n      return item;\n    });\n  };\n\n  __proto.createAndInsert = function (items, isAppend) {\n    DOMRenderer.createElements(items);\n    DOMRenderer.renderItems(items);\n\n    this._insert(items, isAppend);\n  };\n\n  __proto.getViewSize = function () {\n    return this._size.view;\n  };\n\n  __proto.getViewportSize = function () {\n    return this._size.viewport;\n  };\n\n  __proto.getContainerSize = function () {\n    return this._size.container;\n  };\n\n  __proto.setContainerSize = function (size) {\n    this._size.container = size;\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = size + \"px\";\n  };\n\n  __proto.resize = function () {\n    var horizontal = this.options.horizontal;\n    var view = this.view;\n\n    var size = this._calcSize();\n\n    if (size === 0) {\n      return;\n    }\n\n    var isResize = size !== this._size.viewport;\n\n    if (isResize) {\n      this._size = {\n        view: -1,\n        container: -1,\n        viewport: size,\n        item: null\n      };\n    }\n\n    this._size.view = horizontal ? innerWidth(view) : innerHeight(view);\n    return isResize;\n  };\n\n  __proto.isNeededResize = function () {\n    return this._calcSize() !== this._size.viewport;\n  };\n\n  __proto.clear = function () {\n    this.container.innerHTML = \"\";\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n    this._size = {\n      item: null,\n      viewport: -1,\n      container: -1,\n      view: -1\n    };\n  };\n\n  __proto.destroy = function () {\n    this.clear();\n    var container = this.options.container;\n    var property;\n\n    for (property in this._orgStyle) {\n      this[container ? \"view\" : \"container\"].style[property] = this._orgStyle[property];\n    }\n\n    container && this.container.parentNode.removeChild(this.container);\n  };\n\n  __proto._init = function (el) {\n    var element = $(el);\n    var style = getStyles(element);\n    var _a = this.options,\n        container = _a.container,\n        horizontal = _a.horizontal;\n\n    if (style.position === \"static\") {\n      this._orgStyle.position = element.style.position;\n      element.style.position = \"relative\";\n    }\n\n    if (container) {\n      var target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n      this._orgStyle.overflowX = element.style.overflowX;\n      this._orgStyle.overflowY = element.style.overflowY;\n      element.style[\"overflow\" + target[0]] = \"scroll\";\n      element.style[\"overflow\" + target[1]] = \"hidden\";\n      this.view = element;\n      this.container = container === true ? createContainer(this.view) : container;\n    } else {\n      this.view = win;\n      this.container = element;\n    }\n  };\n\n  __proto._insert = function (items, isAppend, styles) {\n    var container = this.container;\n    var df = document.createDocumentFragment();\n    items.forEach(function (item) {\n      styles && DOMRenderer.renderItem(item, styles);\n      isAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n    });\n    isAppend ? container.appendChild(df) : container.insertBefore(df, container.firstChild);\n  };\n\n  __proto._calcSize = function () {\n    return this.options.horizontal ? innerHeight(this.container) : innerWidth(this.container);\n  };\n\n  return DOMRenderer;\n}();\n\nfunction isVisible(group, threshold, scrollPos, endScrollPos) {\n  var items = group.items,\n      outlines = group.outlines;\n  var start = outlines.start;\n  var end = outlines.end;\n\n  if (start.length === 0 || end.length === 0 || !items.length || !items[0].el) {\n    return 2;\n  }\n\n  var min = Math.min.apply(Math, start);\n  var max = Math.max.apply(Math, end);\n\n  if (endScrollPos + threshold < min) {\n    return +1;\n  } else if (scrollPos - threshold > max) {\n    return -1;\n  }\n\n  return 0;\n}\n\nvar Infinite = /*#__PURE__*/function () {\n  function Infinite(itemManger, options) {\n    this.options = assign({\n      useRecycle: true,\n      threshold: 100,\n      append: function () {\n        return void 0;\n      },\n      prepend: function () {\n        return void 0;\n      },\n      recycle: function () {\n        return void 0;\n      }\n    }, options);\n    this._itemManager = itemManger;\n    this.clear();\n  }\n\n  var __proto = Infinite.prototype;\n\n  __proto.setSize = function (size) {\n    this._status.size = size;\n  };\n\n  __proto.sync = function (items) {\n    var status = this._status;\n    var startCursor = status.startCursor,\n        endCursor = status.endCursor;\n    var itemManager = this._itemManager;\n    var prevVisisbleGroups = itemManager.sliceGroups(startCursor, endCursor + 1);\n    var prevVisibleItems = ItemManager.pluck(prevVisisbleGroups, \"items\");\n    var result = itemManager.sync(items);\n    var startGroup = find(prevVisisbleGroups, function (_a) {\n      var groupKey = _a.groupKey;\n      return itemManager.getGroupByKey(groupKey);\n    });\n    var endGroup = findLast(prevVisisbleGroups, function (_a) {\n      var groupKey = _a.groupKey;\n      return itemManager.getGroupByKey(groupKey);\n    });\n    var nextStartCursor = startGroup ? itemManager.indexOf(startGroup) : -1;\n    var nextEndCursor = endGroup ? itemManager.indexOf(endGroup) : -1;\n\n    if (nextStartCursor > -1 && nextEndCursor > -1) {\n      // This is when the arrangement is inverted.\n      // prevVisisbleGroups is [0, 1, 2, 3]\n      // but currentGroups is [3, 2, 1, 0]\n      // so, nextStartCursor is 3, and nextEndCursor is 0\n      var minCursor = Math.min(nextStartCursor, nextEndCursor);\n      var maxCursor = Math.max(nextStartCursor, nextEndCursor);\n      nextStartCursor = minCursor;\n      nextEndCursor = maxCursor;\n    } else if (nextEndCursor > -1) {\n      nextStartCursor = nextEndCursor;\n    } else if (nextStartCursor > -1) {\n      nextEndCursor = nextStartCursor;\n    }\n\n    status.startCursor = nextStartCursor;\n    status.endCursor = nextEndCursor;\n\n    if (result.removed.length > 0) {\n      return \"relayout\";\n    } else {\n      var nextVisibleItems = itemManager.pluck(\"items\", startCursor, endCursor);\n      var visibleDiffResult = diff(prevVisibleItems, nextVisibleItems, function (_a) {\n        var itemKey = _a.itemKey;\n        return itemKey;\n      });\n\n      if (visibleDiffResult.removed.length > 0) {\n        return \"layout\";\n      } else {\n        return \"\";\n      }\n    }\n  };\n\n  __proto.recycle = function (scrollPos, isForward) {\n    if (!this.options.useRecycle || typeof scrollPos !== \"number\") {\n      return;\n    }\n\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor,\n        size = _a.size;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return;\n    }\n\n    var endScrollPos = scrollPos + size;\n    var _b = this.options,\n        threshold = _b.threshold,\n        recycle = _b.recycle;\n\n    var visibles = this._itemManager.sliceGroups(startCursor, endCursor + 1).map(function (group) {\n      return isVisible(group, threshold, scrollPos, endScrollPos);\n    });\n\n    var length = visibles.length;\n    var start = isForward ? 0 : visibles.lastIndexOf(0);\n    var end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n    if (!isForward && start !== -1) {\n      start += 1;\n    }\n\n    if (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n      return;\n    }\n\n    start = startCursor + start;\n    end = startCursor + end;\n\n    if (isForward) {\n      this.setCursor(\"start\", end + 1);\n    } else {\n      this.setCursor(\"end\", start - 1);\n    }\n\n    recycle({\n      start: start,\n      end: end\n    });\n  };\n\n  __proto.scroll = function (scrollPos) {\n    var _a = this.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    var items = this._itemManager;\n\n    if (typeof scrollPos !== \"number\" || startCursor === -1 || endCursor === -1 || !items.size()) {\n      return;\n    }\n\n    var size = this._status.size;\n    var _b = this.options,\n        threshold = _b.threshold,\n        append = _b.append,\n        prepend = _b.prepend;\n    var datas = items.getGroups();\n    var endScrollPos = scrollPos + size;\n    var startEdgePos = Math.max.apply(Math, datas[startCursor].outlines.start);\n    var endEdgePos = Math.min.apply(Math, datas[endCursor].outlines.end);\n    var visibles = datas.map(function (group, i) {\n      var _a = group.outlines,\n          start = _a.start,\n          end = _a.end;\n\n      if (!start.length || !end.length) {\n        return false;\n      }\n\n      var startPos = Math.min.apply(Math, start);\n      var endPos = Math.max.apply(Math, end);\n\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n\n      return false;\n    });\n    var startIndex = visibles.indexOf(true);\n    var endIndex = visibles.lastIndexOf(true);\n\n    if (~startIndex && startIndex < startCursor) {\n      prepend({\n        cache: datas.slice(startIndex, Math.min(startCursor, endIndex + 1))\n      });\n    } else if (endCursor < endIndex) {\n      append({\n        cache: datas.slice(Math.max(startIndex, endCursor + 1), endIndex + 1)\n      });\n    } else {\n      // if you have data(no cachedAppendData, has cachedPrependData) to pepend, request it.\n      var cachedAppendData = datas.slice(endCursor + 1, endCursor + 2);\n      var cachedPrependData = datas.slice(startCursor - 1, startCursor);\n      var isPrepend = scrollPos <= startEdgePos + threshold;\n\n      if (endScrollPos >= endEdgePos - threshold && (!isPrepend || cachedAppendData.length || !cachedPrependData.length)) {\n        append({\n          cache: cachedAppendData\n        });\n      } else if (isPrepend) {\n        prepend({\n          cache: cachedPrependData\n        });\n      }\n    }\n  };\n\n  __proto.setCursor = function (cursor, index) {\n    var status = this._status;\n    var items = this._itemManager;\n    var size = items.size();\n\n    if (!this.options.useRecycle) {\n      status.startCursor = 0;\n\n      if (items.getOutline(size - 1, \"end\").length) {\n        status.endCursor = size - 1;\n        return;\n      }\n\n      if (cursor !== \"end\") {\n        return;\n      }\n    }\n\n    if (cursor === \"start\") {\n      status.startCursor = index;\n    } else {\n      status.endCursor = Math.min(size - 1, index);\n    }\n\n    status.startCursor = Math.max(0, status.startCursor);\n  };\n\n  __proto.setStatus = function (status) {\n    this._status = assign(this._status, status);\n  };\n\n  __proto.getStatus = function (startKey, endKey) {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor,\n        size = _a.size;\n    var startIndex = Math.max(this._itemManager.indexOf(startKey), 0);\n    var endIndex = (this._itemManager.indexOf(endKey) + 1 || this._itemManager.size()) - 1;\n    var start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n    var end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n    return {\n      startCursor: start,\n      endCursor: end,\n      size: size\n    };\n  };\n\n  __proto.getEdgeOutline = function (cursor) {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return [];\n    }\n\n    return this._itemManager.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n  };\n\n  __proto.getEdgeValue = function (cursor) {\n    var outlines = this.getEdgeOutline(cursor);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, outlines) : 0;\n  };\n\n  __proto.getVisibleItems = function () {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n    return this._itemManager.pluck(\"items\", startCursor, endCursor);\n  };\n\n  __proto.getCursors = function () {\n    var status = this._status;\n    return [status.startCursor, status.endCursor];\n  };\n\n  __proto.getCursor = function (cursor) {\n    return this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n  };\n\n  __proto.getVisibleData = function () {\n    var _a = this._status,\n        startCursor = _a.startCursor,\n        endCursor = _a.endCursor;\n    return this._itemManager.sliceGroups(startCursor, endCursor + 1);\n  };\n\n  __proto.remove = function (groupIndex, itemIndex) {\n    var status = this._status;\n    var items = this._itemManager;\n    var startCursor = status.startCursor,\n        endCursor = status.endCursor;\n    var result = items.remove(groupIndex, itemIndex);\n\n    if (result.group) {\n      if (groupIndex < startCursor) {\n        this.setCursor(\"start\", startCursor - 1);\n      }\n\n      if (groupIndex <= endCursor) {\n        this.setCursor(\"end\", endCursor - 1);\n      }\n    }\n\n    if (!items.size()) {\n      status.startCursor = -1;\n      status.endCursor = -1;\n    }\n\n    return result;\n  };\n\n  __proto.clear = function () {\n    this._status = {\n      startCursor: -1,\n      endCursor: -1,\n      size: -1\n    };\n  };\n\n  return Infinite;\n}();\n\nfunction hasTarget(target, value) {\n  return ~target.indexOf(value);\n}\n\nvar RenderManager = /*#__PURE__*/function () {\n  function RenderManager(_infinite, _itemManager, _renderer, options) {\n    this._infinite = _infinite;\n    this._itemManager = _itemManager;\n    this._renderer = _renderer;\n    this.options = options;\n  }\n\n  var __proto = RenderManager.prototype;\n\n  __proto.setLayout = function (layout) {\n    this._layout = layout;\n  };\n\n  __proto.render = function (callbackComponent, groups, items, isAppend) {\n    var _this = this;\n\n    if (items === void 0) {\n      items = ItemManager.pluck(groups, \"items\");\n    }\n\n    var checkGroups = isAppend ? groups : groups.reverse();\n    var replaceTarget = [];\n    var removeTarget = [];\n    var elements = items.map(function (item) {\n      return item.el;\n    });\n    var prefix = this.options.attributePrefix;\n    check(elements, prefix).on(\"ready\", function () {\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._complete(callbackComponent, checkGroups, items, isAppend);\n    }).on(\"error\", function (_a) {\n      var target = _a.target,\n          itemIndex = _a.itemIndex;\n\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._error(callbackComponent, removeTarget, replaceTarget, target, items, itemIndex);\n    }).on(\"finish\", function () {\n      if (!_this._itemManager) {\n        return;\n      }\n\n      _this._end(callbackComponent, removeTarget, replaceTarget, items);\n    });\n    return callbackComponent;\n  };\n\n  __proto._complete = function (callbackComponent, groups, items, isAppend) {\n    var infinite = this._infinite;\n    var layout = this._layout;\n    var itemManager = this._itemManager;\n    var cursor = isAppend ? \"end\" : \"start\";\n    var groupIndex = itemManager.indexOf(groups[0]);\n    var prevGroup = itemManager.getGroup(groupIndex + (isAppend ? -1 : 1));\n    var outline = prevGroup ? prevGroup.outlines[cursor] : [0];\n\n    this._renderer.updateSize(items);\n\n    groups.forEach(function (group) {\n      var groupOutline = group.outlines[isAppend ? \"start\" : \"end\"];\n      var isRelayout = !outline.length || (outline.length === groupOutline.length ? !outline.every(function (v, index) {\n        return v === groupOutline[index];\n      }) : true);\n\n      if (!isRelayout) {\n        outline = group.outlines[isAppend ? \"end\" : \"start\"];\n        DOMRenderer.renderItems(group.items);\n        return;\n      }\n\n      var groupItems = group.items;\n      var groupInfo = layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n      assign(group, groupInfo);\n      DOMRenderer.renderItems(groupInfo.items);\n      outline = groupInfo.outlines[isAppend ? \"end\" : \"start\"];\n    });\n    var startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n    var endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n    var requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n    var requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n    var isInCursor = true;\n\n    if (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n      isInCursor = false;\n    }\n\n    if (isInCursor) {\n      if (isAppend) {\n        requestStartCursor = startCursor;\n        requestEndCursor = Math.max(endCursor, requestEndCursor);\n      } else {\n        requestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n        requestEndCursor = endCursor;\n      }\n    }\n\n    if (requestStartCursor > requestEndCursor) {\n      var tempCursor = requestStartCursor;\n      requestStartCursor = requestEndCursor;\n      requestEndCursor = tempCursor;\n    }\n\n    callbackComponent.trigger(\"renderComplete\", {\n      start: requestStartCursor,\n      end: requestEndCursor\n    });\n    callbackComponent.trigger(\"layoutComplete\", {\n      items: ItemManager.pluck(groups, \"items\"),\n      isAppend: isAppend\n    });\n  };\n\n  __proto._error = function (callbackComponent, removeTarget, replaceTarget, target, items, errorIndex) {\n    var itemManager = this._itemManager;\n    var item = items[errorIndex];\n    var element = item.el;\n    var prefix = this.options.attributePrefix; // remove item\n\n    var removeItem = function () {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      removeTarget.push(element);\n      var index = replaceTarget.indexOf(errorIndex);\n      index !== -1 && replaceTarget.splice(index, 1);\n    }; // remove image\n\n\n    var remove = function () {\n      if (target === element) {\n        removeItem();\n        return;\n      }\n\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      target.parentNode.removeChild(target);\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace image\n\n\n    var replace = function (src) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      if (src) {\n        if (matchHTML(src) || typeof src === \"object\") {\n          var parentNode = target.parentNode;\n          parentNode.insertBefore($(src), target);\n          parentNode.removeChild(target);\n          item.content = element.outerHTML;\n        } else {\n          target.src = src;\n\n          if (target.getAttribute(prefix + \"width\")) {\n            removeAutoSizer(target, prefix);\n            target.removeAttribute(prefix + \"width\");\n            target.removeAttribute(prefix + \"height\");\n          }\n        }\n      }\n\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace item\n\n\n    var replaceItem = function (content) {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      element.innerHTML = content;\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    };\n\n    var totalIndex = itemManager.pluck(\"items\").indexOf(item);\n    callbackComponent.trigger(\"imageError\", {\n      target: target,\n      element: element,\n      items: items,\n      item: item,\n      itemIndex: errorIndex,\n      replace: replace,\n      replaceItem: replaceItem,\n      remove: remove,\n      removeItem: removeItem,\n      totalIndex: totalIndex\n    });\n  };\n\n  __proto._end = function (callbackComponent, removeTarget, replaceTarget, items) {\n    var _this = this;\n\n    var attributePrefix = this.options.attributePrefix;\n    var removeTargetLength = removeTarget.length;\n    var replaceTargetLength = replaceTarget.length;\n\n    if (!removeTargetLength && !replaceTargetLength) {\n      callbackComponent.trigger(\"finish\", {\n        remove: []\n      });\n      return;\n    }\n\n    var layoutedItems = replaceTarget.map(function (itemIndex) {\n      return items[itemIndex];\n    });\n\n    if (!replaceTargetLength) {\n      callbackComponent.trigger(\"finish\", {\n        remove: removeTarget,\n        layout: true\n      });\n      return;\n    } // wait layoutComplete beacause of error event.\n\n\n    check(layoutedItems.map(function (v) {\n      return v.el;\n    }), attributePrefix).on(\"ready\", function () {\n      _this._renderer.updateSize(layoutedItems);\n\n      callbackComponent.trigger(\"finish\", {\n        remove: removeTarget,\n        layout: true\n      });\n    });\n  };\n\n  return RenderManager;\n}();\n\nvar Watcher = /*#__PURE__*/function () {\n  function Watcher(view, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = this;\n\n    this._containerOffset = 0;\n    this._isScrollIssue = IS_IOS; //  When InfiniteGrid is initialized.\n    // The initial value is null to block the scroll event when returning from browser behavior.\n\n    this._prevPos = null;\n\n    this._onCheck = function () {\n      var prevPos = _this.getScrollPos();\n\n      var orgScrollPos = _this.getOrgScrollPos();\n\n      _this.setScrollPos(orgScrollPos);\n\n      var scrollPos = _this.getScrollPos();\n\n      if (prevPos === null || _this._isScrollIssue && orgScrollPos === 0 || prevPos === scrollPos) {\n        orgScrollPos && (_this._isScrollIssue = false);\n        return;\n      }\n\n      _this._isScrollIssue = false;\n\n      _this.options.check({\n        isForward: prevPos < scrollPos,\n        scrollPos: scrollPos,\n        orgScrollPos: orgScrollPos,\n        horizontal: _this.options.horizontal\n      });\n    };\n\n    this._onResize = function () {\n      if (_this._timer.resize) {\n        clearTimeout(_this._timer.resize);\n      }\n\n      _this._timer.resize = setTimeout(function () {\n        _this.resize();\n\n        _this.options.resize();\n\n        _this._timer.resize = null;\n      }, 100);\n    };\n\n    assign(this.options = {\n      container: view,\n      resize: function () {\n        return void 0;\n      },\n      check: function () {\n        return void 0;\n      },\n      isOverflowScroll: false,\n      horizontal: false\n    }, options);\n    this._timer = {\n      resize: null\n    };\n    this._view = view;\n    this.attachEvent();\n    this.resize();\n    this.setScrollPos();\n  }\n\n  var __proto = Watcher.prototype;\n\n  __proto.getStatus = function () {\n    return {\n      _prevPos: this._prevPos,\n      scrollPos: this.getOrgScrollPos()\n    };\n  };\n\n  __proto.setStatus = function (status, applyScrollPos) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    this._prevPos = status._prevPos;\n    applyScrollPos && this.scrollTo(status.scrollPos);\n  };\n\n  __proto.scrollBy = function (pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollBy(this._view, arrPos[0], arrPos[1]);\n    this.setScrollPos();\n  };\n\n  __proto.scrollTo = function (pos) {\n    var arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollTo(this._view, arrPos[0], arrPos[1]);\n  };\n\n  __proto.getScrollPos = function () {\n    return this._prevPos;\n  };\n\n  __proto.setScrollPos = function (pos) {\n    if (pos === void 0) {\n      pos = this.getOrgScrollPos();\n    }\n\n    this._prevPos = pos - this.getContainerOffset();\n  };\n\n  __proto.attachEvent = function () {\n    addEvent(this._view, \"scroll\", this._onCheck);\n    addEvent(win, \"resize\", this._onResize);\n  };\n\n  __proto.getOrgScrollPos = function () {\n    return scroll(this._view, this.options.horizontal);\n  };\n\n  __proto.reset = function () {\n    this._prevPos = null;\n  };\n\n  __proto.getContainerOffset = function () {\n    return this._containerOffset;\n  };\n\n  __proto.resize = function () {\n    this._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n  };\n\n  __proto.detachEvent = function () {\n    removeEvent(this._view, \"scroll\", this._onCheck);\n    removeEvent(win, \"resize\", this._onResize);\n  };\n\n  __proto.destroy = function () {\n    this.detachEvent();\n    this.reset();\n  };\n\n  __proto._getOffset = function () {\n    var _a = this.options,\n        container = _a.container,\n        horizontal = _a.horizontal;\n    var rect = container.getBoundingClientRect();\n    return rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n  };\n\n  return Watcher;\n}(); // https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n\n/* eslint-disable */\n// if (typeof Object.create !== \"function\") {\n//   // tslint:disable\n//   Object.create = (o: any, properties: any) => {\n//     if (typeof o !== \"object\" && typeof o !== \"function\") {\n//       throw new TypeError(\"Object prototype may only be an Object: \" + o);\n//     } else if (o === null) {\n//       throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n//     }\n//     function F() { }\n//     F.prototype = o;\n//     return new F();\n//   };\n//   // tslint:enable\n// }\n\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 카드 엘리먼트를 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 카드 엘리먼트를 다양한 레이아웃으로 배치할 수 있다. 카드 엘리먼트의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n  // ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\n\n\nvar InfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGrid, _super);\n  /**\n   * @param {HTMLElement|String|jQuery} element A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n   * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n   * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>레이아웃을 구성하는 카드 엘리먼트를 선택할 선택자(selector)</ko>\n   * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM의 수를 유지할지 여부를 나타낸다. useRecycle 값이 'true'이면 DOM 개수를 일정하게 유지한다. useRecycle 값이 'false' 이면 카드 엘리먼트가 추가될수록 DOM 개수가 계속 증가한다.</ko>\n   * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll 적용여부를 결정한다.</ko>\n   * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향)</ko>\n   * @param {Boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>위로 스크롤할 시 아이템을 추가하는 동안 보이는 빈 공간을 안보이게 한다.</ko>\n   * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>카드 엘리먼트의 크기가 동일한지 여부. 배치될 카드 엘리먼트의 크기가 모두 동일할 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n   * @param {Boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>모든 카드 엘리먼트의 크기가 불변일 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n   * @param {Number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>트랜지션 효과를 완료하는데 걸리는 시간을 나타낸다.</ko>\n   * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>레이아웃에 카드 엘리먼트를 추가하는 이벤트가 발생하는 기준 영역의 크기.</ko>\n   * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>엘리먼트의 데이타 속성에 사용할 접두사.</ko>\n   * @param {boolean} [options.renderExternal=false] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\n   */\n\n\n  function InfiniteGrid(element, options) {\n    var _this = _super.call(this) || this;\n\n    _this._loadingBar = {};\n    _this._requestGroups = [];\n    assign(_this.options = __assign({}, DEFAULT_OPTIONS), options);\n    DEFENSE_BROWSER && (_this.options.useFit = false);\n    IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\n    _this._reset();\n\n    var _a = _this.options,\n        isOverflowScroll = _a.isOverflowScroll,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize,\n        horizontal = _a.horizontal,\n        threshold = _a.threshold,\n        useRecycle = _a.useRecycle,\n        attributePrefix = _a.attributePrefix;\n    _this._itemManager = new ItemManager();\n    _this._renderer = new DOMRenderer(element, {\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      horizontal: horizontal,\n      container: isOverflowScroll\n    });\n    _this._watcher = new Watcher(_this._renderer.view, {\n      isOverflowScroll: isOverflowScroll,\n      horizontal: horizontal,\n      container: _this._renderer.container,\n      resize: function () {\n        return _this._onResize();\n      },\n      check: function (param) {\n        return _this._onCheck(param);\n      }\n    });\n    _this._infinite = new Infinite(_this._itemManager, {\n      useRecycle: useRecycle,\n      threshold: threshold,\n      append: function (param) {\n        return _this._requestAppend(param);\n      },\n      prepend: function (param) {\n        return _this._requestPrepend(param);\n      },\n      recycle: function (param) {\n        return _this._recycle([param]);\n      }\n    });\n    _this._renderManager = new RenderManager(_this._infinite, _this._itemManager, _this._renderer, {\n      attributePrefix: attributePrefix,\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      horizontal: horizontal\n    });\n    return _this;\n  }\n  /**\n   * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko 카드 엘리먼트를 레이아웃 아래에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n   * 이 메소드는 isProcessing()의 반환값이 false일 경우에만 사용 가능하다.\n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트의 배열</ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.append([HTMLElement1, HTMLElement2]);\n   * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  var __proto = InfiniteGrid.prototype;\n\n  __proto.append = function (elements, groupKey) {\n    this._layout && this._insert({\n      elements: elements,\n      isAppend: true,\n      groupKey: groupKey\n    });\n    return this;\n  };\n  /**\n   * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko 카드 엘리먼트를 레이아웃의 위에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트 배열</ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n   * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  __proto.prepend = function (elements, groupKey) {\n    this._layout && this._insert({\n      elements: elements,\n      isAppend: false,\n      groupKey: groupKey\n    });\n    return this;\n  };\n  /**\n   * Specifies the Layout class to use.\n   * @ko 사용할 Layout 클래스를 지정한다.\n   * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko>사용할 Layout 클래스 또는 레이아웃 모듈의 인스턴스</ko>\n   * @param {Object} options Options to apply to the Layout.<ko>Layout에 적용할 옵션</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n   *  margin: 10,\n   *  align: \"start\"\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n   *  margin: 10,\n   *  minSize: 100,\n   *  maxSize: 200\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n   *  margin: 10,\n   *  column: 2\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n   *  margin: 10,\n   *  frame: [\n   *   [1, 2],\n   *   [4, 3],\n   *  ]\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n   *  margin: 10,\n   *  aspectRatio: 1.5\n   * });\n   * var layout = new eg.InfiniteGrid.GridLayout({\n   *   margin: 10,\n   *  align: \"start\"\n   * });\n   * infinitegrid.setLayout(layout);\n   */\n\n\n  __proto.setLayout = function (LayoutKlass, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var horizontal = this.options.horizontal;\n\n    if (typeof LayoutKlass === \"function\") {\n      this._layout = new LayoutKlass(assign(options, {\n        horizontal: horizontal\n      }));\n    } else {\n      LayoutKlass.options.horizontal = horizontal;\n      this._layout = LayoutKlass;\n    }\n\n    this._renderManager.setLayout(this._layout);\n\n    this._renderer.resize();\n\n    this._setSize(this._renderer.getViewportSize());\n\n    return this;\n  };\n  /**\n   * Returns the layouted items.\n   * @ko 레이아웃된 아이템들을 반환한다.\n   * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>캐싱된 아이템을 포함할지 여부를 나타낸다.</ko>\n   * @returns List of items <ko>아이템의 목록</ko>\n   */\n\n\n  __proto.getItems = function (includeCached) {\n    if (includeCached === void 0) {\n      includeCached = false;\n    }\n\n    return includeCached ? this._itemManager.pluck(\"items\") : this._infinite.getVisibleItems();\n  };\n  /**\n   * @param - Get items to render on screen.\n   * @ko 화면에 렌더될 아이템들 가져온다.\n   * @private\n   * @param - The groups currently being added by request.<ko>요청에 의해 지금 추가중인 그룹들.</ko>\n   * @return - The items to be rendered on screen. <ko>화면레 렌더될 아이템들.</ko>\n   */\n\n\n  __proto.getRenderingItems = function () {\n    var items = this.getItems();\n    var itemKeys = {};\n    items.forEach(function (item) {\n      itemKeys[item.itemKey] = true;\n    });\n    var nextVisisbleItems = ItemManager.pluck(this._requestGroups, \"items\").filter(function (item) {\n      if (itemKeys[item.itemKey]) {\n        return false;\n      }\n\n      itemKeys[item.itemKey] = true;\n      return true;\n    });\n    return items.concat(nextVisisbleItems);\n  };\n  /**\n   * Synchronize info of items with info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 아이템의 정보들을 동기화한다.\n   * @private\n   * @param - all item infos to synchronize <ko>동기화할 전체 아이템 정보들.</ko>\n   */\n\n\n  __proto.beforeSync = function (items) {\n    return this._infinite.sync(items);\n  };\n  /**\n   * Synchronize info of items with DOM info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 DOM의 정보와 현재 아이템 정보를 동기화 한다.\n   * @private\n   * @param - The DOM elements that are currently visible.<ko>현재 보여지고 있는 DOM 엘리먼트들.</ko>\n   * @param - The groups currently being added by request.<ko>요청에 의해 지금 추가중인 그룹들.</ko>\n   */\n\n\n  __proto.sync = function (elements) {\n    var itemManager = this._itemManager;\n    var infinite = this._infinite;\n    var items = this.getRenderingItems();\n    items.forEach(function (item, i) {\n      var isChange = item.el !== elements[i];\n      item.el = elements[i];\n\n      if (isChange) {\n        DOMRenderer.renderItem(item, item.rect);\n      }\n    });\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    var newItems = items.filter(function (item) {\n      return !item.orgSize || !item.orgSize.width;\n    });\n\n    if (newItems.length) {\n      this._postLayout({\n        fromCache: false,\n        groups: infinite.getVisibleData(),\n        newItems: newItems,\n        isAppend: true,\n        isTrusted: false\n      });\n    } else {\n      var size = itemManager.size();\n\n      if (!size) {\n        this._requestAppend({});\n      } else if (infinite.getCursor(\"start\") < 0) {\n        var firstGroup = itemManager.getGroup(0);\n\n        this._postLayout({\n          groups: [firstGroup],\n          hasChildren: false,\n          fromCache: false,\n          isAppend: true\n        });\n      } else {\n        this._infinite.scroll(this._watcher.getScrollPos());\n      }\n    }\n  };\n  /**\n   * Rearranges a layout.\n   * @ko 레이아웃을 다시 배치한다.\n   * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>카드 엘리먼트 재배치 여부</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.layout = function (isRelayout) {\n    if (isRelayout === void 0) {\n      isRelayout = true;\n    }\n\n    if (!this._layout) {\n      return this;\n    }\n\n    var renderer = this._renderer;\n    var itemManager = this._itemManager;\n    var infinite = this._infinite;\n    var isResize = renderer.resize();\n    var items = this.getItems();\n    var _a = this.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize,\n        transitionDuration = _a.transitionDuration;\n    var isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n    var size = itemManager.size();\n\n    this._watcher.resize();\n\n    if (isRelayout) {\n      if (isResize) {\n        this._setSize(renderer.getViewportSize());\n      }\n    } // check childElement\n\n\n    if (!items.length) {\n      var children_1 = toArray(renderer.container.children).filter(function (el) {\n        return el.className.indexOf(IGNORE_CLASSNAME) === -1;\n      });\n      var hasChildren = children_1.length > 0;\n\n      if (size) {\n        var firstGroup = itemManager.getGroup(0);\n\n        if (hasChildren) {\n          firstGroup.items.forEach(function (item, i) {\n            item.el = children_1[i];\n          });\n        } // has items, no visible items\n\n\n        this._postLayout({\n          groups: [firstGroup],\n          hasChildren: hasChildren,\n          fromCache: false,\n          isAppend: true\n        });\n      } else {\n        // no items, no visible items\n        if (hasChildren) {\n          var groupKey = children_1[0].getAttribute(\"data-groupkey\");\n\n          if (typeof groupKey !== \"string\") {\n            groupKey = undefined;\n          }\n\n          this._insert({\n            elements: children_1,\n            isAppend: true,\n            hasChildren: true,\n            groupKey: groupKey\n          });\n        } else {\n          if (renderer.getContainerSize()) {\n            renderer.setContainerSize(0);\n          }\n\n          this._requestAppend({});\n        }\n      }\n\n      return this;\n    } // layout datas\n\n\n    var _b = infinite.getCursors(),\n        startCursor = _b[0],\n        endCursor = _b[1];\n\n    var data = isLayoutAll || !(isRelayout && isResize) ? itemManager.getGroups() : itemManager.sliceGroups(startCursor, endCursor + 1); // LayoutManger interface\n\n    this._relayout(isRelayout, data, isResize ? items : []);\n\n    if (isLayoutAll) {\n      this._fit();\n    } else if (isRelayout && isResize) {\n      itemManager.clearOutlines(startCursor, endCursor);\n    }\n\n    DOMRenderer.renderItems(items, transitionDuration);\n    isRelayout && this._watcher.setScrollPos();\n\n    this._onLayoutComplete({\n      items: items,\n      isAppend: true,\n      fromCache: true,\n      isTrusted: false,\n      useRecycle: false,\n      isLayout: true\n    });\n\n    return this;\n  };\n  /**\n   * Removes a item corresponding to an index on a grid layout.\n   * @ko 그리드 레이아웃에서 인덱스에 해당하는 아이템 삭제한다.\n   * @param - Index of group corresponding to item to remove <ko>삭제할 아이템에 해당하는 그룹의 인덱스</ko>\n   * @param - Index of item to remove on group <ko>그룹에서 삭제할 아이템의 인덱스</ko>\n   * @return {Object}  Removed items information <ko>삭제된 아이템들 정보</ko>\n   */\n\n\n  __proto.removeByIndex = function (groupIndex, itemIndex, isLayout) {\n    if (isLayout === void 0) {\n      isLayout = true;\n    }\n\n    var _a = this._infinite.remove(groupIndex, itemIndex),\n        items = _a.items,\n        group = _a.group;\n\n    items.forEach(function (item) {\n      DOMRenderer.removeElement(item.el);\n    });\n\n    if (items.length) {\n      isLayout && this.layout(!!group);\n      return items;\n    }\n\n    return [];\n  };\n  /**\n   * Removes a item element on a grid layout.\n   * @ko 그리드 레이아웃의 카드 엘리먼트를 삭제한다.\n   * @param {HTMLElement} item element to be removed <ko>삭제될 아이템 엘리먼트</ko>\n   * @return {Object}  Removed items information <ko>삭제된 아이템들 정보</ko>\n   */\n\n\n  __proto.remove = function (element, isLayout) {\n    if (isLayout === void 0) {\n      isLayout = true;\n    }\n\n    var _a = this._itemManager.indexesOfElement(element),\n        groupIndex = _a.groupIndex,\n        itemIndex = _a.itemIndex;\n\n    return this.removeByIndex(groupIndex, itemIndex, isLayout);\n  };\n  /**\n   * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n   * @ko 현재 유지하고 있는 카드 엘리먼트의 그룹 키 목록을 반환한다. 여러 개의 카드 엘리먼트를 묶어서 관리할 수 있도록 append() 메서드나 prepend() 메서드에서 그룹 키를 지정할 수 있다. append() 메서드나 prepend() 메서드에서 그룹 키를 지정하지 않았다면 자동으로 그룹키가 생성된다.\n   * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>캐싱된 그룹을 포함할지 여부를 나타낸다.</ko>\n   * @return {Array} List of group keys <ko>그룹 키의 목록</ko>\n   */\n\n\n  __proto.getGroupKeys = function (includeCached) {\n    var data = includeCached ? this._itemManager.getGroups() : this._infinite.getVisibleData();\n    return data.map(function (v) {\n      return v.groupKey;\n    });\n  };\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko 카드의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n   * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n   */\n\n\n  __proto.getStatus = function (startKey, endKey) {\n    return {\n      _status: assign({}, this._status),\n      _itemManager: this._itemManager.getStatus(startKey, endKey),\n      _renderer: this._renderer.getStatus(),\n      _watcher: this._watcher.getStatus(),\n      _infinite: this._infinite.getStatus(startKey, endKey)\n    };\n  };\n  /**\n   * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n   * @ko getStatue() 메서드가 저장한 정보로 eg.InfiniteGrid 모듈의 상태를 설정한다.\n   * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n   * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>스크롤의 위치를 복원할지 결정한다.</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.setStatus = function (status, applyScrollPos, syncElements) {\n    if (applyScrollPos === void 0) {\n      applyScrollPos = true;\n    }\n\n    if (!status) {\n      return this;\n    }\n\n    var _status = status._status,\n        _renderer = status._renderer,\n        _itemManager = status._itemManager,\n        _watcher = status._watcher,\n        _infinite = status._infinite;\n\n    if (!_status || !_renderer || !_itemManager || !_watcher || !_infinite) {\n      return this;\n    }\n\n    var renderExternal = this.options.renderExternal;\n    var items = this._itemManager;\n    var renderer = this._renderer;\n    var watcher = this._watcher;\n    var infinite = this._infinite;\n    watcher.detachEvent();\n    assign(this._status, _status);\n    this._status.processingStatus = IDLE;\n    items.setStatus(_itemManager);\n    renderer.setStatus(_renderer);\n    infinite.setStatus(_infinite);\n    var visibleItems = this.getItems();\n    var length = visibleItems.length;\n\n    if (renderExternal) {\n      visibleItems.forEach(function (item, i) {\n        item.el = syncElements[i];\n      });\n      DOMRenderer.renderItems(visibleItems);\n    } else {\n      renderer.createAndInsert(visibleItems, true);\n    }\n\n    var isReLayout = renderer.isNeededResize();\n    watcher.setStatus(_watcher, applyScrollPos);\n    watcher.attachEvent();\n    var _a = this.options,\n        isConstantSize = _a.isConstantSize,\n        isEqualSize = _a.isEqualSize;\n\n    if (!length) {\n      this._requestAppend({\n        cache: []\n      });\n    } else if (isReLayout) {\n      renderer.resize();\n\n      this._setSize(renderer.getViewportSize());\n\n      if (isConstantSize) {\n        this.layout(true);\n      } else {\n        this._itemManager.clearOutlines();\n\n        this._postLayout({\n          fromCache: true,\n          groups: isEqualSize ? items.getGroups() : infinite.getVisibleData(),\n          items: visibleItems,\n          newItems: visibleItems,\n          isAppend: true,\n          isTrusted: false\n        });\n      }\n    } else {\n      this.layout(false);\n    }\n\n    return this;\n  };\n  /**\n   * Clears added card elements and data.\n   * @ko 추가된 카드 엘리먼트와 데이터를 모두 지운다.\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.clear = function () {\n    this._itemManager.clear();\n\n    this._renderer.clear();\n\n    this._infinite.clear();\n\n    this._reset();\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n  /**\n   * Specifies the Loading Bar to use for append or prepend items.\n   * @ko 아이템을 append 또는 prepend 하기 위해 사용할 로딩 바를 지정한다.\n   * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko> 로딩 바 HTML 또는 element 또는 selector </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.setLoadingBar = function (userLoadingBar) {\n    if (userLoadingBar === void 0) {\n      userLoadingBar = {};\n    }\n\n    var loadingBarObj = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n      append: userLoadingBar,\n      prepend: userLoadingBar\n    };\n    this._status.loadingSize = 0;\n    this._status.loadingStyle = {};\n    var loadingBar = this._loadingBar;\n    var isChangeLoadingBar = false;\n\n    for (var type in loadingBarObj) {\n      var loadingElement = $(loadingBarObj[type]);\n\n      if (loadingBar[type] !== loadingElement) {\n        loadingBar[type] = loadingElement;\n        isChangeLoadingBar = true;\n      }\n\n      if (!hasClass(loadingElement, IGNORE_CLASSNAME)) {\n        addClass(loadingElement, IGNORE_CLASSNAME);\n      }\n    }\n\n    if (isChangeLoadingBar) {\n      this._renderLoading();\n    }\n\n    this._appendLoadingBar();\n\n    return this;\n  };\n  /**\n   * Checks whether a card element or data is being added.\n   * @ko 카드 엘리먼트 추가 또는 데이터 로딩이 진행 중인지 확인한다\n   * @return {Boolean} Indicates whether a card element or data is being added <ko>카드 엘리먼트 추가 또는 데이터 로딩 진행 중 여부</ko>\n   */\n\n\n  __proto.isProcessing = function () {\n    return this._isProcessing() || this.isLoading();\n  };\n  /**\n   * Checks whether data is loading.\n   * @ko 데이터 로딩 중인지 확인한다\n   * @return {Boolean} Indicates whether data is loading <ko>데이터 로딩 진행 중 여부</ko>\n   */\n\n\n  __proto.isLoading = function () {\n    return this._getLoadingStatus() > 0;\n  };\n  /**\n   * Returns the element of loading bar.\n   * @ko 로딩 바의 element를 반환한다.\n   * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n   * @return {Element} The element of loading bar. <ko>로딩 바의 element</ko>\n   */\n\n\n  __proto.getLoadingBar = function (isAppend) {\n    if (isAppend === void 0) {\n      isAppend = this._getLoadingStatus() !== LOADING_PREPEND;\n    }\n\n    return this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n  };\n  /**\n   * Start loading for append/prepend during loading data.\n   * @ko 데이터가 로딩되는 동안 append/prepend하길 위해 로딩을 시작한다.\n   * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n   * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.startLoading = function (isAppend, userStyle) {\n    var _this = this;\n\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"block\"\n      };\n    }\n\n    if (this.isLoading()) {\n      return this;\n    }\n\n    var type = isAppend ? \"append\" : \"prepend\";\n\n    this._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\n    if (!this._loadingBar[type]) {\n      return this;\n    }\n\n    var next = function () {\n      _this._renderLoading(userStyle);\n\n      _this._status.loadingStyle = userStyle;\n\n      if (!isAppend) {\n        _this._fit();\n      } else {\n        _this._setContainerSize(_this._getEdgeValue(\"end\") + _this._status.loadingSize);\n      }\n    };\n\n    if (this.options.renderExternal) {\n      this.trigger(\"render\", {\n        next: next\n      });\n    } else {\n      next();\n    }\n\n    return this;\n  };\n  /**\n   * End loading after startLoading() for append/prepend\n   * @ko  append/prepend하길 위해 startLoading() 호출해선 걸었던 로딩을 끝낸다.\n   * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.endLoading = function (userStyle) {\n    if (userStyle === void 0) {\n      userStyle = {\n        display: \"none\"\n      };\n    }\n\n    var _a;\n\n    if (!this.isLoading()) {\n      return this;\n    }\n\n    var isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    var type = isAppend ? \"append\" : \"prepend\";\n    var el = this._loadingBar[type];\n    var status = this._status;\n    var size = status.loadingSize;\n\n    this._process(LOADING_APPEND | LOADING_PREPEND, false);\n\n    status.loadingSize = 0;\n    status.loadingStyle = {};\n\n    if (el) {\n      var style = assign((_a = {}, _a[this.options.horizontal ? \"left\" : \"top\"] = -size + \"px\", _a), userStyle);\n\n      for (var property in style) {\n        el.style[property] = style[property];\n      }\n\n      if (!isAppend) {\n        this._fitItems(size);\n      } else {\n        this._setContainerSize(this._getEdgeValue(\"end\"));\n      }\n\n      if (this.options.renderExternal) {\n        this.trigger(\"render\", {\n          next: function () {}\n        });\n      }\n    }\n\n    if (this.options.useRecycle && !this.isProcessing()) {\n      this._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n    }\n\n    return this;\n  };\n  /**\n   * Retrieves the item via index or the element.\n   * @ko index 또는 element를 통해 아이템을 가져온다.\n   * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item에 해당하는 element 또는 해당 item이 있는 group의 index</ko>\n   * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex를 사용할 경우 해당 group에 있는 Item의 index </ko>\n   * @return The item containing the content, size and position,etc<ko>content, size, position 등이 담겨있는 item 정보</ko>\n   * @example\n    ig.getItem(0, 0);\n   ig.getItem(element);\n    {\n    el: HTMLElement,\n    content: \"<div>...</div>\",\n    size: {width: ..., height: ...},\n    rect: {top: ..., left: ..., width: ..., height: ...},\n   }\n   */\n\n\n  __proto.getItem = function (groupIndex, itemIndex) {\n    if (groupIndex === void 0) {\n      groupIndex = 0;\n    }\n\n    if (typeof groupIndex === \"object\") {\n      if (!groupIndex) {\n        return;\n      }\n\n      var items = this.getItems();\n      var length = items.length;\n\n      for (var i = 0; i < length; ++i) {\n        if (items[i].el === groupIndex) {\n          return items[i];\n        }\n      }\n\n      return undefined;\n    } else {\n      var group = this._itemManager.getGroup(groupIndex);\n\n      return group && group.items[itemIndex || 0];\n    }\n  };\n  /**\n   * Updates the item via index or the element.\n   * @ko index 또는 element를 통해 아이템을 업데이트한다.\n   * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item에 해당하는 element 또는 해당 item이 있는 group의 index</ko>\n   * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex를 사용할 경우 해당 group에 있는 Item의 index </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n  element.innerHTML = \"2\";\n  element.style.height = \"400px\";\n  ig.updateItem(element);\n  ig.updateItem(0, 0);\n   */\n\n\n  __proto.updateItem = function (groupIndex, itemIndex) {\n    var item = this.getItem(groupIndex, itemIndex);\n    this._updateItem(item) && this.layout(false);\n    return this;\n  };\n  /**\n   * Update the currently displayed items.\n   * @ko 현재보여주는 아이템들을 업데이트한다.\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n  element.innerHTML = \"2\";\n  element.style.height = \"400px\";\n   element2.innerHTML = \"2\";\n  element2.style.height = \"400px\";\n   ig.updateItems();\n   */\n\n\n  __proto.updateItems = function () {\n    var _this = this;\n\n    this.getItems().forEach(function (item) {\n      _this._updateItem(item);\n    });\n    this.layout(false);\n    return this;\n  };\n  /**\n   * Move to some group or item position.\n   * @ko 해당하는 그룹 또는 아이템의 위치로 이동한다.\n   * @param {Number} [index] group's index <ko> 그룹의 index</ko>\n   * @param {Number} [itemIndex=-1] item's index <ko> 그룹의 index</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n\n\n  __proto.moveTo = function (index, itemIndex) {\n    var _this = this;\n\n    if (itemIndex === void 0) {\n      itemIndex = 0;\n    }\n\n    if (this.isProcessing()) {\n      return this;\n    }\n\n    var data = this._itemManager.getGroup(index);\n\n    if (!data) {\n      return this;\n    }\n\n    var infinite = this._infinite;\n    var outlines = data.outlines;\n    var items = data.items;\n    var item = items[itemIndex];\n    var isResize = outlines.start && outlines.start.length === 0;\n\n    var _a = infinite.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    var isInCursor = startCursor <= index && index <= endCursor;\n    var _b = this.options,\n        useRecycle = _b.useRecycle,\n        horizontal = _b.horizontal;\n\n    if (isInCursor || !useRecycle || !isResize) {\n      var pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max.apply(Math, outlines.start);\n      var fit = Math.min.apply(Math, outlines.start);\n\n      if (fit < 0) {\n        // base < 0\n        this._fitItems(fit, 0);\n\n        pos -= fit;\n      }\n\n      var isAppend = index > startCursor;\n\n      if (isInCursor || isAppend) {\n        this._scrollTo(pos);\n\n        return this;\n      }\n\n      this._postLayout({\n        fromCache: true,\n        groups: [data],\n        items: items,\n        newItems: [],\n        isAppend: isAppend,\n        isTrusted: false\n      }).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n        var itemManager = _this._itemManager;\n\n        if (!itemManager) {\n          return;\n        }\n\n        var scrollPos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n\n        if (!isInCursor) {\n          itemManager.clearOutlines(start, end);\n        }\n\n        _this._scrollTo(scrollPos);\n\n        _this._setScrollPos(scrollPos);\n      });\n\n      return this;\n    } else {\n      var isAppend = index > endCursor || index < startCursor - 1;\n\n      this._postCache({\n        isAppend: isAppend,\n        cache: [data],\n        isTrusted: false\n      }).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n        var itemManager = _this._itemManager;\n\n        if (!itemManager) {\n          return;\n        }\n\n        var pos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n        itemManager.clearOutlines(start, end);\n\n        _this._scrollTo(pos);\n\n        _this._setScrollPos(pos);\n      });\n    }\n\n    return this;\n  };\n  /**\n  * Destroys elements, properties, and events used on a grid layout.\n  * @ko 그리드 레이아웃에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n  */\n\n\n  __proto.destroy = function () {\n    this._infinite.clear();\n\n    this._watcher.destroy();\n\n    this._reset();\n\n    this._itemManager.clear();\n\n    this._renderer.destroy();\n  };\n\n  __proto._relayout = function (isRelayout, groups, items) {\n    var renderer = this._renderer;\n    var _a = renderer.options,\n        isEqualSize = _a.isEqualSize,\n        isConstantSize = _a.isConstantSize;\n    var layoutGroups = groups.filter(function (group) {\n      var item = group.items[0];\n      return item.orgSize && item.rect.top > DUMMY_POSITION / 10;\n    });\n\n    if (!layoutGroups.length) {\n      return [];\n    }\n\n    var outline = layoutGroups[0].outlines.start;\n\n    if (isRelayout) {\n      outline = [outline.length ? Math.min.apply(Math, outline) : 0];\n\n      if (!isConstantSize && items.length) {\n        renderer.updateSize(items); // update invisible items' size\n\n        if (isEqualSize && items[0].size) {\n          ItemManager.pluck(layoutGroups, \"items\").forEach(function (item) {\n            item.size = assign({}, items[0].size);\n          });\n        }\n      }\n    }\n\n    this._layout.layout(layoutGroups, outline);\n  };\n\n  __proto._setContainerSize = function (size) {\n    this._renderer.setContainerSize(Math.max(this._itemManager.getMaxEdgeValue(), size));\n  };\n\n  __proto._appendLoadingBar = function () {\n    if (!this.options.renderExternal) {\n      var loadingBar = this._loadingBar;\n      var container = this._renderer.container;\n\n      for (var type in loadingBar) {\n        container.appendChild(loadingBar[type]);\n      }\n    }\n  };\n\n  __proto._setSize = function (size) {\n    this._infinite.setSize(this._renderer.getViewSize());\n\n    this._layout.setSize(size);\n  };\n\n  __proto._fitItems = function (base, margin) {\n    if (margin === void 0) {\n      margin = 0;\n    }\n\n    base > 0 && this._watcher.scrollBy(-base);\n\n    this._itemManager.fit(base, this.options.horizontal);\n\n    DOMRenderer.renderItems(this.getItems());\n\n    this._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\n    base < 0 && this._watcher.scrollBy(-base);\n  }; // called by visible\n\n\n  __proto._fit = function (useFit) {\n    if (useFit === void 0) {\n      useFit = this.options.useFit;\n    }\n\n    var base = this._getEdgeValue(\"start\");\n\n    var margin = this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize || 0;\n    var _a = this.options,\n        isConstantSize = _a.isConstantSize,\n        isEqualSize = _a.isEqualSize,\n        useRecycle = _a.useRecycle;\n\n    if (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n      if (base < margin) {\n        this._fitItems(base - margin, margin);\n      }\n\n      base = 0;\n    } else if (base !== 0 || margin) {\n      this._fitItems(base - margin, margin);\n    } else {\n      return 0;\n    }\n\n    this.isLoading() && this._renderLoading();\n    return base;\n  };\n\n  __proto._getEdgeValue = function (cursor) {\n    return this._infinite.getEdgeValue(cursor);\n  };\n\n  __proto._isProcessing = function () {\n    return (this._status.processingStatus & PROCESSING) > 0;\n  };\n\n  __proto._getLoadingStatus = function () {\n    return this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n  };\n\n  __proto._process = function (status, isAdd) {\n    if (isAdd === void 0) {\n      isAdd = true;\n    }\n\n    if (isAdd) {\n      this._status.processingStatus |= status;\n    } else {\n      this._status.processingStatus -= this._status.processingStatus & status;\n    }\n  };\n\n  __proto._insert = function (_a) {\n    var elements = _a.elements,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        _b = _a.groupKey,\n        groupKey = _b === void 0 ? new Date().getTime() + Math.floor(Math.random() * 1000) : _b;\n\n    if (this._isProcessing() || elements.length === 0) {\n      return;\n    }\n\n    var items = ItemManager.toItems($(elements, true), groupKey);\n\n    this._insertItems({\n      items: items,\n      isAppend: isAppend,\n      hasChildren: hasChildren,\n      groupKey: groupKey\n    });\n  };\n\n  __proto._insertItems = function (_a) {\n    var items = _a.items,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        _b = _a.groupKey,\n        groupKey = _b === void 0 ? new Date().getTime() + Math.floor(Math.random() * 1000) : _b;\n\n    if (!items.length) {\n      return;\n    }\n\n    var group = this._itemManager[isAppend ? \"appendGroup\" : \"prependGroup\"]({\n      groupKey: groupKey,\n      items: items\n    });\n\n    if (!isAppend) {\n      var infinite = this._infinite;\n\n      var _c = infinite.getCursors(),\n          startCursor = _c[0],\n          endCursor = _c[1];\n\n      infinite.setCursor(\"start\", startCursor + 1);\n      infinite.setCursor(\"end\", endCursor + 1);\n    }\n\n    this._postLayout({\n      fromCache: false,\n      groups: [group],\n      items: group.items,\n      newItems: group.items,\n      isAppend: isAppend,\n      hasChildren: hasChildren,\n      isTrusted: false\n    });\n  }; // add items, and remove items for recycling\n\n\n  __proto._recycle = function (ranges) {\n    var _this = this;\n\n    var _a = this.options,\n        useRecycle = _a.useRecycle,\n        renderExternal = _a.renderExternal;\n\n    if (!useRecycle) {\n      return false;\n    }\n\n    var isRecycle = false;\n    ranges.forEach(function (_a) {\n      var start = _a.start,\n          end = _a.end;\n\n      if (start === -1 || end === -1 || end < start) {\n        return;\n      }\n\n      var items = _this._itemManager.pluck(\"items\", start, end);\n\n      isRecycle = isRecycle || items.some(function (item) {\n        return item.mounted;\n      });\n      items.forEach(function (item) {\n        item.mounted = false;\n      });\n\n      if (!renderExternal) {\n        DOMRenderer.removeItems(items);\n      }\n    });\n\n    if (isRecycle) {\n      this._requestGroups = [];\n      this.trigger(\"render\", {\n        next: function () {}\n      });\n    }\n\n    return isRecycle;\n  };\n\n  __proto._renderLoading = function (userStyle) {\n    if (userStyle === void 0) {\n      userStyle = this._status.loadingStyle;\n    }\n\n    if (!this.isLoading()) {\n      return;\n    }\n\n    var isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    var el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n    if (!el) {\n      return;\n    }\n\n    var style = assign({\n      position: \"absolute\"\n    }, userStyle);\n\n    for (var property in style) {\n      el.style[property] = style[property];\n    }\n\n    this._status.loadingSize = this.options.horizontal ? outerWidth(el) : outerHeight(el);\n    var posName = this.options.horizontal ? \"left\" : \"top\";\n\n    if (!(posName in style)) {\n      var pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n      el.style[posName] = pos + \"px\";\n    }\n  };\n\n  __proto._updateItem = function (item) {\n    if (item && item.el) {\n      item.content = item.el.outerHTML;\n      !this.options.isEqualSize && resetSize(item);\n\n      this._renderer.updateSize([item]);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  __proto._setScrollPos = function (pos) {\n    this._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n  };\n\n  __proto._scrollTo = function (pos) {\n    this._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n  };\n\n  __proto._postCache = function (_a) {\n    var cache = _a.cache,\n        isAppend = _a.isAppend,\n        _b = _a.isTrusted,\n        isTrusted = _b === void 0 ? true : _b;\n    var isConstantSize = this.options.isConstantSize;\n    var items = ItemManager.pluck(cache, \"items\");\n    var fromCache = true;\n    var newItems = items.filter(function (item) {\n      if (!item.orgSize || !item.orgSize.width) {\n        fromCache = false;\n        return true;\n      }\n\n      return !isConstantSize && item.rect.top < DUMMY_POSITION / 10;\n    });\n    return this._postLayout({\n      fromCache: fromCache,\n      groups: cache,\n      items: items,\n      newItems: newItems,\n      isAppend: isAppend,\n      isTrusted: isTrusted\n    });\n  };\n\n  __proto._postLayout = function (_a) {\n    var _this = this;\n\n    var fromCache = _a.fromCache,\n        groups = _a.groups,\n        _b = _a.items,\n        items = _b === void 0 ? ItemManager.pluck(groups, \"items\") : _b,\n        newItems = _a.newItems,\n        isAppend = _a.isAppend,\n        hasChildren = _a.hasChildren,\n        isTrusted = _a.isTrusted;\n\n    this._process(PROCESSING);\n\n    if (!groups.length) {\n      return;\n    }\n\n    var renderExternal = this.options.renderExternal;\n    var renderer = this._renderer;\n    var callbackComponent = new Component();\n\n    var next = function () {\n      items.forEach(function (item) {\n        item.mounted = true;\n      });\n\n      _this._renderManager.render(callbackComponent, groups, newItems, isAppend).on(\"renderComplete\", function (_a) {\n        var start = _a.start,\n            end = _a.end;\n\n        _this._setCursor(start, end);\n      }).on(\"imageError\", function (e) {\n        /**\n         * This event is fired when an error occurs in the image.\n         * @ko 이미지 로드에 에러가 날 때 발생하는 이벤트.\n         * @event eg.InfiniteGrid#imageError\n         * @param {eg.InfiniteGrid.IErrorCallbackOptions} e The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n         * @example\n        ig.on(\"imageError\", e => {\n        e.remove();\n        e.removeItem();\n        e.replace(\"http://...jpg\");\n        e.replace(imageElement);\n        e.replaceItem(\"item html\");\n        });\n        */\n        _this.trigger(\"imageError\", assign(e, {\n          element: e.item.el\n        }));\n      }).on(\"layoutComplete\", function (_a) {\n        var layoutItems = _a.items;\n\n        _this._process(PROCESSING, false);\n\n        _this._onLayoutComplete({\n          items: layoutItems,\n          isAppend: isAppend,\n          fromCache: fromCache,\n          isTrusted: isTrusted,\n          useRecycle: false\n        });\n      }).on(\"finish\", function (_a) {\n        var remove = _a.remove,\n            layout = _a.layout;\n        remove.forEach(function (el) {\n          return _this.remove(el, false);\n        });\n\n        if (layout) {\n          _this.layout(false);\n        } else if (!_this.isProcessing() && _this.options.useRecycle) {\n          var scroller = _this._watcher;\n          var scrollPos = scroller.getScrollPos();\n\n          _this._infinite.recycle(scrollPos, isAppend);\n        }\n      });\n    };\n\n    if (!hasChildren) {\n      if (renderExternal) {\n        if (items.every(function (item) {\n          return item.mounted;\n        })) {\n          next();\n        } else {\n          this._requestGroups = groups;\n          this.trigger(\"render\", {\n            next: function () {\n              !hasChildren && DOMRenderer.renderItems(items);\n              next();\n            }\n          });\n        }\n\n        return callbackComponent;\n      } else {\n        // If container has children, it does not render first.\n        renderer.createAndInsert(items, isAppend);\n      }\n    }\n\n    next();\n    return callbackComponent;\n  }; // called by visible\n\n\n  __proto._requestAppend = function (_a) {\n    var _this = this;\n\n    var cache = _a.cache;\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: true\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n       * @ko 카드 엘리먼트가 레이아웃의 아래나 오른쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 아래나 오른쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다\n       * @event eg.InfiniteGrid#append\n       * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 마지막 그룹의 그룹키</ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n       * @param {Function} param.startLoading Start loading for append loading data. <ko> 뒷쪽에 추가되는 데이터 로딩을 시작한다. </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩을 시작할 때 로딩 바에 적용될 사용자 스타일 </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n       */\n      this.trigger(\"append\", {\n        isTrusted: true,\n        groupKey: this.getGroupKeys().pop() || \"\",\n        startLoading: function (userStyle) {\n          _this.startLoading(true, userStyle);\n        },\n        endLoading: function (userStyle) {\n          _this.endLoading(userStyle);\n        }\n      });\n    }\n  }; // called by visible\n\n\n  __proto._requestPrepend = function (_a) {\n    var _this = this;\n\n    var cache = _a.cache;\n\n    this._fit(this.options.useFit || !cache || !cache.length);\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache: cache,\n        isAppend: false\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n       * @ko 카드가 레이아웃의 위나 왼쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 위나 왼쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다.\n       * @event eg.InfiniteGrid#prepend\n       * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 첫번째 그룹의 그룹키</ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n       * @param {Function} param.startLoading Start loading for prepend loading data. <ko> 앞쪽에 추가되는 데이터 로딩을 시작한다. </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩을 시작할 때 로딩 바에 적용될 사용자 스타일 </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n       */\n      this.trigger(\"prepend\", {\n        isTrusted: true,\n        groupKey: this.getGroupKeys().shift(),\n        startLoading: function (userStyle) {\n          _this.startLoading(false, userStyle);\n        },\n        endLoading: function (userStyle) {\n          _this.endLoading(userStyle);\n        }\n      });\n    }\n  };\n\n  __proto._onResize = function () {\n    this.layout(true);\n  };\n\n  __proto._setCursor = function (start, end) {\n    var infinite = this._infinite;\n\n    var _a = infinite.getCursors(),\n        startCursor = _a[0],\n        endCursor = _a[1];\n\n    infinite.setCursor(\"start\", start);\n    infinite.setCursor(\"end\", end);\n\n    var isRecycle = this._recycle([{\n      start: startCursor,\n      end: start - 1\n    }, {\n      start: end + 1,\n      end: endCursor\n    }]);\n\n    if (!isRecycle) {\n      this._requestGroups = [];\n      this.trigger(\"render\", {\n        next: function () {}\n      });\n    }\n  };\n\n  __proto._onCheck = function (_a) {\n    var isForward = _a.isForward,\n        scrollPos = _a.scrollPos,\n        horizontal = _a.horizontal,\n        orgScrollPos = _a.orgScrollPos;\n    /**\n     * This event is fired when the user scrolls.\n     * @ko 사용자가 스크롤 할 경우 발생하는 이벤트.\n     * @event eg.InfiniteGrid#change\n     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>스크롤 진행방향이 앞쪽으로 진행하는 지, 뒤쪽으로 진행하는지를 나타낸다.</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n     * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n     * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n     */\n\n    this.trigger(\"change\", {\n      isForward: isForward,\n      horizontal: horizontal,\n      scrollPos: scrollPos,\n      orgScrollPos: orgScrollPos\n    });\n\n    this._infinite.scroll(scrollPos);\n  };\n\n  __proto._onLayoutComplete = function (_a) {\n    var _this = this;\n\n    var items = _a.items,\n        isAppend = _a.isAppend,\n        _b = _a.isTrusted,\n        isTrusted = _b === void 0 ? false : _b,\n        _c = _a.useRecycle,\n        useRecycle = _c === void 0 ? this.options.useRecycle : _c,\n        _d = _a.fromCache,\n        fromCache = _d === void 0 ? false : _d,\n        _e = _a.isLayout,\n        isLayout = _e === void 0 ? false : _e;\n\n    var viewSize = this._renderer.getViewSize();\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this.isLoading() && this._renderLoading();\n    }\n\n    var watcher = this._watcher;\n    var scrollPos = watcher.getScrollPos(); // recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\n    if (!isLayout && useRecycle && !this.isLoading()) {\n      this._infinite.recycle(scrollPos, isAppend);\n    }\n\n    var size = this._getEdgeValue(\"end\");\n\n    if (isAppend) {\n      this._setContainerSize(size + this._status.loadingSize || 0);\n\n      if (typeof scrollPos === \"number\" && scrollPos > 0) {\n        !IS_IOS && this._scrollTo(scrollPos);\n      }\n    }\n    /**\n     * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n     * @ko 레이아웃 배치가 완료됐을 때 발생하는 이벤트. append() 메서드나 prepend() 메서드, layout() 메서드 호출 후 카드의 배치가 완료됐을 때 발생한다\n     * @event eg.InfiniteGrid#layoutComplete\n     *\n     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @param {Array} param.target Rearranged card elements<ko>재배치된 카드 엘리먼트들</ko>\n     * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>해당 아이템들이 캐시인지 아닌지 확인한다.</ko>\n     * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>해당 이벤트가 리사이즈 이벤트 또는 layout() 메서드를 통해 호출됐으면 true, 아이템 추가로 호출됐으면 false를 반환한다.</ko>\n     * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>카드 엘리먼트가 append() 메서드로 추가됐는지 확인한다. layout() 메서드가 호출된 후 layoutComplete 이벤트가 발생해도 'true'를 반환한다.</ko>\n     * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend 등 호출 후 스크롤이 생겼는지 확인한다.</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n     * @param {Number} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n     * @param {Number} param.size The size of container element <ko>컨테이너 엘리먼트의 크기</ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n     * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n     * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n     */\n\n\n    this.trigger(\"layoutComplete\", {\n      target: items.concat(),\n      isAppend: !!isAppend,\n      isTrusted: isTrusted,\n      fromCache: fromCache,\n      isLayout: isLayout,\n      isScroll: viewSize < watcher.getContainerOffset() + size,\n      scrollPos: scrollPos,\n      orgScrollPos: watcher.getOrgScrollPos(),\n      size: size,\n      endLoading: function (userStyle) {\n        _this.endLoading(userStyle);\n      }\n    });\n\n    this._infinite.scroll(scrollPos);\n  };\n\n  __proto._reset = function () {\n    this._status = {\n      processingStatus: IDLE,\n      loadingSize: 0,\n      loadingStyle: {}\n    };\n  };\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @type {String}\n   * @example\n   * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n   * @memberof eg.InfiniteGrid\n   */\n\n\n  InfiniteGrid.VERSION = \"3.6.2\";\n  return InfiniteGrid;\n}(Component);\n\nvar START = ALIGN.START,\n    CENTER = ALIGN.CENTER,\n    END = ALIGN.END,\n    JUSTIFY = ALIGN.JUSTIFY;\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 카드를 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 카드 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>아이템들의 위치의 정렬 (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n  margin: 10,\n  align: \"start\",\n  itemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n  margin: 10,\n  align: \"center\",\n  itemSize: 200,\n  horizontal: true,\n});\n\n</script>\n```\n **/\n\nvar GridLayout = /*#__PURE__*/function () {\n  function GridLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      align: START,\n      itemSize: 0\n    }, options);\n    this._size = 0;\n    this._columnSize = 0;\n    this._columnLength = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.GridLayout#append\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  var __proto = GridLayout.prototype;\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko 아이템을 아웃라인 위에 추가한다.\n   * @method eg.InfiniteGrid.GridLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.GridLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    var _this = this;\n\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var firstItem = groups.length && groups[0].items.length && groups[0].items[0];\n    this.checkColumn(firstItem); // if outlines' length and columns' length are now same, re-caculate outlines.\n\n    var startOutline;\n\n    if (outline.length !== this._columnLength) {\n      var pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline); // re-layout items.\n\n      startOutline = fill(new Array(this._columnLength), pos);\n    } else {\n      startOutline = outline.slice();\n    }\n\n    groups.forEach(function (group) {\n      var items = group.items;\n\n      var result = _this._layout(items, startOutline, true);\n\n      group.outlines = result;\n      startOutline = result.end;\n    });\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko 레이아웃의 가시 사이즈를 설정한다.\n   * @method eg.InfiniteGrid.GridLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n\n  __proto.checkColumn = function (item) {\n    var _a = this.options,\n        itemSize = _a.itemSize,\n        margin = _a.margin,\n        horizontal = _a.horizontal;\n    var sizeName = horizontal ? \"height\" : \"width\";\n    var columnSize = Math.floor(itemSize || item && item.size[sizeName] || 0) || 0;\n    this._columnSize = columnSize;\n\n    if (!columnSize) {\n      this._columnLength = 1;\n      return;\n    }\n\n    this._columnLength = Math.max(Math.floor((this._size + margin) / (columnSize + margin)), 1);\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _a;\n\n    var length = items.length;\n    var margin = this.options.margin;\n    var align = this.options.align;\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n    var columnSize = this._columnSize;\n    var columnLength = this._columnLength;\n    var size = this._size;\n    var viewDist = size - (columnSize + margin) * columnLength + margin;\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var startOutline = outline.slice();\n    var endOutline = outline.slice();\n\n    for (var i = 0; i < length; ++i) {\n      var point = Math[pointCaculateName].apply(Math, endOutline) || 0;\n      var index = endOutline.indexOf(point);\n      var item = items[isAppend ? i : length - 1 - i];\n      var itemSize = item.size;\n\n      if (!itemSize) {\n        continue;\n      }\n\n      var size1 = itemSize[size1Name];\n      var size2 = itemSize[size2Name];\n      var pos1 = isAppend ? point : point - margin - size1;\n      var endPos1 = pos1 + size1 + margin;\n\n      if (index === -1) {\n        index = 0;\n      }\n\n      var pos2 = (columnSize + margin) * index; // ALIGN\n\n      if (align === CENTER) {\n        pos2 += viewDist / 2;\n      } else if (align === END) {\n        pos2 += viewDist + columnSize - size2;\n      } else if (align === JUSTIFY) {\n        if (columnLength <= 1) {\n          pos2 += viewDist / 2;\n        } else {\n          pos2 = (size - columnSize) / (columnLength - 1) * index;\n        }\n      } // tetris\n\n\n      item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a);\n      item.column = index;\n      endOutline[index] = isAppend ? endPos1 : pos1;\n    }\n\n    if (!isAppend) {\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    } // if append items, startOutline is low, endOutline is high\n    // if prepend items, startOutline is high, endOutline is low\n\n\n    return {\n      start: isAppend ? startOutline : endOutline,\n      end: isAppend ? endOutline : startOutline\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var clone = cache ? items : cloneItems(items);\n    var startOutline = outline;\n\n    if (!this._columnLength) {\n      this.checkColumn(items[0]);\n    }\n\n    if (outline.length !== this._columnLength) {\n      startOutline = fill(new Array(this._columnLength), outline.length ? Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0 : 0);\n    }\n\n    var result = this._layout(clone, startOutline, isAppend);\n\n    return {\n      items: clone,\n      outlines: result\n    };\n  };\n\n  return GridLayout;\n}();\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\n\n\nfunction disableFrame(frame, type, top, left, width, height) {\n  for (var i = top; i < top + height; ++i) {\n    for (var j = left; j < left + width; ++j) {\n      if (type !== frame[i][j]) {\n        continue;\n      }\n\n      frame[i][j] = 0;\n    }\n  }\n}\n\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n  var size = {\n    left: left,\n    top: top,\n    type: type,\n    width: 1,\n    height: 1\n  };\n\n  for (var i = left; i < width; ++i) {\n    if (frame[top][i] === type) {\n      size.width = i - left + 1;\n      continue;\n    }\n\n    break;\n  }\n\n  for (var i = top; i < height; ++i) {\n    if (frame[i][left] === type) {\n      size.height = i - top + 1;\n      continue;\n    }\n\n    break;\n  } // After finding the shape, it will not find again.\n\n\n  disableFrame(frame, type, top, left, size.width, size.height);\n  return size;\n}\n\nfunction getShapes(frame) {\n  var height = frame.length;\n  var width = height ? frame[0].length : 0;\n  var shapes = [];\n\n  for (var i = 0; i < height; ++i) {\n    for (var j = 0; j < width; ++j) {\n      var type = frame[i][j];\n\n      if (!type) {\n        continue;\n      } // Separate shapes with other numbers.\n\n\n      shapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n    }\n  }\n\n  shapes.sort(function (a, b) {\n    return a.type < b.type ? -1 : 1;\n  });\n  return {\n    shapes: shapes,\n    width: width,\n    height: height\n  };\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout은 주어진 프레임에 맞춰 카드를 배치하는 레이아웃입니다. 디자이너가 직접 이미지를 배치하는 것과 알고리즘을 사용한 배치의 중간 정도 수준에 해당하는 레이아웃이다.\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko> 다음 프레임이 전 프레임에 이어 붙일 수 있는지 있는지 확인한다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n  margin: 10,\n  itemSize: 200,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n  margin: 10,\n  itemSize: 200,\n  horizontal: true,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n</script>\n```\n **/\n\n\nvar FrameLayout = /*#__PURE__*/function () {\n  function FrameLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      itemSize: 0,\n      frame: [],\n      frameFill: true\n    }, options);\n    var frame = this.options.frame.map(function (row) {\n      return row.slice();\n    });\n    this._itemSize = this.options.itemSize || 0; // divide frame into shapes.\n\n    this._shapes = getShapes(frame);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.FrameLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  var __proto = FrameLayout.prototype;\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko 레이아웃의 가시 사이즈를 설정한다.\n   * @method eg.InfiniteGrid.FrameLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.FrameLayout#append\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko 아이템을 아웃라인 위에 추가한다.\n   * @method eg.InfiniteGrid.FrameLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n\n  __proto._getItemSize = function () {\n    this._checkItemSize();\n\n    return this._itemSize;\n  };\n\n  __proto._checkItemSize = function () {\n    if (this.options.itemSize) {\n      this._itemSize = this.options.itemSize;\n      return;\n    }\n\n    var style = this._style;\n    var size = style.size2;\n    var margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / this._shapes[size] - margin;\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var _a;\n\n    var length = items.length;\n    var style = this._style;\n    var _b = this.options,\n        margin = _b.margin,\n        frameFill = _b.frameFill;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n\n    var itemSize = this._getItemSize();\n\n    var isItemObject = typeof itemSize === \"object\";\n    var itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n    var itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n    var shapesSize = this._shapes[size2Name];\n    var shapes = this._shapes.shapes;\n    var shapesLength = shapes.length;\n    var startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    var endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    var dist = 0;\n    var end = 0;\n\n    if (!shapesLength) {\n      return {\n        start: outline,\n        end: outline\n      };\n    }\n\n    for (var i = 0; i < length; i += shapesLength) {\n      for (var j = 0; j < shapesLength && i + j < length; ++j) {\n        var item = items[i + j];\n        var shape = shapes[j];\n        var shapePos1 = shape[pos1Name];\n        var shapePos2 = shape[pos2Name];\n        var shapeSize1 = shape[size1Name];\n        var shapeSize2 = shape[size2Name];\n        var pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n        var pos2 = shapePos2 * (itemSize2 + margin);\n        var size1 = shapeSize1 * (itemSize1 + margin) - margin;\n        var size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n        for (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n          if (startOutline[k] === DUMMY_POSITION) {\n            startOutline[k] = pos1;\n          }\n\n          startOutline[k] = Math.min(startOutline[k], pos1);\n          endOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n        }\n\n        item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a[size1Name] = size1, _a[size2Name] = size2, _a);\n      }\n\n      end = Math.max.apply(Math, endOutline); // check dist once\n\n      if (i !== 0) {\n        continue;\n      } // find & fill empty block\n\n\n      if (!frameFill) {\n        dist = 0;\n        continue;\n      }\n\n      dist = end;\n\n      for (var j = 0; j < shapesSize; ++j) {\n        if (startOutline[j] === DUMMY_POSITION) {\n          continue;\n        } // the dist between frame's end outline and next frame's start outline\n        // expect that next frame's start outline is startOutline[j] + end\n\n\n        dist = Math.min(startOutline[j] + end - endOutline[j], dist);\n      }\n    }\n\n    for (var i = 0; i < shapesSize; ++i) {\n      if (startOutline[i] !== DUMMY_POSITION) {\n        continue;\n      }\n\n      startOutline[i] = Math.max.apply(Math, startOutline);\n      endOutline[i] = startOutline[i];\n    } // The target outline is start outline when type is appending\n\n\n    var targetOutline = isAppend ? startOutline : endOutline;\n    var prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"].apply(Math, outline);\n    var prevOutlineDist = isAppend ? 0 : end;\n\n    if (frameFill && outline.length === shapesSize) {\n      prevOutlineDist = -DUMMY_POSITION;\n\n      for (var i = 0; i < shapesSize; ++i) {\n        if (startOutline[i] === endOutline[i]) {\n          continue;\n        } // if appending type is prepend(false), subtract dist from appending group's height.\n\n\n        prevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n      }\n    }\n\n    for (var i = 0; i < shapesSize; ++i) {\n      startOutline[i] += prevOutlineEnd - prevOutlineDist;\n      endOutline[i] += prevOutlineEnd - prevOutlineDist;\n    }\n\n    items.forEach(function (item) {\n      item.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n    });\n    return {\n      start: startOutline.map(function (point) {\n        return parseInt(point, 10);\n      }),\n      end: endOutline.map(function (point) {\n        return parseInt(point, 10);\n      })\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return FrameLayout;\n}();\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n  var point = Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0;\n\n  if (outline.length !== columnLength) {\n    return fill(new Array(columnLength), 0);\n  }\n\n  return outline.map(function (l) {\n    return Math.floor((l - point) / itemSize);\n  });\n}\n\nfunction getColumn(item) {\n  if (item.column) {\n    return item.column;\n  }\n\n  var column = 1;\n\n  if (item.el) {\n    column = parseInt(item.el.getAttribute(\"data-column\"), 10) || 1;\n  }\n\n  item.column = column;\n  return column;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout은 바둑판처럼 모든 카드를 정사각형으로 배치하고 중요한 카드는 크기를 N배로 키워서 보여주는 레이아웃이다. 주요 카드를 크게 표시하고, 그 다음에 작은 카드를 배치해 자연스럽게 카드의 관계를 나타낼 수 있습니다.\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. (priority: `column` > `itemSize` > element's size)<ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (우선순위: `column` > `itemSize` > 엘리먼트의 사이즈) </ko>\n * @param {Boolean} [options.column=0] The number of columns in the layout. If it is 0, the column is returned by `itemSize`.  (priority: `column` > `itemSize` > element's size)<ko> 레이아웃의 열의 개수. 만약 column이 0이면, `itemSize`로 열을 구합니다. (우선순위: `column` > `itemSize` > 엘리먼트의 사이즈) </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n    horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n    margin: 10,\n    itemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n    margin: 10,\n    itemSize: 200,\n    horizontal: true,\n});\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\n\n\nvar SquareLayout = /*#__PURE__*/function (_super) {\n  __extends(SquareLayout, _super);\n\n  function SquareLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _super.call(this, options) || this;\n  }\n\n  var __proto = SquareLayout.prototype;\n\n  __proto._layout = function (items, outline, isAppend) {\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    if (isAppend === void 0) {\n      isAppend = false;\n    }\n\n    var _a, _b;\n\n    var itemSize = this._getSquareSize(items[0]);\n\n    var margin = this.options.margin;\n    var columnLength = this.options.column || Math.floor((this._size + margin) / (itemSize + margin)) || 1;\n    var length = items.length;\n    var endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n    var pointCaculateName = isAppend ? \"min\" : \"max\";\n    var shapes = [];\n    var sign = isAppend ? 1 : -1;\n    var style = this._style;\n    var pos1Name = style.startPos1;\n    var pos2Name = style.startPos2;\n\n    for (var i = 0; i < length; ++i) {\n      var point = Math[pointCaculateName].apply(Math, endOutline);\n      var index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n      var item = items[i];\n      var columnWidth = item.columnWidth;\n      var column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);\n      var columnCount = 1;\n\n      if (column > 1) {\n        for (var j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {\n          if (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {\n            ++columnCount;\n            continue;\n          }\n\n          break;\n        }\n\n        if (!isAppend) {\n          index -= columnCount - 1;\n        }\n      }\n\n      item.columnWidth = [columnLength, columnCount];\n      shapes.push((_a = {\n        width: columnCount,\n        height: columnCount\n      }, _a[pos1Name] = point - (!isAppend ? columnCount : 0), _a[pos2Name] = index, _a.type = i + 1, _a.index = i, _a));\n\n      for (var j = 0; j < columnCount; ++j) {\n        endOutline[index + j] = point + sign * columnCount;\n      }\n    }\n\n    this._shapes = (_b = {\n      shapes: shapes\n    }, _b[style.size2] = columnLength, _b);\n\n    var result = _super.prototype._layout.call(this, items, outline, isAppend);\n\n    if (!isAppend) {\n      shapes.sort(function (shape1, shape2) {\n        var item1pos1 = shape1[pos1Name];\n        var item1pos2 = shape1[pos2Name];\n        var item2pos1 = shape2[pos1Name];\n        var item2pos2 = shape2[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n      items.sort(function (a, b) {\n        var item1pos1 = a.rect[pos1Name];\n        var item1pos2 = a.rect[pos2Name];\n        var item2pos1 = b.rect[pos1Name];\n        var item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    }\n\n    return result;\n  };\n\n  __proto._getSquareSize = function (item) {\n    var _a = this.options,\n        column = _a.column,\n        margin = _a.margin,\n        itemSize = _a.itemSize;\n\n    if (column) {\n      // if column is in options, caculate itemSize from column.\n      this._itemSize = (this._size + margin) / column - margin;\n    } else if (itemSize) {\n      this._itemSize = this.options.itemSize;\n    } else {\n      var sizeName = this._style.size2; // if frameSize is 0, caculate frameSize from item.size.\n\n      var frameSize = this._shapes[sizeName] || Math.floor((this._size + margin) / (item.size[sizeName] + margin) / getColumn(item));\n      this._itemSize = (this._size + margin) / frameSize - margin;\n    }\n\n    return this._itemSize;\n  };\n\n  return SquareLayout;\n}(FrameLayout);\n\nvar BoxModel = /*#__PURE__*/function () {\n  function BoxModel(options) {\n    assign(this, {\n      originWidth: 0,\n      originHeight: 0,\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0,\n      items: []\n    }, options);\n  }\n\n  var __proto = BoxModel.prototype;\n\n  __proto.scaleTo = function (width, height) {\n    var scaleX = this.width ? width / this.width : 0;\n    var scaleY = this.height ? height / this.height : 0;\n    this.items.forEach(function (v) {\n      if (scaleX !== 0) {\n        v.left *= scaleX;\n        v.width *= scaleX;\n      }\n\n      if (scaleY !== 0) {\n        v.top *= scaleY;\n        v.height *= scaleY;\n      }\n    });\n    this.width = width;\n    this.height = height;\n  };\n\n  __proto.push = function (item) {\n    this.items.push(item);\n  };\n\n  __proto.getOriginSize = function () {\n    return this.originWidth * this.originHeight;\n  };\n\n  __proto.getSize = function () {\n    return this.width * this.height;\n  };\n\n  __proto.getOriginRatio = function () {\n    return this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n  };\n\n  __proto.getRatio = function () {\n    return this.height === 0 ? 0 : this.width / this.height;\n  };\n\n  return BoxModel;\n}();\n\nfunction getCost(originLength, length) {\n  var cost = originLength / length;\n\n  if (cost < 1) {\n    cost = 1 / cost;\n  }\n\n  return cost - 1;\n}\n\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n  item.height = itemFitSize.height;\n  item.width = itemFitSize.width;\n  bestFitArea.height = containerFitSize.height;\n  bestFitArea.width = containerFitSize.width;\n\n  if (layoutVertical) {\n    item.top = bestFitArea.top + bestFitArea.height;\n    item.left = bestFitArea.left;\n  } else {\n    item.left = bestFitArea.left + bestFitArea.width;\n    item.top = bestFitArea.top;\n  }\n}\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout은 카드의 본래 크기에 따른 비중을 해치지 않으면서 중요한 카드는 더 크게 보여 주는 레이아웃이다. 행과 열이 구분돼 이미지를 정돈되게 배치하는 대신 가로세로 일정 공간 내에서 동적으로 카드를 배치한다.\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko> 그룹의 가로 세로 비 </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko> 이미지를 배치할 때 사이즈 가중치 </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko> 이미지를 배치할 때 비율 가중치 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n  horizontal: true,\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n</script>\n```\n **/\n\n\nvar PackingLayout = /*#__PURE__*/function () {\n  function PackingLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      aspectRatio: 1,\n      sizeWeight: 1,\n      ratioWeight: 1\n    }, options);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.PackingLayout#append\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  var __proto = PackingLayout.prototype;\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko 아이템을 아웃라인 위에 추가한다.\n   * @method eg.InfiniteGrid.PackingLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.PackingLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n  /**\n   * Set the viewport size of the layout.\n   * @ko 레이아웃의 가시 사이즈를 설정한다.\n   * @method eg.InfiniteGrid.PackingLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n\n  __proto._findBestFitArea = function (container, item) {\n    if (container.getRatio() === 0) {\n      // 아이템 최초 삽입시 전체영역 지정\n      container.originWidth = item.width;\n      container.originHeight = item.height;\n      container.width = item.width;\n      container.height = item.height;\n      return;\n    }\n\n    var bestFitArea;\n    var minCost = 10000000;\n    var layoutVertical = false;\n    var itemFitSize = {\n      width: 0,\n      height: 0\n    };\n    var containerFitSize = {\n      width: 0,\n      height: 0\n    };\n    var _a = this.options,\n        sizeWeight = _a.sizeWeight,\n        ratioWeight = _a.ratioWeight;\n    container.items.forEach(function (v) {\n      var containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n      var containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n      var width = v.width;\n      var height = v.height;\n      var cost;\n\n      for (var i = 0; i < 2; ++i) {\n        var itemWidth = void 0;\n        var itemHeight = void 0;\n        var containerWidth = void 0;\n        var containerHeight = void 0;\n\n        if (i === 0) {\n          // 상하에 아이템 추가\n          itemWidth = width;\n          itemHeight = height * (item.height / (v.originHeight + item.height));\n          containerWidth = width;\n          containerHeight = height - itemHeight;\n        } else {\n          // 좌우에 아이템 추가\n          itemHeight = height;\n          itemWidth = width * (item.width / (v.originWidth + item.width));\n          containerHeight = height;\n          containerWidth = width - itemWidth;\n        }\n\n        var itemSize = itemWidth * itemHeight;\n        var itemRatio = itemWidth / itemHeight;\n        var containerSize = containerWidth * containerHeight;\n        var containerRatio = containerHeight / containerHeight;\n        cost = getCost(item.getSize(), itemSize) * sizeWeight;\n        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n        cost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n        cost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n        if (cost === Math.min(cost, minCost)) {\n          minCost = cost;\n          bestFitArea = v;\n          layoutVertical = i === 0;\n          itemFitSize.width = itemWidth;\n          itemFitSize.height = itemHeight;\n          containerFitSize.width = containerWidth;\n          containerFitSize.height = containerHeight;\n        }\n      }\n    });\n    fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _this = this;\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var style = this._style;\n    var _a = this.options,\n        horizontal = _a.horizontal,\n        aspectRatio = _a.aspectRatio,\n        margin = _a.margin;\n    var pos1Name = style.startPos1;\n    var containerWidth = this._size * (horizontal ? aspectRatio : 1);\n    var containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n    var containerSize1 = horizontal ? containerWidth : containerHeight;\n    var prevOutline = toZeroArray(outline);\n    var start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;\n    var end = start + containerSize1 + margin;\n    var container = new BoxModel({});\n    items.forEach(function (item) {\n      var _a = item.orgSize,\n          width = _a.width,\n          height = _a.height;\n      var model = new BoxModel({\n        width: width,\n        height: height,\n        originWidth: width,\n        originHeight: height\n      });\n\n      _this._findBestFitArea(container, model);\n\n      container.push(model);\n      container.scaleTo(containerWidth + margin, containerHeight + margin);\n    });\n    items.forEach(function (item, i) {\n      var boxItem = container.items[i];\n      var width = boxItem.width;\n      var height = boxItem.height;\n      var top = boxItem.top;\n      var left = boxItem.left;\n      item.rect = {\n        top: top,\n        left: left,\n        width: width - margin,\n        height: height - margin\n      };\n      item.rect[pos1Name] += start;\n    });\n    return {\n      start: [start],\n      end: [end]\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return PackingLayout;\n}();\n/* eslint-disable */\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\n\n\nfunction single_source_shortest_paths(graph, s, d) {\n  // Predecessor map for each node that has been encountered.\n  // node ID => predecessor node ID\n  var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.\n  // node ID => cost\n\n  var costs = {};\n  costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from\n  // `costs` in that it provides easy access to the node that currently has\n  // the known shortest path from s.\n  // XXX: Do we actually need both `costs` and `open`?\n\n  var open = new BinaryHeap(function (x) {\n    return x.cost;\n  });\n  open.push({\n    value: s,\n    cost: 0\n  });\n  var closest;\n  var u;\n  var cost_of_s_to_u;\n  var adjacent_nodes;\n  var cost_of_e;\n  var cost_of_s_to_u_plus_cost_of_e;\n  var cost_of_s_to_v;\n  var first_visit;\n\n  while (open.size()) {\n    // In the nodes remaining in graph that have a known cost from s,\n    // find the node, u, that currently has the shortest path from s.\n    closest = open.pop();\n    u = closest.value;\n    cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...\n\n    adjacent_nodes = graph(u) || {}; // ...and explore the edges that connect u to those nodes, updating\n    // the cost of the shortest paths to any or all of those nodes as\n    // necessary. v is the node across the current edge from u.\n\n    for (var v in adjacent_nodes) {\n      // Get the cost of the edge running from u to v.\n      cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*\n      // cost from s to v that may or may not be less than the current\n      // known cost to v.\n\n      cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to\n      // v is greater than the new cost we just found (cost of s to u plus\n      // cost of u to v across e), update v's cost in the cost list and\n      // update v's predecessor in the predecessor list (it's now u).\n\n      cost_of_s_to_v = costs[v];\n      first_visit = typeof costs[v] === \"undefined\";\n\n      if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n        costs[v] = cost_of_s_to_u_plus_cost_of_e;\n        open.push({\n          value: v,\n          cost: cost_of_s_to_u_plus_cost_of_e\n        });\n        predecessors[v] = u;\n      }\n    }\n  }\n\n  if (typeof costs[d] === \"undefined\") {\n    var msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n    throw new Error(msg);\n  }\n\n  return predecessors;\n}\n\nfunction extract_shortest_path_from_predecessor_list(predecessors, d) {\n  var nodes = [];\n  var u = d;\n\n  while (u) {\n    nodes.push(u);\n    u = predecessors[u];\n  }\n\n  nodes.reverse();\n  return nodes;\n}\n\nfunction find_path(graph, s, d) {\n  var predecessors = single_source_shortest_paths(graph, s, d);\n  return extract_shortest_path_from_predecessor_list(predecessors, d);\n}\n\nvar BinaryHeap = /*#__PURE__*/function () {\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  var __proto = BinaryHeap.prototype;\n\n  __proto.push = function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to bubble up.\n\n    this.bubbleUp(this.content.length - 1);\n  };\n\n  __proto.pop = function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return result;\n  };\n\n  __proto.size = function () {\n    return this.content.length;\n  };\n\n  __proto.bubbleUp = function (_n) {\n    var n = _n; // Fetch the element that has to be moved.\n\n    var element = this.content[n]; // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1;\n      var parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break;\n      }\n    }\n  };\n\n  __proto.sinkDown = function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n    var child1Score;\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2;\n      var child1N = child2N - 1; // This is used to store the new position of the element,\n      // if any.\n\n      var swap = null; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap == null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        // Otherwise, we are done.\n        break;\n      }\n    }\n  };\n\n  return BinaryHeap;\n}();\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. 용어의 의미대로 너비가 주어진 사이즈를 기준으로 카드가 가득 차도록 배치하는 레이아웃이다.\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko> 아이템이 조정되는 최소 크기 </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko> 아이템이 조정되는 최대 크기 </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko> 한 줄에 들어가는 아이템의 개수 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n  column: 5,\n  horizontal: true,\n});\n\n</script>\n```\n **/\n\n\nvar JustifiedLayout = /*#__PURE__*/function () {\n  function JustifiedLayout(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      minSize: 0,\n      maxSize: 0,\n      column: [1, 8]\n    }, options);\n    this._style = getStyleNames(this.options.horizontal);\n    this._size = 0;\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko 레이아웃의 가시 사이즈를 설정한다.\n   * @method eg.InfiniteGrid.JustifiedLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  var __proto = JustifiedLayout.prototype;\n\n  __proto.setSize = function (size) {\n    this._size = size;\n    return this;\n  };\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.JustifiedLayout#append\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.append = function (items, outline, cache) {\n    return this._insert(items, outline, true, cache);\n  };\n  /**\n   * Adds items at the top of a outline.\n   * @ko 아이템을 아웃라인 위에 추가한다.\n   * @method eg.InfiniteGrid.JustifiedLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  __proto.prepend = function (items, outline, cache) {\n    return this._insert(items, outline, false, cache);\n  };\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n   * @method eg.InfiniteGrid.JustifiedLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * layout.layout(groups, [100]);\n   */\n\n\n  __proto.layout = function (groups, outline) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var length = groups.length;\n    var point = outline;\n\n    for (var i = 0; i < length; ++i) {\n      var group = groups[i];\n\n      var outlines = this._layout(group.items, point, true);\n\n      group.outlines = outlines;\n      point = outlines.end;\n    }\n\n    return this;\n  };\n\n  __proto._layout = function (items, outline, isAppend) {\n    var _this = this;\n\n    var style = this._style;\n    var size1Name = style.size1;\n    var size2Name = style.size2;\n    var startIndex = 0;\n    var endIndex = items.length;\n    var column = this.options.column;\n    var columns = typeof column === \"object\" ? column : [column, column];\n\n    var graph = function (_start) {\n      var results = {};\n      var start = +_start.replace(/[^0-9]/g, \"\");\n      var length = endIndex + 1;\n\n      for (var i = Math.min(start + columns[0], length - 1); i < length; ++i) {\n        if (i - start > columns[1]) {\n          break;\n        }\n\n        var cost = _this._getCost(items, start, i, size1Name, size2Name);\n\n        if (cost === null) {\n          continue;\n        }\n\n        if (cost < 0 && i === length - 1) {\n          cost = 0;\n        }\n\n        results[\"\" + i] = Math.pow(cost, 2);\n      }\n\n      return results;\n    }; // shortest path for items' total height.\n\n\n    var path = find_path(graph, \"\" + startIndex, \"\" + endIndex);\n    return this._setStyle(items, path, outline, isAppend);\n  };\n\n  __proto._getSize = function (items, size1Name, size2Name) {\n    var margin = this.options.margin;\n    var size = items.reduce(function (sum, item) {\n      return sum + item.orgSize[size2Name] / item.orgSize[size1Name];\n    }, 0);\n    return (this._size - margin * (items.length - 1)) / size;\n  };\n\n  __proto._getCost = function (items, i, j, size1Name, size2Name) {\n    var size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\n    var min = this.options.minSize || 0;\n    var max = this.options.maxSize || Infinity;\n\n    if (isFinite(max)) {\n      // if this size is not in range, the cost increases sharply.\n      if (size < min) {\n        return Math.pow(size - min, 2) + Math.pow(max, 2);\n      } else if (size > max) {\n        return Math.pow(size - max, 2) + Math.pow(max, 2);\n      } else {\n        // if this size in range, the cost is negative or low.\n        return Math.min(size - max, min - size);\n      }\n    } // if max is infinite type, caculate cost only with \"min\".\n\n\n    if (size < min) {\n      return Math.max(Math.pow(min, 2), Math.pow(size, 2));\n    }\n\n    return size - min;\n  };\n\n  __proto._setStyle = function (items, path, outline, isAppend) {\n    if (outline === void 0) {\n      outline = [];\n    }\n\n    var _a;\n\n    var style = this._style; // if direction is vertical\n    // startPos1 : top, endPos1 : bottom\n    // size1 : height\n    // startPos2 : left, endPos2 : right\n    // size2 : width\n    // if direction is horizontal\n    // startPos1 : left, endPos1 : right\n    // size1 : width\n    // startPos2 : top, endPos2 : bottom\n    // size2 : height\n\n    var pos1Name = style.startPos1;\n    var size1Name = style.size1;\n    var pos2Name = style.startPos2;\n    var size2Name = style.size2;\n    var length = path.length;\n    var margin = this.options.margin;\n    var startPoint = outline[0] || 0;\n    var endPoint = startPoint;\n    var height = 0;\n\n    for (var i = 0; i < length - 1; ++i) {\n      var path1 = parseInt(path[i], 10);\n      var path2 = parseInt(path[i + 1], 10); // pathItems(path1 to path2) are in 1 line.\n\n      var pathItems = items.slice(path1, path2);\n      var pathItemsLength = pathItems.length;\n\n      var size1 = this._getSize(pathItems, size1Name, size2Name);\n\n      var pos1 = endPoint;\n\n      for (var j = 0; j < pathItemsLength; ++j) {\n        var item = pathItems[j];\n        var size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1; // item has margin bottom and right.\n        // first item has not margin.\n\n        var prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n        var pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n        item.rect = (_a = {}, _a[pos1Name] = pos1, _a[pos2Name] = pos2, _a[size1Name] = size1, _a[size2Name] = size2, _a);\n      }\n\n      height += margin + size1;\n      endPoint = startPoint + height;\n    }\n\n    var itemsLength = items.length;\n\n    if (isAppend) {\n      // previous group's end outline is current group's start outline\n      return {\n        start: [startPoint],\n        end: [endPoint]\n      };\n    } // for prepend, only substract height from position.\n    // always start is lower than end.\n\n\n    for (var i = 0; i < itemsLength; ++i) {\n      var item = items[i]; // move items as long as height for prepend\n\n      item.rect[pos1Name] -= height;\n    }\n\n    return {\n      start: [startPoint - height],\n      end: [startPoint]\n    };\n  };\n\n  __proto._insert = function (items, outline, isAppend, cache) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (outline === void 0) {\n      outline = [];\n    } // this only needs the size of the item.\n\n\n    var clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, isAppend)\n    };\n  };\n\n  return JustifiedLayout;\n}();\n/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\n\n\nexport default InfiniteGrid;\nexport { GridLayout, FrameLayout, SquareLayout, PackingLayout, JustifiedLayout, Infinite, DOMRenderer, ItemManager, CONTAINER_CLASSNAME, IGNORE_CLASSNAME, DEFAULT_OPTIONS, INFINITEGRID_METHODS, INFINITEGRID_EVENTS, categorize, withInfiniteGridMethods };","map":{"version":3,"sources":["../src/browser.ts","../src/consts.ts","../src/utils.ts","../src/ItemManager.ts","../src/DOMRenderer.ts","../src/Infinite.ts","../src/RenderManager.ts","../src/Watcher.ts","../src/InfiniteGrid.ts","../src/layouts/GridLayout.ts","../src/layouts/FrameLayout.ts","../src/layouts/SquareLayout.ts","../src/layouts/lib/BoxModel.ts","../src/layouts/PackingLayout.ts","../src/layouts/lib/dijkstra.ts","../src/layouts/JustifiedLayout.ts","../src/index.ts"],"names":["win","document","navigator","userAgent","ua","window","SUPPORT_COMPUTEDSTYLE","SUPPORT_ADDEVENTLISTENER","SUPPORT_PASSIVE","supportsPassiveOption","Object","get","IS_IE","IS_IOS","IS_ANDROID2","CONTAINER_CLASSNAME","IGNORE_CLASSNAME","TRANSITION_NAME","VERTICAL","HORIZONTAL","DUMMY_POSITION","GROUPKEY_ATT","DEFAULT_OPTIONS","itemSelector","isOverflowScroll","threshold","isEqualSize","isConstantSize","useRecycle","horizontal","transitionDuration","useFit","attributePrefix","renderExternal","DEFAULT_LAYOUT_OPTIONS","margin","agent","isMobile","ALIGN","START","CENTER","END","JUSTIFY","IDLE","LOADING_APPEND","LOADING_PREPEND","PROCESSING","webkit","WEBKIT_VERSION","parseInt","DEFENSE_BROWSER","ITEM_KEYS","TRANSITION","TRANSITION_END","INFINITEGRID_EVENTS","INFINITEGRID_METHODS","getLoadingBar","getItem","getItems","layout","getGroupKeys","getStatus","setStatus","isProcessing","startLoading","endLoading","isLoading","updateItem","updateItems","moveTo","nodes","array","length","i","html","param","multi","match","matchHTML","dummy","el","toArray","isWindow","isJQuery","$","Array","element","type","handler","eventListenerOptions","options","callback","removeEvent","addEvent","prop","x","y","isDocument","doc","body","Math","size","clientRect","name","cssSize","getStyles","parseFloat","_getSize","width","outerWidth","height","outerHeight","STYLE","vertical","startPos1","endPos1","size1","startPos2","endPos2","size2","isHorizontal","target","sources","source","defaultOptions","assign","outline","items","arr","value","newItems","newGroups","groupKeys","groupKey","group","item","mounted","content","rect","top","left","prototype","infinitegridName","args","result","className","ItemManager","makeItem","acc","v","datas","startIndex","endIndex","_data","item2","key","data2","data","status","_this","groups","property","base","outlines","start","end","isUndefined","cursor","index","targetValue","startCursor","endCursor","pos","groupIndex","prevItems","newGroup","categorize","diff","removed","added","maintained","nextGroups","fromIndex","toIndex","itemIndex","groupItem","groupItems","nextItems","nextIndex","newItem","styles","removeTransition","pos1","pos2","TRANSFORM","selectContainer","container","children","properties","p","DOMRenderer","prevRect","render","setTransition","addOnceEvent","itemRect","parentNode","noElementItems","elements","view","viewport","cssText","_size","_a","getSize","isResize","innerWidth","innerHeight","style","createContainer","df","isAppend","min","max","endScrollPos","scrollPos","append","prepend","recycle","itemManager","prevVisisbleGroups","prevVisibleItems","startGroup","find","endGroup","findLast","nextStartCursor","nextEndCursor","minCursor","maxCursor","nextVisibleItems","visibleDiffResult","itemKey","_b","visibles","isVisible","isForward","startEdgePos","endEdgePos","startPos","endPos","cache","cachedAppendData","cachedPrependData","isPrepend","checkGroups","replaceTarget","removeTarget","prefix","check","infinite","prevGroup","groupOutline","isRelayout","groupInfo","requestStartCursor","requestEndCursor","isInCursor","tempCursor","callbackComponent","removeItem","hasTarget","remove","replace","removeAutoSizer","replaceItem","totalIndex","removeTargetLength","replaceTargetLength","layoutedItems","resize","_prevPos","applyScrollPos","arrPos","scrollBy","scrollTo","scroll","prevPos","orgScrollPos","clearTimeout","setTimeout","tslib_1","InfiniteGrid","_super","LayoutKlass","includeCached","itemKeys","nextVisisbleItems","isChange","fromCache","isTrusted","firstGroup","hasChildren","renderer","isLayoutAll","children_1","isLayout","_status","_itemManager","_renderer","_watcher","_infinite","watcher","visibleItems","syncElements","isReLayout","userLoadingBar","loadingBarObj","loadingBar","isChangeLoadingBar","loadingElement","hasClass","addClass","userStyle","display","next","fit","layoutGroups","isAdd","_c","isRecycle","ranges","position","posName","resetSize","e","layoutItems","scroller","_d","_e","viewSize","isScroll","processingStatus","loadingSize","loadingStyle","assignOptions","align","itemSize","getStyleNames","firstItem","startOutline","fill","sizeName","columnSize","size1Name","size2Name","pos1Name","pos2Name","columnLength","viewDist","pointCaculateName","endOutline","point","item1pos1","a","item1pos2","item2pos1","b","item2pos2","clone","cloneItems","j","frame","disableFrame","shapes","searchShapeInFrame","frameFill","row","getShapes","isItemObject","itemSize2","itemSize1","shapesSize","shapesLength","dist","shape","shapePos1","shapePos2","shapeSize1","shapeSize2","k","targetOutline","prevOutlineEnd","prevOutlineDist","l","column","makeShapeOutline","sign","columnWidth","getColumn","columnCount","shape1","shape2","frameSize","originWidth","originHeight","scaleX","scaleY","cost","originLength","itemFitSize","bestFitArea","containerFitSize","aspectRatio","sizeWeight","ratioWeight","minCost","layoutVertical","containerSizeCost","getCost","containerRatioCost","itemWidth","itemHeight","containerWidth","containerHeight","itemRatio","containerSize","containerRatio","fitArea","containerSize1","prevOutline","toZeroArray","model","boxItem","predecessors","costs","open","closest","u","cost_of_s_to_u","adjacent_nodes","graph","cost_of_e","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","first_visit","msg","single_source_shortest_paths","extract_shortest_path_from_predecessor_list","n","parentN","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score","minSize","maxSize","columns","results","_start","path","find_path","sum","isFinite","startPoint","endPoint","path1","path2","pathItems","pathItemsLength","prevItemRect","itemsLength"],"mappings":"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","sourcesContent":["let win: Window;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {\n\t\tdocument: {},\n\t\tnavigator: {\n\t\t\tuserAgent: \"\",\n\t\t},\n\t} as Window;\n} else {\n\twin = window;\n}\n\nexport { win as window };\nexport const document = win.document;\n","import { window, document } from \"./browser\";\nimport { IAlign, InfiniteGridMethodsKeys } from \"./types\";\n\nconst ua = window.navigator.userAgent;\n\nexport const SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in window);\nexport const SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nexport const SUPPORT_PASSIVE = (() => {\n\tlet supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\t// tslint:disable-next-line: no-empty\n\t\t\tdocument.addEventListener(\"test\", () => { }, Object.defineProperty({},\n\t\t\t\t\"passive\", {\n\t\t\t\tget() {\n\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t},\n\t\t\t}));\n\t\t}\n\t} catch (e) {\n\t\t//\n\t}\n\treturn supportsPassiveOption;\n})();\n\nexport const IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const IS_ANDROID2 = /Android 2\\./.test(ua);\nexport const CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexport const IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nexport const TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\n\nexport const VERTICAL = \"vertical\";\nexport const HORIZONTAL = \"horizontal\";\n\nexport const DUMMY_POSITION = -100000;\nexport const GROUPKEY_ATT = \"data-groupkey\";\n\nexport const DEFAULT_OPTIONS = {\n\titemSelector: \"*\",\n\tisOverflowScroll: false,\n\tthreshold: 100,\n\tisEqualSize: false,\n\tisConstantSize: false,\n\tuseRecycle: true,\n\thorizontal: false,\n\ttransitionDuration: 0,\n\tuseFit: true,\n\tattributePrefix: \"data-\",\n\trenderExternal: false,\n};\n\nexport const DEFAULT_LAYOUT_OPTIONS = {\n\thorizontal: false,\n\tmargin: 0,\n};\n\nexport const agent = ua.toLowerCase();\nexport const isMobile = /mobi|ios|android/.test(agent);\n\nexport const ALIGN: IAlign = {\n\tSTART: \"start\",\n\tCENTER: \"center\",\n\tEND: \"end\",\n\tJUSTIFY: \"justify\",\n};\n\nexport const IDLE = 0;\nexport const LOADING_APPEND = 1;\nexport const LOADING_PREPEND = 2;\nexport const PROCESSING = 4;\n\nconst webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\n\nexport const WEBKIT_VERSION = (webkit && parseInt(webkit[1], 10)) || 0;\nexport const DEFENSE_BROWSER = (WEBKIT_VERSION && WEBKIT_VERSION < 537);\n\nexport const ITEM_KEYS = [\"content\", \"groupKey\", \"itemKey\", \"orgSize\", \"mounted\", \"prevRect\", \"rect\", \"size\"];\ninterface ITransitionEnd {\n\ttransitionend: string;\n\twebkitTransitionEnd: string;\n\tMSTransitionEnd: string;\n\toTransitionEnd: string;\n\tmozTransitionEnd: string;\n}\n\nexport const [TRANSFORM, TRANSITION, TRANSITION_END] = (() => {\n\tconst properties: ITransitionEnd = {\n\t\ttransitionend: \"\",\n\t\twebkitTransitionEnd: \"-webkit-\",\n\t\tMSTransitionEnd: \"-ms-\",\n\t\toTransitionEnd: \"-o-\",\n\t\tmozTransitionEnd: \"-moz-\",\n\t};\n\n\tfor (const property in properties) {\n\t\tconst prefix = properties[property as keyof ITransitionEnd];\n\n\t\tif (`on${property.toLowerCase()}` in window) {\n\t\t\treturn [`${prefix}transform`, `${prefix}transition`, property];\n\t\t}\n\t}\n\treturn [];\n})() as [\"transform\", \"transition\", \"transitionend\"];\n\nexport const INFINITEGRID_EVENTS = [\"append\", \"prepend\", \"imageError\", \"change\", \"layoutComplete\"];\n\n// It's for making mistakes.\n// Whenever you add a public method, you must add the corresponding method name to an array or object.\n// An additional error may occur if not added.\nexport const INFINITEGRID_METHODS: { [key in InfiniteGridMethodsKeys]: true } = {\n\tgetLoadingBar: true,\n\tgetItem: true,\n\tgetItems: true,\n\tlayout: true,\n\tgetGroupKeys: true,\n\tgetStatus: true,\n\tsetStatus: true,\n\tisProcessing: true,\n\tstartLoading: true,\n\tendLoading: true,\n\tisLoading: true,\n\tupdateItem: true,\n\tupdateItems: true,\n\tmoveTo: true,\n};\n","\nimport { window, document } from \"./browser\";\nimport {\n\tSUPPORT_COMPUTEDSTYLE,\n\tSUPPORT_ADDEVENTLISTENER,\n\tSUPPORT_PASSIVE,\n\tVERTICAL,\n\tHORIZONTAL,\n\tDEFAULT_LAYOUT_OPTIONS,\n\tDUMMY_POSITION,\n\tINFINITEGRID_METHODS,\n} from \"./consts\";\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport { IJQuery, IRectlProperties, InnerSizeType, ClientSizeType, ScrollSizeType, OffsetSizeType, IItem, IGroup, IArrayFormat, IInfiniteGridItem } from \"./types\";\nexport function toArray(nodes: HTMLCollection): HTMLElement[];\nexport function toArray<T extends Node>(nodes: IArrayFormat<T>): T[];\nexport function toArray<T extends Node>(nodes: IArrayFormat<T>): T[] {\n\t// SCRIPT5014 in IE8\n\tconst array: T[] = [];\n\n\tif (nodes) {\n\t\tconst length = nodes.length;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nexport function matchHTML(html: string) {\n\treturn html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nexport function $(param: Window, multi?: false): Window;\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti: true,\n): HTMLElement[];\nexport function $(\n\tparam: string | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti?: false,\n): HTMLElement;\nexport function $(\n\tparam: string | HTMLElement | Window | IJQuery,\n\tmulti?: false,\n): HTMLElement | Window;\nexport function $(\n\tparam: string | Window | HTMLElement | Array<string | HTMLElement> | IJQuery,\n\tmulti = false,\n): HTMLElement | Window | HTMLElement[] {\n\tlet el: Window | HTMLElement | HTMLElement[] | NodeListOf<HTMLElement> | undefined;\n\n\tif (typeof param === \"string\") { // String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tconst match = matchHTML(param);\n\n\t\t// creating element\n\t\tif (match) { // HTML\n\t\t\tconst dummy = document.createElement(\"div\");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = dummy.childNodes as NodeListOf<HTMLElement>;\n\t\t} else { // Selector\n\t\t\tel = document.querySelectorAll<HTMLElement>(param);\n\t\t}\n\t\tif (multi) {\n\t\t\treturn toArray(el as NodeListOf<HTMLElement>);\n\t\t} else {\n\t\t\treturn el && (el as NodeListOf<HTMLElement>)[0];\n\t\t}\n\t} else if (isWindow(param)) { // window\n\t\tel = param;\n\t} else if (isJQuery(param)) { // jQuery\n\t\tel = multi ? $(param.toArray(), true) :\n\t\t\t$(param.get(0), false);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(v => $(v));\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? (el as HTMLElement[])[0] : undefined;\n\t\t}\n\t} else if (param.nodeName &&\n\t\t(param.nodeType === 1 || param.nodeType === 9)) { // HTMLElement, Document\n\t\tel = param;\n\t} else {\n\t\tel = [].slice.call(el);\n\t}\n\treturn el as Window | HTMLElement | HTMLElement[];\n}\nexport function addEvent(\n\telement: Element | Window,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tif (SUPPORT_ADDEVENTLISTENER) {\n\t\tlet options = eventListenerOptions || false;\n\n\t\tif (typeof eventListenerOptions === \"object\") {\n\t\t\toptions = SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if ((element as any).attachEvent) {\n\t\t(element as any).attachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = handler;\n\t}\n}\nexport function removeEvent(\n\telement: Element | Window,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if ((element as any).detachEvent) {\n\t\t(element as any).detachEvent(`on${type}`, handler);\n\t} else {\n\t\t(element as any)[`on${type}`] = null;\n\t}\n}\nexport function addOnceEvent(\n\telement: Element,\n\ttype: string,\n\thandler: (...args: any[]) => any,\n\teventListenerOptions?: boolean | { [key: string]: any },\n) {\n\tconst callback = (e: any) => {\n\t\tremoveEvent(element, type, callback);\n\t\thandler(e);\n\t};\n\n\taddEvent(element, type, callback, eventListenerOptions);\n}\nexport function scroll(el: HTMLElement | Window, horizontal = false) {\n\tconst prop = `scroll${horizontal ? \"Left\" : \"Top\"}` as \"scrollLeft\" | \"scrollTop\";\n\n\tif (isWindow(el)) {\n\t\treturn window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nexport function scrollTo(el: Window | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nexport function scrollBy(el: Window | Element, x: number, y: number) {\n\tif (isWindow(el)) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nexport function getStyles(el: Element) {\n\treturn (SUPPORT_COMPUTEDSTYLE ?\n\t\twindow.getComputedStyle(el) : (el as any).currentStyle) || {};\n}\nfunction _getSize(el: Window | Document | HTMLElement, name: \"Width\" | \"Height\", isOffset?: boolean) {\n\tif (isWindow(el)) { // WINDOW\n\t\treturn window[`inner${name}` as InnerSizeType] || document.body[`client${name}` as ClientSizeType];\n\t} else if (isDocument(el)) { // DOCUMENT_NODE\n\t\tconst doc = (el as Document).documentElement;\n\t\tconst body = (el as Document).body;\n\n\t\treturn Math.max(\n\t\t\tbody[`scroll${name}` as ScrollSizeType], doc[`scroll${name}` as ScrollSizeType],\n\t\t\tbody[`offset${name}` as OffsetSizeType], doc[`offset${name}` as OffsetSizeType],\n\t\t\tdoc[`client${name}` as ClientSizeType],\n\t\t);\n\t} else { // NODE\n\t\tlet size = 0;\n\n\t\tif (isOffset) {\n\t\t\tconst clientRect = el.getBoundingClientRect();\n\n\t\t\tsize = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n\t\t} else {\n\t\t\tsize = el[`client${name}` as ClientSizeType] || el[`offset${name}` as OffsetSizeType];\n\t\t}\n\t\tif (size) {\n\t\t\treturn size;\n\t\t}\n\t\tconst cssSize = getStyles(el)[name.toLowerCase()];\n\n\t\treturn (~cssSize.indexOf(\"px\") && parseFloat(cssSize)) || 0;\n\t}\n}\n\nexport function innerWidth(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", false);\n}\nexport function innerHeight(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", false);\n}\nexport function outerWidth(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Width\", true);\n}\nexport function outerHeight(el: Window | Document | HTMLElement) {\n\treturn _getSize(el, \"Height\", true);\n}\nexport function getSize(el: HTMLElement) {\n\treturn {\n\t\twidth: outerWidth(el),\n\t\theight: outerHeight(el),\n\t};\n}\nexport const STYLE: {\n\tvertical: IRectlProperties,\n\thorizontal: IRectlProperties,\n} = {\n\tvertical: {\n\t\tstartPos1: \"top\",\n\t\tendPos1: \"bottom\",\n\t\tsize1: \"height\",\n\t\tstartPos2: \"left\",\n\t\tendPos2: \"right\",\n\t\tsize2: \"width\",\n\t},\n\thorizontal: {\n\t\tstartPos1: \"left\",\n\t\tendPos1: \"right\",\n\t\tsize1: \"width\",\n\t\tstartPos2: \"top\",\n\t\tendPos2: \"bottom\",\n\t\tsize2: \"height\",\n\t},\n};\n\nexport function getStyleNames(isHorizontal: boolean): IRectlProperties {\n\treturn STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\nexport function assign<A, B>(target: A, source: B): A & B;\nexport function assign<A, B, C>(target: A, source1: B, source2: C): A & B & C;\nexport function assign<A, B, C, D>(target: A, source1: B, source2: C, source3: D): A & B & C & D;\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>): { [key: string]: any };\nexport function assign(target: { [key: string]: any }, ...sources: Array<{ [key: string]: any }>) {\n\tsources.forEach(source => {\n\t\tfor (const key in source) {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t});\n\treturn target;\n}\nexport function assignOptions<A extends { [key: string]: any }, B extends { [key: string]: any }>(\n\tdefaultOptions: A, options: B): typeof DEFAULT_LAYOUT_OPTIONS & A & B {\n\treturn assign({},\n\t\tDEFAULT_LAYOUT_OPTIONS,\n\t\tdefaultOptions,\n\t\toptions);\n}\n\nexport function toZeroArray(outline?: number[]) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\nexport function cloneItems<T extends { [key: string]: any }>(items: T[]) {\n\treturn items.map(item => assign({}, item));\n}\nexport function isJQuery(el: any): el is IJQuery {\n\treturn (typeof (window as any).jQuery === \"function\" && el instanceof (window as any).jQuery) ||\n\t\tel.constructor.prototype.jquery && el.toArray;\n}\nexport function isWindow(el: any): el is Window {\n\treturn el === window;\n}\nexport function isDocument(el: Node): el is Document {\n\treturn el.nodeType === 9;\n}\n\nexport function fill<T>(arr: T[], value: T) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nexport function isUndefined(target: any): target is undefined {\n\treturn typeof target === \"undefined\";\n}\n\nexport function find<T>(arr: T[], callback: (target: T) => any) {\n\tconst length = arr.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tif (callback(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\treturn null;\n}\nexport function findLast<T>(arr: T[], callback: (target: T) => any) {\n\tconst length = arr.length;\n\n\tfor (let i = length - 1; i >= 0; --i) {\n\t\tif (callback(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\treturn null;\n}\nexport function categorize(newItems: IItem[]) {\n\tconst newGroups: IGroup[] = [];\n\tconst groupKeys: { [key: string]: IGroup } = {};\n\n\tnewItems.forEach(item => {\n\t\tconst { groupKey } = item;\n\t\tlet group = groupKeys[groupKey];\n\n\t\tif (!group) {\n\t\t\tgroup = {\n\t\t\t\tgroupKey,\n\t\t\t\titems: [],\n\t\t\t};\n\t\t\tgroupKeys[groupKey] = group;\n\t\t\tnewGroups.push(group);\n\t\t}\n\n\t\tgroup.items.push(item);\n\t});\n\n\treturn newGroups;\n}\n\nexport function resetSize(item: IInfiniteGridItem) {\n\titem.orgSize = null;\n\titem.size = null;\n}\n\nexport function makeItem(groupKey: string | number, el?: HTMLElement) {\n\treturn {\n\t\tel,\n\t\tgroupKey,\n\t\tmounted: false,\n\t\tcontent: el ? el.outerHTML : \"\",\n\t\trect: {\n\t\t\ttop: DUMMY_POSITION,\n\t\t\tleft: DUMMY_POSITION,\n\t\t},\n\t};\n}\n\n/**\n * Decorator that makes the method of infinitegrid available in the framework.\n * @ko 프레임워크에서 인피니트그리드의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.InfiniteGrid\n * @private\n * @example\n * ```js\n * import NativeInfiniteGrid, { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class InfiniteGrid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private infinitegrid: NativeInfiniteGrid;\n * }\n * ```\n */\nexport function withInfiniteGridMethods(prototype: any, infinitegridName: string) {\n\tObject.keys(INFINITEGRID_METHODS).forEach((name: keyof InfiniteGrid) => {\n\t\tif (prototype[name]) {\n\t\t\treturn;\n\t\t}\n\t\tprototype[name] = function(...args) {\n\t\t\tconst result = this[infinitegridName][name](...args);\n\n\t\t\t// fix `this` type to return your own `infinitegrid` instance to the instance using the decorator.\n\t\t\tif (result === this[infinitegridName]) {\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t});\n}\n\nexport function hasClass(element: HTMLElement, className: string) {\n\tif (element.classList) {\n\t\treturn element.classList.contains(className);\n\t}\n\treturn !!element.className.match(new RegExp(`(\\\\s|^)${className}(\\\\s|$)`));\n}\n\nexport function addClass(element: HTMLElement, className: string) {\n\tif (element.classList) {\n\t\telement.classList.add(className);\n\t} else {\n\t\telement.className += ` ${className}`;\n\t}\n}\n","import { diff, DiffResult } from \"@egjs/list-differ\";\nimport { GROUPKEY_ATT, DUMMY_POSITION, ITEM_KEYS } from \"./consts\";\nimport { isUndefined, assign, categorize, makeItem } from \"./utils\";\nimport { CursorType, IInfiniteGridGroup, IInfiniteGridItem, IItemManagerStatus, IItem, IGroup } from \"./types\";\n\nexport default class ItemManager {\n\tpublic static toItems(elements: HTMLElement[], groupKey: string | number): IInfiniteGridItem[] {\n\t\treturn elements.map(el => makeItem(groupKey, el));\n\t}\n\tpublic static pluck<A extends { [key: string]: any }, B extends keyof A>(data: A[], property: B):\n\t\tA[B] extends any[] ? A[B] : Array<A[B]> {\n\t\treturn data.reduce((acc, v) => acc.concat(v[property]), []) as any;\n\t}\n\t// groups\n\tprivate _groups: IInfiniteGridGroup[] = [];\n\t// group keys\n\tprivate _groupKeys: { [key: string]: IInfiniteGridGroup } = {};\n\n\tpublic clear() {\n\t\tthis._groups = [];\n\t\tthis._groupKeys = {};\n\t}\n\tpublic getStatus(startKey?: string | number, endKey?: string | number): IItemManagerStatus {\n\t\tconst datas = this._groups;\n\t\tconst startIndex = Math.max(this.indexOf(startKey), 0);\n\t\tconst endIndex = this.indexOf(endKey) + 1 || datas.length;\n\n\t\treturn {\n\t\t\t_data: datas.slice(startIndex, endIndex).map(data => {\n\t\t\t\tconst items = data.items.map(item => {\n\t\t\t\t\tconst item2 = {} as IInfiniteGridItem;\n\n\t\t\t\t\tITEM_KEYS.forEach(key => {\n\t\t\t\t\t\tif (key in item) {\n\t\t\t\t\t\t\titem2[key] = item[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn item2;\n\t\t\t\t});\n\t\t\t\tconst data2 = assign({}, data);\n\n\t\t\t\tdata2.items = items;\n\t\t\t\treturn data2;\n\t\t\t}),\n\t\t};\n\t}\n\tpublic setStatus(status: IItemManagerStatus) {\n\t\tconst data = status._data;\n\n\t\tthis.clear();\n\n\t\tdata.forEach((group, i) => {\n\t\t\tthis.insertGroup(group, i);\n\t\t});\n\t}\n\tpublic size() {\n\t\treturn this._groups.length;\n\t}\n\tpublic fit(base: number, horizontal: boolean) {\n\t\tconst groups = this._groups;\n\t\tif (!groups.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst property = horizontal ? \"left\" : \"top\";\n\n\t\tif (base !== 0) {\n\t\t\tgroups.forEach(group => {\n\t\t\t\tconst { items, outlines } = group;\n\n\t\t\t\titems.forEach(item => {\n\t\t\t\t\titem.rect[property] -= base;\n\t\t\t\t});\n\t\t\t\toutlines.start = outlines.start.map(start => start - base);\n\t\t\t\toutlines.end = outlines.end.map(end => end - base);\n\t\t\t});\n\t\t}\n\t}\n\tpublic pluck<T extends keyof IInfiniteGridGroup>(property: T, start?: number, end?: number) {\n\t\tconst data = isUndefined(start) ? this._groups : this.sliceGroups(start, (isUndefined(end) ? start : end) + 1);\n\n\t\treturn ItemManager.pluck(data, property);\n\t}\n\tpublic getOutline(index: number, property: keyof IInfiniteGridGroup[\"outlines\"]) {\n\t\tconst data = this._groups[index];\n\n\t\treturn data ? data.outlines[property] : [];\n\t}\n\tpublic getEdgeIndex(cursor: CursorType, start: number, end: number) {\n\t\tconst prop = cursor === \"start\" ? \"min\" : \"max\";\n\t\tlet index = -1;\n\t\tlet targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n\t\tfor (let i = start; i <= end; i++) {\n\t\t\tconst value = Math[prop](...this.getOutline(i, cursor));\n\n\t\t\tif ((cursor === \"start\" && targetValue > value) ||\n\t\t\t\t(cursor === \"end\" && targetValue < value)) {\n\t\t\t\ttargetValue = value;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tpublic getEdgeValue(cursor: CursorType, start: number, end: number) {\n\t\tconst group = this.getGroup(this.getEdgeIndex(cursor, start, end));\n\n\t\tif (group) {\n\t\t\tconst outlines = group.outlines[cursor];\n\n\t\t\tif (outlines.length) {\n\t\t\t\treturn Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic clearOutlines(startCursor = -1, endCursor = -1) {\n\t\tconst datas = this.getGroups();\n\n\t\tdatas.forEach((group, cursor) => {\n\t\t\tif (startCursor <= cursor && cursor <= endCursor) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgroup.items.forEach(item => {\n\t\t\t\titem.rect.top = DUMMY_POSITION;\n\t\t\t\titem.rect.left = DUMMY_POSITION;\n\t\t\t});\n\t\t\tgroup.outlines.start = [];\n\t\t\tgroup.outlines.end = [];\n\t\t});\n\t}\n\tpublic getMaxEdgeValue() {\n\t\tconst groups = this._groups;\n\t\tconst length = groups.length;\n\n\t\tfor (let i = length - 1; i >= 0; --i) {\n\t\t\tconst end = groups[i].outlines.end;\n\n\t\t\tif (end.length) {\n\t\t\t\tconst pos = Math.max(...end);\n\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic prependGroup(group: IGroup): IInfiniteGridGroup | null {\n\t\treturn this.insertGroup(group, 0);\n\t}\n\tpublic appendGroup(group: IGroup): IInfiniteGridGroup | null {\n\t\treturn this.insertGroup(group, this._groups.length);\n\t}\n\tpublic insertGroup(group: IGroup, groupIndex: number): IInfiniteGridGroup | null {\n\t\tif (groupIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst prevItems: IItem[] = group.items || [];\n\t\tconst newGroup: IInfiniteGridGroup = {\n\t\t\toutlines: {\n\t\t\t\tstart: [],\n\t\t\t\tend: [],\n\t\t\t},\n\t\t\t...group,\n\t\t\titems: [],\n\t\t};\n\t\tthis._groups.splice(groupIndex, 0, newGroup);\n\t\tthis._groupKeys[newGroup.groupKey] = newGroup;\n\n\t\tprevItems.forEach((item, i) => {\n\t\t\tthis.insert(item, groupIndex, i);\n\t\t});\n\t\treturn newGroup;\n\t}\n\tpublic sync(items: IItem[]): DiffResult<IGroup> {\n\t\tconst groups = this._groups;\n\t\tconst groupKeys = this._groupKeys;\n\t\tconst newGroups = categorize(items);\n\t\tconst result = diff(groups, newGroups, group => group.groupKey);\n\t\tconst {\n\t\t\tremoved,\n\t\t\tadded,\n\t\t\tmaintained,\n\t\t} = result;\n\n\t\tremoved.forEach(removedIndex => {\n\t\t\tconst group = groups[removedIndex];\n\n\t\t\tif (!group) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdelete groupKeys[group.groupKey];\n\t\t});\n\t\tconst nextGroups: IInfiniteGridGroup[] = [];\n\t\tmaintained.forEach(([fromIndex]) => {\n\t\t\tnextGroups.push(groups[fromIndex]);\n\t\t});\n\t\tthis._groups = nextGroups;\n\n\t\tadded.forEach(addedIndex => {\n\t\t\tthis.insertGroup(newGroups[addedIndex], addedIndex);\n\t\t});\n\t\tmaintained.reverse().forEach(([, toIndex]) => {\n\t\t\tthis.syncItems(toIndex, newGroups[toIndex].items);\n\t\t});\n\t\treturn result;\n\t}\n\tpublic insert(newItem: IItem, groupIndex = -1, itemIndex = -1): IInfiniteGridItem | null {\n\t\tconst { groupKey } = newItem;\n\t\tconst groups = this._groups;\n\t\tconst groupKeys = this._groupKeys;\n\t\tconst group = (groupIndex > -1 ? groups[groupIndex] : groupKeys[groupKey])\n\t\t\t|| this.insertGroup({ groupKey }, groupIndex);\n\n\t\tif (!group) {\n\t\t\treturn null;\n\t\t}\n\t\tconst groupItem: IInfiniteGridItem = {\n\t\t\tcontent: \"\",\n\t\t\tmounted: false,\n\t\t\trect: {\n\t\t\t\ttop: DUMMY_POSITION,\n\t\t\t\tleft: DUMMY_POSITION,\n\t\t\t},\n\t\t\t...newItem,\n\t\t};\n\t\tconst groupItems = group.items;\n\n\t\tif (itemIndex === -1) {\n\t\t\tgroupItems.push(groupItem);\n\t\t} else {\n\t\t\tgroupItems.splice(itemIndex, 0, groupItem);\n\t\t}\n\n\t\treturn groupItem;\n\t}\n\tpublic removeGroup(groupIndex: number): IInfiniteGridGroup | null {\n\t\tconst group = this._groups.splice(groupIndex, 1)[0];\n\n\t\tif (!group) {\n\t\t\treturn null;\n\t\t}\n\t\tdelete this._groupKeys[group.groupKey];\n\n\t\treturn group;\n\t}\n\tpublic remove(groupIndex: number, itemIndex: number) {\n\t\tconst data = this.getGroup(groupIndex);\n\t\tlet group: IInfiniteGridGroup | null = null;\n\t\tlet items: IInfiniteGridItem[] = [];\n\n\t\tif (!data) {\n\t\t\treturn { items, group };\n\t\t}\n\t\t// remove item information\n\t\titems = data.items.splice(itemIndex, 1);\n\n\t\tif (!data.items.length) {\n\t\t\tgroup = this.removeGroup(groupIndex);\n\t\t}\n\t\treturn { items, group };\n\t}\n\tpublic indexOf(data: { groupKey: string | number } | string | number | undefined) {\n\t\tif (typeof data === \"undefined\") {\n\t\t\treturn -1;\n\t\t}\n\t\tconst groupKey = `${typeof data === \"object\" ? data.groupKey : data}`;\n\t\tconst datas = this._groups;\n\t\tconst length = datas.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tif (groupKey === `${datas[i].groupKey}`) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic indexesOfElement(element: HTMLElement) {\n\t\tconst groupKey = element.getAttribute(GROUPKEY_ATT)!;\n\t\tconst groupIndex = this.indexOf({ groupKey });\n\t\tlet itemIndex = -1;\n\n\t\tif (groupIndex > -1) {\n\t\t\tconst data = this.getGroup(groupIndex);\n\n\t\t\tconst length = data.items.length;\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tif (data.items[i].el === element) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { groupIndex, itemIndex };\n\t}\n\tpublic sliceGroups(start?: number, end?: number) {\n\t\treturn this._groups.slice(start, end);\n\t}\n\tpublic getGroups() {\n\t\treturn this._groups;\n\t}\n\tpublic getGroupByKey(key: number | string) {\n\t\treturn this._groupKeys[key];\n\t}\n\tpublic getGroup(index: number) {\n\t\treturn this._groups[index];\n\t}\n\tprivate syncItems(groupIndex: number, newItems: IItem[]) {\n\t\tif (!newItems.length) {\n\t\t\tthis.removeGroup(groupIndex);\n\t\t\treturn;\n\t\t}\n\t\tconst items = this.getGroup(groupIndex).items;\n\t\tconst {\n\t\t\tadded,\n\t\t\tmaintained,\n\t\t} = diff(items, newItems, item => item.itemKey);\n\n\t\tconst group = this._groups[groupIndex];\n\t\tconst nextItems: IInfiniteGridItem[] = [];\n\t\tmaintained.forEach(([fromIndex, nextIndex]) => {\n\t\t\tconst item = items[fromIndex];\n\t\t\tconst newItem = newItems[nextIndex];\n\n\t\t\tassign(item, newItem);\n\t\t\tnextItems.push(item);\n\t\t});\n\n\t\tgroup.items = nextItems;\n\t\tadded.forEach(addedIndex => {\n\t\t\tthis.insert(newItems[addedIndex], groupIndex, addedIndex);\n\t\t});\n\n\t}\n}\n","import {\n\tDUMMY_POSITION,\n\tGROUPKEY_ATT,\n\tCONTAINER_CLASSNAME,\n\tTRANSITION_NAME,\n\tTRANSITION,\n\tTRANSITION_END,\n\tTRANSFORM,\n} from \"./consts\";\nimport { window, document } from \"./browser\";\nimport {\n\t$,\n\tinnerHeight,\n\tinnerWidth,\n\tgetSize,\n\tgetStyles,\n\taddOnceEvent,\n\tassign,\n} from \"./utils\";\nimport { RectType, IPosition, IJQuery, IInfiniteGridItem, IDOMRendererStatus, IDOMRendererSize, IDOMRendererOptions, IDOMRendererOrgStyle } from \"./types\";\n\nfunction removeTransition(styles: HTMLElement[\"style\"]) {\n\tstyles[`${TRANSITION}-property`] = \"\";\n\tstyles[`${TRANSITION}-duration`] = \"\";\n\tstyles[TRANSFORM] = \"\";\n}\nfunction setTransition(styles: HTMLElement[\"style\"], transitionDuration: number, pos1: IPosition, pos2: IPosition) {\n\tif (!transitionDuration) {\n\t\tremoveTransition(styles);\n\t\treturn false;\n\t}\n\tif (pos1.left === pos2.left && pos1.top === pos2.top) {\n\t\treturn false;\n\t}\n\tstyles[`${TRANSITION}-property`] = `${TRANSFORM},width,height`;\n\tstyles[`${TRANSITION}-duration`] = `${transitionDuration}s`;\n\tstyles[TRANSFORM] = `translate(${pos1.left - pos2.left}px,${pos1.top - pos2.top}px)`;\n\treturn true;\n}\n\nfunction createContainer(element: HTMLElement) {\n\tconst selectContainer = element.querySelector<HTMLElement>(`.${CONTAINER_CLASSNAME}`);\n\n\tif (selectContainer) {\n\t\tselectContainer.style.position = \"relative\";\n\t\tselectContainer.style.height = \"100%\";\n\n\t\treturn selectContainer;\n\t}\n\tconst container = document.createElement(\"div\");\n\n\tcontainer.className = CONTAINER_CLASSNAME;\n\tcontainer.style.position = \"relative\";\n\tcontainer.style.height = \"100%\";\n\n\tconst children = element.children;\n\tconst length = children.length;\t// for IE8\n\n\tfor (let i = 0; i < length; i++) {\n\t\tcontainer.appendChild(children[0]);\n\t}\n\telement.appendChild(container);\n\treturn container;\n}\nfunction render(properties: RectType[], rect: IInfiniteGridItem[\"rect\"], styles: HTMLElement[\"style\"]) {\n\tproperties.forEach(p => {\n\t\t(p in rect) && (styles[p] = `${rect[p]}px`);\n\t});\n}\n\nexport default class DOMRenderer {\n\tpublic static renderItem(item: IInfiniteGridItem, rect: IInfiniteGridItem[\"rect\"], transitionDuration?: number) {\n\t\tif (!item.el) {\n\t\t\treturn;\n\t\t}\n\t\tconst { el, prevRect } = item;\n\t\tconst styles = el.style;\n\n\t\t// for debugging\n\t\tel.setAttribute(GROUPKEY_ATT, `${item.groupKey}`);\n\t\tstyles.position = \"absolute\";\n\t\trender([\"width\", \"height\"], rect, styles);\n\t\tif (transitionDuration && TRANSITION && prevRect) {\n\t\t\tsetTransition(styles, transitionDuration, rect, prevRect);\n\t\t\tif ((el as any)[TRANSITION_NAME]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tel[TRANSITION_NAME] = true;\n\t\t\taddOnceEvent(el, TRANSITION_END, () => {\n\t\t\t\tconst itemRect = item.rect;\n\n\t\t\t\tremoveTransition(styles);\n\t\t\t\trender([\"left\", \"top\"], itemRect, styles);\n\t\t\t\titem.prevRect = itemRect;\n\t\t\t\tel[TRANSITION_NAME] = false;\n\t\t\t});\n\t\t} else {\n\t\t\trender([\"left\", \"top\"], rect, styles);\n\t\t\titem.prevRect = rect;\n\t\t}\n\t}\n\tpublic static renderItems(items: IInfiniteGridItem[], transitionDuration?: number) {\n\t\titems.forEach(item => {\n\t\t\tDOMRenderer.renderItem(item, item.rect, transitionDuration);\n\t\t});\n\t}\n\tpublic static removeItems(items: IInfiniteGridItem[]) {\n\t\titems.forEach(item => {\n\t\t\tif (item.el) {\n\t\t\t\tDOMRenderer.removeElement(item.el);\n\t\t\t\titem.el = null;\n\t\t\t}\n\t\t});\n\t}\n\tpublic static removeElement(element: HTMLElement) {\n\t\tconst parentNode = element && element.parentNode;\n\n\t\tif (!parentNode) {\n\t\t\treturn;\n\t\t}\n\t\tparentNode.removeChild(element);\n\t}\n\tpublic static createElements(items: IInfiniteGridItem[]) {\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst noElementItems = items.filter(item => !item.el);\n\n\t\tif (!noElementItems.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst elements = $(\n\t\t\tnoElementItems.map(({ content }) => content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\")).join(\"\"),\n\t\t\ttrue,\n\t\t);\n\n\t\tnoElementItems.forEach((item, index) => {\n\t\t\titem.el = elements[index];\n\t\t});\n\t}\n\tpublic container: HTMLElement;\n\tpublic view: Window | HTMLElement;\n\tpublic options: IDOMRendererOptions = {\n\t\tisEqualSize: false,\n\t\tisConstantSize: false,\n\t\thorizontal: false,\n\t\tcontainer: false,\n\t};\n\tpublic _size: IDOMRendererSize = {\n\t\tcontainer: -1,\n\t\tview: -1,\n\t\tviewport: -1,\n\t\titem: null,\n\t};\n\tpublic _orgStyle: IDOMRendererOrgStyle = {};\n\tconstructor(element: string | HTMLElement | IJQuery, options: IDOMRendererOptions) {\n\t\tassign(this.options, options);\n\t\tthis._init(element);\n\t\tthis.resize();\n\t}\n\tpublic getStatus() {\n\t\treturn {\n\t\t\tcssText: this.container.style.cssText,\n\t\t\t_size: assign({}, this._size),\n\t\t};\n\t}\n\tpublic setStatus(status: IDOMRendererStatus) {\n\t\tthis.container.style.cssText = status.cssText;\n\t\tassign(this._size, status._size);\n\t}\n\tpublic updateSize(items: IInfiniteGridItem[]) {\n\t\tconst { isEqualSize, isConstantSize } = this.options;\n\t\tconst size = this._size;\n\n\t\treturn items.map(item => {\n\t\t\tif (!item.el) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t\tif (isEqualSize && !size.item) {\n\t\t\t\tsize.item = getSize(item.el);\n\t\t\t}\n\t\t\titem.size = (isEqualSize && assign({}, size.item)) ||\n\t\t\t\t(isConstantSize && item.orgSize && item.orgSize.width && assign({}, item.orgSize)) ||\n\t\t\t\tgetSize(item.el);\n\t\t\tif (!item.orgSize || !item.orgSize.width || !item.orgSize.height) {\n\t\t\t\titem.orgSize = assign({}, item.size);\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\t}\n\tpublic createAndInsert(items: IInfiniteGridItem[], isAppend?: boolean) {\n\t\tDOMRenderer.createElements(items);\n\n\t\tDOMRenderer.renderItems(items);\n\t\tthis._insert(items, isAppend);\n\t}\n\tpublic getViewSize() {\n\t\treturn this._size.view;\n\t}\n\tpublic getViewportSize() {\n\t\treturn this._size.viewport;\n\t}\n\tpublic getContainerSize() {\n\t\treturn this._size.container;\n\t}\n\tpublic setContainerSize(size: number) {\n\t\tthis._size.container = size;\n\t\tthis.container.style[this.options.horizontal ? \"width\" : \"height\"] = `${size}px`;\n\t}\n\tpublic resize() {\n\t\tconst horizontal = this.options.horizontal;\n\t\tconst view = this.view;\n\t\tconst size = this._calcSize();\n\n\t\tif (size === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst isResize = size !== this._size.viewport;\n\n\t\tif (isResize) {\n\t\t\tthis._size = {\n\t\t\t\tview: -1,\n\t\t\t\tcontainer: -1,\n\t\t\t\tviewport: size,\n\t\t\t\titem: null,\n\t\t\t};\n\t\t}\n\t\tthis._size.view = horizontal ? innerWidth(view) : innerHeight(view);\n\t\treturn isResize;\n\t}\n\tpublic isNeededResize() {\n\t\treturn this._calcSize() !== this._size.viewport;\n\t}\n\tpublic clear() {\n\t\tthis.container.innerHTML = \"\";\n\t\tthis.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n\n\t\tthis._size = {\n\t\t\titem: null,\n\t\t\tviewport: -1,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t};\n\t}\n\tpublic destroy() {\n\t\tthis.clear();\n\t\tconst container = this.options.container;\n\t\tlet property: keyof IDOMRendererOrgStyle;\n\n\t\tfor (property in this._orgStyle) {\n\t\t\t(this[container ? \"view\" : \"container\"] as HTMLElement).style[property] = this._orgStyle[property]!;\n\t\t}\n\t\tcontainer && this.container.parentNode!.removeChild(this.container);\n\t}\n\tprivate _init(el: HTMLElement | IJQuery | string) {\n\t\tconst element = $(el);\n\t\tconst style = getStyles(element);\n\t\tconst { container, horizontal } = this.options;\n\n\t\tif (style.position === \"static\") {\n\t\t\tthis._orgStyle.position = element.style.position;\n\t\t\telement.style.position = \"relative\";\n\t\t}\n\t\tif (container) {\n\t\t\tconst target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n\n\t\t\tthis._orgStyle.overflowX = element.style.overflowX;\n\t\t\tthis._orgStyle.overflowY = element.style.overflowY;\n\t\t\telement.style[`overflow${target[0]}` as \"overflowX\" | \"overflowY\"] = \"scroll\";\n\t\t\telement.style[`overflow${target[1]}` as \"overflowX\" | \"overflowY\"] = \"hidden\";\n\t\t\tthis.view = element;\n\t\t\tthis.container = container === true ? createContainer(this.view as HTMLElement) : container;\n\t\t} else {\n\t\t\tthis.view = window;\n\t\t\tthis.container = element;\n\t\t}\n\t}\n\tprivate _insert(items: IInfiniteGridItem[], isAppend?: boolean, styles?: IInfiniteGridItem[\"rect\"]) {\n\t\tconst container = this.container;\n\t\tconst df = document.createDocumentFragment();\n\n\t\titems.forEach(item => {\n\t\t\tstyles && DOMRenderer.renderItem(item, styles);\n\t\t\tisAppend ? df.appendChild(item.el!) : df.insertBefore(item.el!, df.firstChild);\n\t\t});\n\t\tisAppend ?\n\t\t\tcontainer.appendChild(df) :\n\t\t\tcontainer.insertBefore(df, container.firstChild);\n\t}\n\tprivate _calcSize() {\n\t\treturn this.options.horizontal ?\n\t\t\tinnerHeight(this.container) : innerWidth(this.container);\n\t}\n}\n","import ItemManager from \"./ItemManager\";\nimport { assign, find, findLast } from \"./utils\";\nimport { CursorType, IInfiniteGridGroup, IInfiniteStatus, IRemoveResult, IItem, IInfiniteOptions, IInfiniteGridItem } from \"./types\";\nimport { diff } from \"@egjs/list-differ\";\n\nfunction isVisible(group: IInfiniteGridGroup, threshold: number, scrollPos: number, endScrollPos: number) {\n\tconst { items, outlines } = group;\n\tconst start = outlines.start;\n\tconst end = outlines.end;\n\n\tif (start.length === 0 || end.length === 0 || !items.length || !items[0].el) {\n\t\treturn 2;\n\t}\n\tconst min = Math.min(...start);\n\tconst max = Math.max(...end);\n\n\tif ((endScrollPos + threshold < min)) {\n\t\treturn +1;\n\t} else if ((scrollPos - threshold > max)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nclass Infinite {\n\tpublic options: Required<IInfiniteOptions>;\n\tprivate _itemManager: ItemManager;\n\tprivate _status: IInfiniteStatus;\n\tconstructor(itemManger: ItemManager, options: IInfiniteOptions) {\n\t\tthis.options = assign({\n\t\t\tuseRecycle: true,\n\t\t\tthreshold: 100,\n\t\t\tappend: () => void 0,\n\t\t\tprepend: () => void 0,\n\t\t\trecycle: () => void 0,\n\t\t}, options);\n\n\t\tthis._itemManager = itemManger;\n\t\tthis.clear();\n\t}\n\tpublic setSize(size: number) {\n\t\tthis._status.size = size;\n\t}\n\tpublic sync(items: IItem[]) {\n\t\tconst status = this._status;\n\t\tconst { startCursor, endCursor } = status;\n\t\tconst itemManager = this._itemManager;\n\t\tconst prevVisisbleGroups = itemManager.sliceGroups(startCursor, endCursor + 1);\n\t\tconst prevVisibleItems = ItemManager.pluck(prevVisisbleGroups, \"items\");\n\t\tconst result = itemManager.sync(items);\n\t\tconst startGroup = find(\n\t\t\tprevVisisbleGroups,\n\t\t\t({ groupKey }) => itemManager.getGroupByKey(groupKey),\n\t\t);\n\t\tconst endGroup = findLast(\n\t\t\tprevVisisbleGroups,\n\t\t\t({ groupKey }) => itemManager.getGroupByKey(groupKey),\n\t\t);\n\t\tlet nextStartCursor = startGroup ? itemManager.indexOf(startGroup) : -1;\n\t\tlet nextEndCursor = endGroup ? itemManager.indexOf(endGroup) : -1;\n\n\t\tif (nextStartCursor > -1 && nextEndCursor > -1) {\n\t\t\t// This is when the arrangement is inverted.\n\t\t\t// prevVisisbleGroups is [0, 1, 2, 3]\n\t\t\t// but currentGroups is [3, 2, 1, 0]\n\t\t\t// so, nextStartCursor is 3, and nextEndCursor is 0\n\t\t\tconst minCursor = Math.min(nextStartCursor, nextEndCursor);\n\t\t\tconst maxCursor = Math.max(nextStartCursor, nextEndCursor);\n\n\t\t\tnextStartCursor = minCursor;\n\t\t\tnextEndCursor = maxCursor;\n\t\t} else if (nextEndCursor > -1) {\n\t\t\tnextStartCursor = nextEndCursor;\n\t\t} else if (nextStartCursor > -1) {\n\t\t\tnextEndCursor = nextStartCursor;\n\t\t}\n\n\t\tstatus.startCursor = nextStartCursor;\n\t\tstatus.endCursor = nextEndCursor;\n\n\t\tif (result.removed.length > 0) {\n\t\t\treturn \"relayout\";\n\t\t} else {\n\t\t\tconst nextVisibleItems = itemManager.pluck(\"items\", startCursor, endCursor);\n\t\t\tconst visibleDiffResult = diff(prevVisibleItems, nextVisibleItems, ({ itemKey }) => itemKey);\n\n\t\t\tif (visibleDiffResult.removed.length > 0) {\n\t\t\t\treturn \"layout\";\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\tpublic recycle(scrollPos: number | null, isForward?: boolean) {\n\t\tif (!this.options.useRecycle || typeof scrollPos !== \"number\") {\n\t\t\treturn;\n\t\t}\n\t\tconst { startCursor, endCursor, size } = this._status;\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn;\n\t\t}\n\t\tconst endScrollPos = scrollPos + size;\n\t\tconst { threshold, recycle } = this.options;\n\t\tconst visibles = this._itemManager.sliceGroups(startCursor, endCursor + 1)\n\t\t\t.map(group => isVisible(group, threshold, scrollPos, endScrollPos));\n\t\tconst length = visibles.length;\n\t\tlet start = isForward ? 0 : visibles.lastIndexOf(0);\n\t\tlet end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n\t\tif (!isForward && start !== -1) {\n\t\t\tstart += 1;\n\t\t}\n\t\tif (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n\t\t\treturn;\n\t\t}\n\t\tstart = startCursor + start;\n\t\tend = startCursor + end;\n\n\t\tif (isForward) {\n\t\t\tthis.setCursor(\"start\", end + 1);\n\t\t} else {\n\t\t\tthis.setCursor(\"end\", start - 1);\n\t\t}\n\t\trecycle({ start, end });\n\t}\n\tpublic scroll(scrollPos: number | null) {\n\t\tconst [startCursor, endCursor] = this.getCursors();\n\t\tconst items = this._itemManager;\n\n\t\tif (typeof scrollPos !== \"number\" || startCursor === -1 ||\n\t\t\tendCursor === -1 || !items.size()) {\n\t\t\treturn;\n\t\t}\n\t\tconst size = this._status.size;\n\t\tconst { threshold, append, prepend } = this.options;\n\t\tconst datas = items.getGroups();\n\t\tconst endScrollPos = scrollPos + size;\n\t\tconst startEdgePos = Math.max(...datas[startCursor].outlines.start);\n\t\tconst endEdgePos = Math.min(...datas[endCursor].outlines.end);\n\t\tconst visibles = datas.map((group, i) => {\n\t\t\tconst { start, end } = group.outlines;\n\n\t\t\tif (!start.length || !end.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst startPos = Math.min(...start);\n\t\t\tconst endPos = Math.max(...end);\n\n\t\t\tif (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tconst startIndex = visibles.indexOf(true);\n\t\tconst endIndex = visibles.lastIndexOf(true);\n\n\t\tif (~startIndex && startIndex < startCursor) {\n\t\t\tprepend({ cache: datas.slice(startIndex, Math.min(startCursor, endIndex + 1)) });\n\t\t} else if (endCursor < endIndex) {\n\t\t\tappend({ cache: datas.slice(Math.max(startIndex, endCursor + 1), endIndex + 1) });\n\t\t} else {\n\t\t\t// if you have data(no cachedAppendData, has cachedPrependData) to pepend, request it.\n\t\t\tconst cachedAppendData = datas.slice(endCursor + 1, endCursor + 2);\n\t\t\tconst cachedPrependData = datas.slice(startCursor - 1, startCursor);\n\t\t\tconst isPrepend = scrollPos <= startEdgePos + threshold;\n\n\t\t\tif (\n\t\t\t\tendScrollPos >= endEdgePos - threshold\n\t\t\t\t&& (!isPrepend || cachedAppendData.length || !cachedPrependData.length)\n\t\t\t) {\n\t\t\t\tappend({ cache: cachedAppendData });\n\t\t\t} else if (isPrepend) {\n\t\t\t\tprepend({ cache: cachedPrependData });\n\t\t\t}\n\t\t}\n\t}\n\tpublic setCursor(cursor: CursorType, index: number) {\n\t\tconst status = this._status;\n\t\tconst items = this._itemManager;\n\t\tconst size = items.size();\n\n\t\tif (!this.options.useRecycle) {\n\t\t\tstatus.startCursor = 0;\n\t\t\tif (items.getOutline(size - 1, \"end\").length) {\n\t\t\t\tstatus.endCursor = size - 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (cursor !== \"end\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (cursor === \"start\") {\n\t\t\tstatus.startCursor = index;\n\t\t} else {\n\t\t\tstatus.endCursor = Math.min(size - 1, index);\n\t\t}\n\t\tstatus.startCursor = Math.max(0, status.startCursor);\n\t}\n\tpublic setStatus(status: IInfiniteStatus) {\n\t\tthis._status = assign(this._status, status);\n\t}\n\tpublic getStatus(startKey?: string | number, endKey?: string | number): IInfiniteStatus {\n\t\tconst { startCursor, endCursor, size } = this._status;\n\t\tconst startIndex = Math.max(this._itemManager.indexOf(startKey), 0);\n\t\tconst endIndex = (this._itemManager.indexOf(endKey) + 1 || this._itemManager.size()) - 1;\n\t\tconst start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n\t\tconst end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n\n\t\treturn {\n\t\t\tstartCursor: start,\n\t\t\tendCursor: end,\n\t\t\tsize,\n\t\t};\n\t}\n\tpublic getEdgeOutline(cursor: CursorType) {\n\t\tconst { startCursor, endCursor } = this._status;\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this._itemManager.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n\t}\n\tpublic getEdgeValue(cursor: CursorType) {\n\t\tconst outlines = this.getEdgeOutline(cursor);\n\n\t\treturn outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n\t}\n\tpublic getVisibleItems(): IInfiniteGridItem[] {\n\t\tconst { startCursor, endCursor } = this._status;\n\n\t\treturn this._itemManager.pluck(\"items\", startCursor, endCursor);\n\t}\n\tpublic getCursors() {\n\t\tconst status = this._status;\n\n\t\treturn [\n\t\t\tstatus.startCursor,\n\t\t\tstatus.endCursor,\n\t\t];\n\t}\n\tpublic getCursor(cursor: CursorType) {\n\t\treturn this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n\t}\n\tpublic getVisibleData() {\n\t\tconst { startCursor, endCursor } = this._status;\n\n\t\treturn this._itemManager.sliceGroups(startCursor, endCursor + 1);\n\t}\n\n\tpublic remove(groupIndex: number, itemIndex: number): IRemoveResult {\n\t\tconst status = this._status;\n\t\tconst items = this._itemManager;\n\t\tconst { startCursor, endCursor } = status;\n\t\tconst result = items.remove(groupIndex, itemIndex);\n\n\t\tif (result.group) {\n\t\t\tif (groupIndex < startCursor) {\n\t\t\t\tthis.setCursor(\"start\", startCursor - 1);\n\t\t\t}\n\t\t\tif (groupIndex <= endCursor) {\n\t\t\t\tthis.setCursor(\"end\", endCursor - 1);\n\t\t\t}\n\t\t}\n\t\tif (!items.size()) {\n\t\t\tstatus.startCursor = -1;\n\t\t\tstatus.endCursor = -1;\n\t\t}\n\t\treturn result;\n\t}\n\tpublic clear() {\n\t\tthis._status = {\n\t\t\tstartCursor: -1,\n\t\t\tendCursor: -1,\n\t\t\tsize: -1,\n\t\t};\n\t}\n}\n\nexport default Infinite;\n","import ItemManager from \"./ItemManager\";\nimport { matchHTML, $, assign } from \"./utils\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport { ILayout, IInfiniteGridItem, IInfiniteGridGroup } from \"./types\";\nimport { check, removeAutoSizer } from \"@egjs/lazyloaded\";\nimport Infinite from \"./Infinite\";\nimport Component from \"@egjs/component\";\n\nfunction hasTarget<T>(target: T[], value: T) {\n\treturn ~target.indexOf(value);\n}\n\nexport default class RenderManager {\n\tprivate _layout: ILayout;\n\tconstructor(\n\t\tprivate _infinite: Infinite,\n\t\tprivate _itemManager: ItemManager,\n\t\tprivate _renderer: DOMRenderer,\n\t\tprivate options: {\n\t\t\tattributePrefix: string;\n\t\t\tisEqualSize: boolean;\n\t\t\tisConstantSize: boolean;\n\t\t\thorizontal: boolean;\n\t\t},\n\t) { }\n\tpublic setLayout(layout: ILayout) {\n\t\tthis._layout = layout;\n\t}\n\tpublic render(\n\t\tcallbackComponent: Component,\n\t\tgroups: IInfiniteGridGroup[],\n\t\titems = ItemManager.pluck(groups, \"items\"),\n\t\tisAppend?: boolean,\n\t) {\n\t\tconst checkGroups = isAppend ? groups : groups.reverse();\n\t\tconst replaceTarget: number[] = [];\n\t\tconst removeTarget: HTMLElement[] = [];\n\t\tconst elements = items.map(item => item.el!);\n\t\tconst prefix = this.options.attributePrefix;\n\n\t\tcheck(\n\t\t\telements,\n\t\t\tprefix,\n\t\t).on(\"ready\", () => {\n\t\t\tif (!this._itemManager) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._complete(callbackComponent, checkGroups, items, isAppend);\n\t\t}).on(\"error\", ({\n\t\t\ttarget,\n\t\t\titemIndex,\n\t\t}) => {\n\t\t\tif (!this._itemManager) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._error(callbackComponent, removeTarget, replaceTarget, target, items, itemIndex);\n\t\t}).on(\"finish\", () => {\n\t\t\tif (!this._itemManager) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._end(callbackComponent, removeTarget, replaceTarget, items);\n\t\t});\n\n\t\treturn callbackComponent;\n\t}\n\tprivate _complete(\n\t\tcallbackComponent: Component,\n\t\tgroups: IInfiniteGridGroup[],\n\t\titems: IInfiniteGridItem[],\n\t\tisAppend?: boolean,\n\t) {\n\t\tconst infinite = this._infinite;\n\t\tconst layout = this._layout;\n\t\tconst itemManager = this._itemManager;\n\t\tconst cursor = isAppend ? \"end\" : \"start\";\n\t\tconst groupIndex = itemManager.indexOf(groups[0]);\n\t\tconst prevGroup = itemManager.getGroup(groupIndex + (isAppend ? -1 : 1));\n\t\tlet outline = prevGroup ? prevGroup.outlines[cursor] : [0];\n\n\t\tthis._renderer.updateSize(items);\n\t\tgroups.forEach(group => {\n\t\t\tconst groupOutline = group.outlines[isAppend ? \"start\" : \"end\"];\n\t\t\tconst isRelayout = !outline.length || (outline.length === groupOutline.length ?\n\t\t\t\t!outline.every((v, index) => v === groupOutline[index]) : true);\n\n\t\t\tif (!isRelayout) {\n\t\t\t\toutline = group.outlines[isAppend ? \"end\" : \"start\"];\n\t\t\t\tDOMRenderer.renderItems(group.items);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst groupItems = group.items;\n\t\t\tconst groupInfo = layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n\n\t\t\tassign(group, groupInfo);\n\t\t\tDOMRenderer.renderItems(groupInfo.items);\n\t\t\toutline = groupInfo.outlines[isAppend ? \"end\" : \"start\"];\n\t\t});\n\n\t\tconst startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n\t\tconst endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n\t\tlet requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n\t\tlet requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n\t\tlet isInCursor = true;\n\n\t\tif (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n\t\t\tisInCursor = false;\n\t\t}\n\t\tif (isInCursor) {\n\t\t\tif (isAppend) {\n\t\t\t\trequestStartCursor = startCursor;\n\t\t\t\trequestEndCursor = Math.max(endCursor, requestEndCursor);\n\t\t\t} else {\n\t\t\t\trequestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n\t\t\t\trequestEndCursor = endCursor;\n\t\t\t}\n\t\t}\n\t\tif (requestStartCursor > requestEndCursor) {\n\t\t\tconst tempCursor = requestStartCursor;\n\n\t\t\trequestStartCursor = requestEndCursor;\n\t\t\trequestEndCursor = tempCursor;\n\t\t}\n\t\tcallbackComponent.trigger(\"renderComplete\", {\n\t\t\tstart: requestStartCursor,\n\t\t\tend: requestEndCursor,\n\t\t});\n\t\tcallbackComponent.trigger(\"layoutComplete\", {\n\t\t\titems: ItemManager.pluck(groups, \"items\"),\n\t\t\tisAppend,\n\t\t});\n\t}\n\tprivate _error(\n\t\tcallbackComponent: Component,\n\t\tremoveTarget: HTMLElement[],\n\t\treplaceTarget: number[],\n\t\ttarget: HTMLImageElement,\n\t\titems: IInfiniteGridItem[],\n\t\terrorIndex: number,\n\t) {\n\t\tconst itemManager = this._itemManager;\n\t\tconst item = items[errorIndex];\n\t\tconst element = item.el!;\n\t\tconst prefix = this.options.attributePrefix;\n\n\t\t// remove item\n\t\tconst removeItem = () => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveTarget.push(element);\n\t\t\tconst index = replaceTarget.indexOf(errorIndex);\n\n\t\t\tindex !== -1 && replaceTarget.splice(index, 1);\n\t\t};\n\t\t// remove image\n\t\tconst remove = () => {\n\t\t\tif (target === element) {\n\t\t\t\tremoveItem();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget.parentNode!.removeChild(target);\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\t\t// replace image\n\t\tconst replace = (src: string) => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (src) {\n\t\t\t\tif (matchHTML(src) || typeof src === \"object\") {\n\t\t\t\t\tconst parentNode = target.parentNode!;\n\n\t\t\t\t\tparentNode.insertBefore($(src), target);\n\t\t\t\t\tparentNode.removeChild(target);\n\t\t\t\t\titem.content = element.outerHTML;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.src = src;\n\t\t\t\t\tif (target.getAttribute(`${prefix}width`)) {\n\t\t\t\t\t\tremoveAutoSizer(target, prefix);\n\t\t\t\t\t\ttarget.removeAttribute(`${prefix}width`);\n\t\t\t\t\t\ttarget.removeAttribute(`${prefix}height`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\t\t// replace item\n\t\tconst replaceItem = (content: string) => {\n\t\t\tif (hasTarget(removeTarget, element)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telement.innerHTML = content;\n\t\t\titem.content = element.outerHTML;\n\t\t\tif (hasTarget(replaceTarget, errorIndex)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treplaceTarget.push(errorIndex);\n\t\t};\n\t\tconst totalIndex = itemManager.pluck(\"items\").indexOf(item);\n\n\t\tcallbackComponent.trigger(\"imageError\", {\n\t\t\ttarget,\n\t\t\telement,\n\t\t\titems,\n\t\t\titem,\n\t\t\titemIndex: errorIndex,\n\t\t\treplace,\n\t\t\treplaceItem,\n\t\t\tremove,\n\t\t\tremoveItem,\n\t\t\ttotalIndex,\n\t\t});\n\t}\n\tprivate _end(\n\t\tcallbackComponent: Component,\n\t\tremoveTarget: HTMLElement[],\n\t\treplaceTarget: number[],\n\t\titems: IInfiniteGridItem[],\n\t) {\n\t\tconst { attributePrefix } = this.options;\n\t\tconst removeTargetLength = removeTarget.length;\n\t\tconst replaceTargetLength = replaceTarget.length;\n\n\t\tif (!removeTargetLength && !replaceTargetLength) {\n\t\t\tcallbackComponent.trigger(\"finish\", { remove: [] });\n\t\t\treturn;\n\t\t}\n\t\tconst layoutedItems = replaceTarget.map(itemIndex => items[itemIndex]);\n\n\t\tif (!replaceTargetLength) {\n\t\t\tcallbackComponent.trigger(\"finish\", { remove: removeTarget, layout: true });\n\t\t\treturn;\n\t\t}\n\t\t// wait layoutComplete beacause of error event.\n\t\tcheck(layoutedItems.map(v => v.el!), attributePrefix).on(\"ready\", () => {\n\t\t\tthis._renderer.updateSize(layoutedItems);\n\t\t\tcallbackComponent.trigger(\"finish\", { remove: removeTarget, layout: true });\n\t\t});\n\t}\n}\n","import {\n\tIS_IOS,\n} from \"./consts\";\nimport {\n\twindow,\n} from \"./browser\";\nimport {\n\taddEvent,\n\tremoveEvent,\n\tscroll,\n\tscrollTo,\n\tscrollBy,\n\tassign,\n} from \"./utils\";\nimport { IWatchStatus, IWatcherOptions } from \"./types\";\n\nexport default class Watcher {\n\tpublic options: IWatcherOptions;\n\tprivate _timer: {\n\t\tresize: any;\n\t};\n\tprivate _containerOffset: number = 0;\n\tprivate _view: Window | HTMLElement;\n\tprivate _isScrollIssue: boolean = IS_IOS;\n\t//  When InfiniteGrid is initialized.\n\t// The initial value is null to block the scroll event when returning from browser behavior.\n\tprivate _prevPos: number | null = null;\n\tconstructor(view: Window | HTMLElement, options: Partial<IWatcherOptions> = {}) {\n\t\tassign(this.options = {\n\t\t\tcontainer: view as HTMLElement,\n\t\t\tresize: () => void 0,\n\t\t\tcheck: () => void 0,\n\t\t\tisOverflowScroll: false,\n\t\t\thorizontal: false,\n\t\t}, options);\n\t\tthis._timer = {\n\t\t\tresize: null,\n\t\t};\n\t\tthis._view = view;\n\t\tthis.attachEvent();\n\t\tthis.resize();\n\t\tthis.setScrollPos();\n\t}\n\tpublic getStatus(): IWatchStatus {\n\t\treturn {\n\t\t\t_prevPos: this._prevPos,\n\t\t\tscrollPos: this.getOrgScrollPos(),\n\t\t};\n\t}\n\tpublic setStatus(status: IWatchStatus, applyScrollPos = true) {\n\t\tthis._prevPos = status._prevPos;\n\t\tapplyScrollPos && this.scrollTo(status.scrollPos);\n\t}\n\tpublic scrollBy(pos: number) {\n\t\tconst arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\tscrollBy(this._view, arrPos[0], arrPos[1]);\n\t\tthis.setScrollPos();\n\t}\n\tpublic scrollTo(pos: number) {\n\t\tconst arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\tscrollTo(this._view, arrPos[0], arrPos[1]);\n\t}\n\tpublic getScrollPos() {\n\t\treturn this._prevPos;\n\t}\n\tpublic setScrollPos(pos = this.getOrgScrollPos()) {\n\t\tthis._prevPos = pos - this.getContainerOffset();\n\t}\n\tpublic attachEvent() {\n\t\taddEvent(this._view, \"scroll\", this._onCheck);\n\t\taddEvent(window, \"resize\", this._onResize);\n\t}\n\tpublic getOrgScrollPos() {\n\t\treturn scroll(this._view, this.options.horizontal);\n\t}\n\tpublic reset() {\n\t\tthis._prevPos = null;\n\t}\n\tpublic getContainerOffset() {\n\t\treturn this._containerOffset;\n\t}\n\tpublic resize() {\n\t\tthis._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n\t}\n\tpublic detachEvent() {\n\t\tremoveEvent(this._view, \"scroll\", this._onCheck);\n\t\tremoveEvent(window, \"resize\", this._onResize);\n\t}\n\tpublic destroy() {\n\t\tthis.detachEvent();\n\t\tthis.reset();\n\t}\n\tprivate _getOffset() {\n\t\tconst { container, horizontal } = this.options;\n\t\tconst rect = container.getBoundingClientRect();\n\n\t\treturn rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n\t}\n\tprivate _onCheck = () => {\n\t\tconst prevPos = this.getScrollPos();\n\t\tconst orgScrollPos = this.getOrgScrollPos();\n\n\t\tthis.setScrollPos(orgScrollPos);\n\t\tconst scrollPos = this.getScrollPos()!;\n\n\t\tif (prevPos === null || (this._isScrollIssue && orgScrollPos === 0) || prevPos === scrollPos) {\n\t\t\torgScrollPos && (this._isScrollIssue = false);\n\t\t\treturn;\n\t\t}\n\t\tthis._isScrollIssue = false;\n\t\tthis.options.check({\n\t\t\tisForward: prevPos < scrollPos,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t\thorizontal: this.options.horizontal,\n\t\t});\n\t}\n\tprivate _onResize = () => {\n\t\tif (this._timer.resize) {\n\t\t\tclearTimeout(this._timer.resize);\n\t\t}\n\t\tthis._timer.resize = setTimeout(() => {\n\t\t\tthis.resize();\n\t\t\tthis.options.resize();\n\t\t\tthis._timer.resize = null;\n\t\t}, 100);\n\t}\n}\n","/**\n * Copyright (c) 2017 NAVER Corp.\n * egjs projects are licensed under the MIT license\n*/\nimport Component from \"@egjs/component\";\nimport ItemManager from \"./ItemManager\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport {\n\tIS_ANDROID2,\n\tIDLE,\n\tLOADING_APPEND,\n\tLOADING_PREPEND,\n\tPROCESSING,\n\tDEFENSE_BROWSER,\n\tIGNORE_CLASSNAME,\n\tDUMMY_POSITION,\n\tIS_IOS,\n\tDEFAULT_OPTIONS,\n} from \"./consts\";\nimport Infinite from \"./Infinite\";\nimport { toArray, $, outerHeight, outerWidth, assign, resetSize, hasClass, addClass } from \"./utils\";\nimport {\n\tIJQuery, ILayout,\n\tCursorType, StyleType,\n\tIInfiniteGridItem,\n\tIInfiniteGridGroup, IInfiniteGridStatus, IItem, IArrayFormat, IInfiniteGridOptions\n} from \"./types\";\nimport RenderManager from \"./RenderManager\";\nimport Watcher from \"./Watcher\";\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\n// if (typeof Object.create !== \"function\") {\n//   // tslint:disable\n//   Object.create = (o: any, properties: any) => {\n//     if (typeof o !== \"object\" && typeof o !== \"function\") {\n//       throw new TypeError(\"Object prototype may only be an Object: \" + o);\n//     } else if (o === null) {\n//       throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n//     }\n//     function F() { }\n//     F.prototype = o;\n//     return new F();\n//   };\n//   // tslint:enable\n// }\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 카드 엘리먼트를 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 카드 엘리먼트를 다양한 레이아웃으로 배치할 수 있다. 카드 엘리먼트의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n  // ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\nclass InfiniteGrid extends Component {\n\t/**\n\t * Version info string\n\t * @ko 버전정보 문자열\n\t * @name VERSION\n\t * @static\n\t * @type {String}\n\t * @example\n\t * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n\t * @memberof eg.InfiniteGrid\n\t */\n\tpublic static VERSION = \"#__VERSION__#\";\n\n\tpublic options: IInfiniteGridOptions;\n\tprivate _loadingBar: {\n\t\tappend?: HTMLElement,\n\t\tprepend?: HTMLElement,\n\t} = {};\n\tprivate _itemManager: ItemManager;\n\tprivate _renderer: DOMRenderer;\n\tprivate _renderManager: RenderManager;\n\tprivate _layout: ILayout;\n\tprivate _watcher: Watcher;\n\tprivate _infinite: Infinite;\n\tprivate _status: IInfiniteGridStatus[\"_status\"];\n\tprivate _requestGroups: IInfiniteGridGroup[] = [];\n\n\t/**\n\t * @param {HTMLElement|String|jQuery} element A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n\t * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n\t * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>레이아웃을 구성하는 카드 엘리먼트를 선택할 선택자(selector)</ko>\n\t * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM의 수를 유지할지 여부를 나타낸다. useRecycle 값이 'true'이면 DOM 개수를 일정하게 유지한다. useRecycle 값이 'false' 이면 카드 엘리먼트가 추가될수록 DOM 개수가 계속 증가한다.</ko>\n\t * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll 적용여부를 결정한다.</ko>\n\t * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향)</ko>\n\t * @param {Boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>위로 스크롤할 시 아이템을 추가하는 동안 보이는 빈 공간을 안보이게 한다.</ko>\n\t * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>카드 엘리먼트의 크기가 동일한지 여부. 배치될 카드 엘리먼트의 크기가 모두 동일할 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n\t * @param {Boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>모든 카드 엘리먼트의 크기가 불변일 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n\t * @param {Number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>트랜지션 효과를 완료하는데 걸리는 시간을 나타낸다.</ko>\n\t * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>레이아웃에 카드 엘리먼트를 추가하는 이벤트가 발생하는 기준 영역의 크기.</ko>\n\t * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>엘리먼트의 데이타 속성에 사용할 접두사.</ko>\n\t * @param {boolean} [options.renderExternal=false] Whether to use external rendering. It will delegate DOM manipulation and can synchronize the rendered state by calling `sync()` method. You can use this option to use in frameworks like React, Vue, Angular, which has its states and rendering methods.<ko>외부 렌더링을 사용할 지의 여부. 이 옵션을 사용시 렌더링을 외부에 위임할 수 있고, `sync()`를 호출하여 그 상태를 동기화할 수 있다. 이 옵션을 사용하여, React, Vue, Angular 등 자체적인 상태와 렌더링 방법을 갖는 프레임워크에 대응할 수 있다.</ko>\n\t */\n\tconstructor(element: HTMLElement | string | IJQuery, options?: Partial<IInfiniteGridOptions>) {\n\t\tsuper();\n\t\tassign(this.options = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t}, options);\n\t\tDEFENSE_BROWSER && (this.options.useFit = false);\n\t\tIS_ANDROID2 && (this.options.isOverflowScroll = false);\n\t\tthis._reset();\n\n\t\tconst {\n\t\t\tisOverflowScroll,\n\t\t\tisEqualSize,\n\t\t\tisConstantSize,\n\t\t\thorizontal,\n\t\t\tthreshold,\n\t\t\tuseRecycle,\n\t\t\tattributePrefix,\n\t\t} = this.options;\n\n\t\tthis._itemManager = new ItemManager();\n\t\tthis._renderer = new DOMRenderer(element, {\n\t\t\tisEqualSize,\n\t\t\tisConstantSize,\n\t\t\thorizontal,\n\t\t\tcontainer: isOverflowScroll,\n\t\t});\n\t\tthis._watcher = new Watcher(\n\t\t\tthis._renderer.view,\n\t\t\t{\n\t\t\t\tisOverflowScroll,\n\t\t\t\thorizontal,\n\t\t\t\tcontainer: this._renderer.container,\n\t\t\t\tresize: () => this._onResize(),\n\t\t\t\tcheck: param => this._onCheck(param),\n\t\t\t});\n\n\t\tthis._infinite = new Infinite(this._itemManager, {\n\t\t\tuseRecycle,\n\t\t\tthreshold,\n\t\t\tappend: param => this._requestAppend(param),\n\t\t\tprepend: param => this._requestPrepend(param),\n\t\t\trecycle: param => this._recycle([param]),\n\t\t});\n\n\t\tthis._renderManager = new RenderManager(\n\t\t\tthis._infinite,\n\t\t\tthis._itemManager,\n\t\t\tthis._renderer,\n\t\t\t{\n\t\t\t\tattributePrefix,\n\t\t\t\tisEqualSize,\n\t\t\t\tisConstantSize,\n\t\t\t\thorizontal,\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko 카드 엘리먼트를 레이아웃 아래에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n\t * 이 메소드는 isProcessing()의 반환값이 false일 경우에만 사용 가능하다.\n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트의 배열</ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.append([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tpublic append(elements: HTMLElement[] | IJQuery | string[] | string, groupKey?: string | number) {\n\t\tthis._layout && this._insert({\n\t\t\telements,\n\t\t\tisAppend: true,\n\t\t\tgroupKey,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n\t * @ko 카드 엘리먼트를 레이아웃의 위에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n\t * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트 배열</ko>\n\t * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n\t * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n\t * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n\t * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n\t * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n\t */\n\tpublic prepend(elements: HTMLElement[] | IJQuery | string[] | string, groupKey?: string | number) {\n\t\tthis._layout && this._insert({\n\t\t\telements,\n\t\t\tisAppend: false,\n\t\t\tgroupKey,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Layout class to use.\n\t * @ko 사용할 Layout 클래스를 지정한다.\n\t * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko>사용할 Layout 클래스 또는 레이아웃 모듈의 인스턴스</ko>\n\t * @param {Object} options Options to apply to the Layout.<ko>Layout에 적용할 옵션</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n\t *  margin: 10,\n\t *  align: \"start\"\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\t *  margin: 10,\n\t *  minSize: 100,\n\t *  maxSize: 200\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n\t *  margin: 10,\n\t *  column: 2\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n\t *  margin: 10,\n\t *  frame: [\n\t *   [1, 2],\n\t *   [4, 3],\n\t *  ]\n\t * });\n\t * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n\t *  margin: 10,\n\t *  aspectRatio: 1.5\n\t * });\n\t * var layout = new eg.InfiniteGrid.GridLayout({\n\t *   margin: 10,\n\t *  align: \"start\"\n\t * });\n\t * infinitegrid.setLayout(layout);\n\t */\n\tpublic setLayout(LayoutKlass: ILayout | (new (...args: any[]) => ILayout), options = {}) {\n\t\tconst { horizontal } = this.options;\n\n\t\tif (typeof LayoutKlass === \"function\") {\n\t\t\tthis._layout = new LayoutKlass(assign(options, {\n\t\t\t\thorizontal,\n\t\t\t}));\n\t\t} else {\n\t\t\tLayoutKlass.options.horizontal = horizontal;\n\t\t\tthis._layout = LayoutKlass;\n\t\t}\n\n\t\tthis._renderManager.setLayout(this._layout);\n\t\tthis._renderer.resize();\n\t\tthis._setSize(this._renderer.getViewportSize());\n\t\treturn this;\n\t}\n\t/**\n\t * Returns the layouted items.\n\t * @ko 레이아웃된 아이템들을 반환한다.\n\t * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>캐싱된 아이템을 포함할지 여부를 나타낸다.</ko>\n\t * @returns List of items <ko>아이템의 목록</ko>\n\t */\n\tpublic getItems(includeCached = false): IInfiniteGridItem[] {\n\t\treturn includeCached ? this._itemManager.pluck(\"items\") : this._infinite.getVisibleItems();\n\t}\n\t/**\n\t * @param - Get items to render on screen.\n     * @ko 화면에 렌더될 아이템들 가져온다.\n     * @private\n\t * @param - The groups currently being added by request.<ko>요청에 의해 지금 추가중인 그룹들.</ko>\n\t * @return - The items to be rendered on screen. <ko>화면레 렌더될 아이템들.</ko>\n     */\n\tpublic getRenderingItems(): IInfiniteGridItem[] {\n\t\tconst items = this.getItems();\n\t\tconst itemKeys: { [key: string]: any } = {};\n\n\t\titems.forEach(item => {\n\t\t\titemKeys[item.itemKey!] = true;\n\t\t});\n\t\tconst nextVisisbleItems = ItemManager.pluck(this._requestGroups, \"items\").filter(item => {\n\t\t\tif (itemKeys[item.itemKey!]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\titemKeys[item.itemKey!] = true;\n\t\t\treturn true;\n\t\t});\n\n\t\treturn items.concat(nextVisisbleItems);\n\t}\n\t/**\n     * Synchronize info of items with info given by external rendering.\n     * @ko 외부 렌더링 방식에 의해 아이템의 정보들을 동기화한다.\n     * @private\n     * @param - all item infos to synchronize <ko>동기화할 전체 아이템 정보들.</ko>\n     */\n\tpublic beforeSync(items: IItem[]) {\n\t\treturn this._infinite.sync(items);\n\t}\n\t/**\n\t * Synchronize info of items with DOM info given by external rendering.\n\t * @ko 외부 렌더링 방식에 의해 입력받은 DOM의 정보와 현재 아이템 정보를 동기화 한다.\n\t * @private\n\t * @param - The DOM elements that are currently visible.<ko>현재 보여지고 있는 DOM 엘리먼트들.</ko>\n\t * @param - The groups currently being added by request.<ko>요청에 의해 지금 추가중인 그룹들.</ko>\n\t */\n\tpublic sync(elements: IArrayFormat<HTMLElement>) {\n\t\tconst itemManager = this._itemManager;\n\t\tconst infinite = this._infinite;\n\t\tconst items = this.getRenderingItems();\n\n\t\titems.forEach((item, i) => {\n\t\t\tconst isChange = item.el !== elements[i];\n\t\t\titem.el = elements[i];\n\n\t\t\tif (isChange) {\n\t\t\t\tDOMRenderer.renderItem(item, item.rect);\n\t\t\t}\n\t\t});\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tconst newItems = items.filter(item => !item.orgSize || !item.orgSize.width);\n\n\t\tif (newItems.length) {\n\t\t\tthis._postLayout({\n\t\t\t\tfromCache: false,\n\t\t\t\tgroups: infinite.getVisibleData(),\n\t\t\t\tnewItems,\n\t\t\t\tisAppend: true,\n\t\t\t\tisTrusted: false,\n\t\t\t});\n\t\t} else {\n\t\t\tconst size = itemManager.size();\n\n\t\t\tif (!size) {\n\t\t\t\tthis._requestAppend({});\n\t\t\t} else if (infinite.getCursor(\"start\") < 0) {\n\t\t\t\tconst firstGroup = itemManager.getGroup(0);\n\n\t\t\t\tthis._postLayout({\n\t\t\t\t\tgroups: [firstGroup],\n\t\t\t\t\thasChildren: false,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tisAppend: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._infinite.scroll(this._watcher.getScrollPos());\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Rearranges a layout.\n\t * @ko 레이아웃을 다시 배치한다.\n\t * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>카드 엘리먼트 재배치 여부</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic layout(isRelayout = true) {\n\t\tif (!this._layout) {\n\t\t\treturn this;\n\t\t}\n\t\tconst renderer = this._renderer;\n\t\tconst itemManager = this._itemManager;\n\t\tconst infinite = this._infinite;\n\t\tconst isResize = renderer.resize();\n\t\tconst items = this.getItems();\n\t\tconst { isEqualSize, isConstantSize, transitionDuration } = this.options;\n\t\tconst isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n\t\tconst size = itemManager.size();\n\n\t\tthis._watcher.resize();\n\n\t\tif (isRelayout) {\n\t\t\tif (isResize) {\n\t\t\t\tthis._setSize(renderer.getViewportSize());\n\t\t\t}\n\t\t}\n\t\t// check childElement\n\t\tif (!items.length) {\n\t\t\tconst children = toArray(renderer.container.children).filter(el => {\n\t\t\t\treturn el.className.indexOf(IGNORE_CLASSNAME) === -1;\n\t\t\t});\n\t\t\tconst hasChildren = children.length > 0;\n\n\t\t\tif (size) {\n\t\t\t\tconst firstGroup = itemManager.getGroup(0);\n\n\t\t\t\tif (hasChildren) {\n\t\t\t\t\tfirstGroup.items.forEach((item, i) => {\n\t\t\t\t\t\titem.el = children[i];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// has items, no visible items\n\t\t\t\tthis._postLayout({\n\t\t\t\t\tgroups: [firstGroup],\n\t\t\t\t\thasChildren,\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tisAppend: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// no items, no visible items\n\t\t\t\tif (hasChildren) {\n\t\t\t\t\tlet groupKey: string | null | undefined = children[0].getAttribute(\"data-groupkey\");\n\n\t\t\t\t\tif (typeof groupKey !== \"string\") {\n\t\t\t\t\t\tgroupKey = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tthis._insert({\n\t\t\t\t\t\telements: children,\n\t\t\t\t\t\tisAppend: true,\n\t\t\t\t\t\thasChildren: true,\n\t\t\t\t\t\tgroupKey,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (renderer.getContainerSize()) {\n\t\t\t\t\t\trenderer.setContainerSize(0);\n\t\t\t\t\t}\n\t\t\t\t\tthis._requestAppend({});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// layout datas\n\t\tconst [startCursor, endCursor] = infinite.getCursors();\n\t\tconst data = isLayoutAll || !(isRelayout && isResize) ? itemManager.getGroups() :\n\t\t\titemManager.sliceGroups(startCursor, endCursor + 1);\n\n\t\t// LayoutManger interface\n\t\tthis._relayout(isRelayout, data, isResize ? items : []);\n\n\t\tif (isLayoutAll) {\n\t\t\tthis._fit();\n\t\t} else if (isRelayout && isResize) {\n\t\t\titemManager.clearOutlines(startCursor, endCursor);\n\t\t}\n\t\tDOMRenderer.renderItems(items, transitionDuration);\n\t\tisRelayout && this._watcher.setScrollPos();\n\t\tthis._onLayoutComplete({\n\t\t\titems,\n\t\t\tisAppend: true,\n\t\t\tfromCache: true,\n\t\t\tisTrusted: false,\n\t\t\tuseRecycle: false,\n\t\t\tisLayout: true,\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t * Removes a item corresponding to an index on a grid layout.\n\t * @ko 그리드 레이아웃에서 인덱스에 해당하는 아이템 삭제한다.\n\t * @param - Index of group corresponding to item to remove <ko>삭제할 아이템에 해당하는 그룹의 인덱스</ko>\n\t * @param - Index of item to remove on group <ko>그룹에서 삭제할 아이템의 인덱스</ko>\n\t * @return {Object}  Removed items information <ko>삭제된 아이템들 정보</ko>\n\t */\n\tpublic removeByIndex(groupIndex: number, itemIndex: number, isLayout = true) {\n\t\tconst { items, group } = this._infinite.remove(groupIndex, itemIndex);\n\n\t\titems.forEach(item => {\n\t\t\tDOMRenderer.removeElement(item.el!);\n\t\t});\n\n\t\tif (items.length) {\n\t\t\tisLayout && this.layout(!!group);\n\n\t\t\treturn items;\n\t\t}\n\t\treturn [];\n\t}\n\t/**\n\t * Removes a item element on a grid layout.\n\t * @ko 그리드 레이아웃의 카드 엘리먼트를 삭제한다.\n\t * @param {HTMLElement} item element to be removed <ko>삭제될 아이템 엘리먼트</ko>\n\t * @return {Object}  Removed items information <ko>삭제된 아이템들 정보</ko>\n\t */\n\tpublic remove(element: HTMLElement, isLayout = true) {\n\t\tconst { groupIndex, itemIndex } = this._itemManager.indexesOfElement(element);\n\n\t\treturn this.removeByIndex(groupIndex, itemIndex, isLayout);\n\t}\n\t/**\n\t * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n\t * @ko 현재 유지하고 있는 카드 엘리먼트의 그룹 키 목록을 반환한다. 여러 개의 카드 엘리먼트를 묶어서 관리할 수 있도록 append() 메서드나 prepend() 메서드에서 그룹 키를 지정할 수 있다. append() 메서드나 prepend() 메서드에서 그룹 키를 지정하지 않았다면 자동으로 그룹키가 생성된다.\n\t * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>캐싱된 그룹을 포함할지 여부를 나타낸다.</ko>\n\t * @return {Array} List of group keys <ko>그룹 키의 목록</ko>\n\t */\n\tpublic getGroupKeys(includeCached?: boolean) {\n\t\tconst data = includeCached ?\n\t\t\tthis._itemManager.getGroups() : this._infinite.getVisibleData();\n\n\t\treturn data.map(v => v.groupKey);\n\t}\n\t/**\n\t * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n\t * @ko 카드의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n\t * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n\t */\n\tpublic getStatus(startKey?: string | number, endKey?: string | number): IInfiniteGridStatus {\n\t\treturn {\n\t\t\t_status: assign({}, this._status),\n\t\t\t_itemManager: this._itemManager.getStatus(startKey, endKey),\n\t\t\t_renderer: this._renderer.getStatus(),\n\t\t\t_watcher: this._watcher.getStatus(),\n\t\t\t_infinite: this._infinite.getStatus(startKey, endKey),\n\t\t};\n\t}\n\t/**\n\t * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n\t * @ko getStatue() 메서드가 저장한 정보로 eg.InfiniteGrid 모듈의 상태를 설정한다.\n\t * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n\t * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>스크롤의 위치를 복원할지 결정한다.</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic setStatus(status: IInfiniteGridStatus, applyScrollPos = true, syncElements?: HTMLElement[]) {\n\t\tif (!status) {\n\t\t\treturn this;\n\t\t}\n\t\tconst { _status, _renderer, _itemManager, _watcher, _infinite } = status;\n\n\t\tif (!_status ||\n\t\t\t!_renderer || !_itemManager || !_watcher || !_infinite) {\n\t\t\treturn this;\n\t\t}\n\t\tconst renderExternal = this.options.renderExternal;\n\t\tconst items = this._itemManager;\n\t\tconst renderer = this._renderer;\n\t\tconst watcher = this._watcher;\n\t\tconst infinite = this._infinite;\n\n\t\twatcher.detachEvent();\n\t\tassign(this._status, _status);\n\t\tthis._status.processingStatus = IDLE;\n\t\titems.setStatus(_itemManager);\n\t\trenderer.setStatus(_renderer);\n\t\tinfinite.setStatus(_infinite);\n\n\t\tconst visibleItems = this.getItems();\n\t\tconst length = visibleItems.length;\n\n\t\tif (renderExternal) {\n\t\t\tvisibleItems.forEach((item, i) => {\n\t\t\t\titem.el = syncElements![i];\n\t\t\t});\n\t\t\tDOMRenderer.renderItems(visibleItems);\n\t\t} else {\n\t\t\trenderer.createAndInsert(visibleItems, true);\n\t\t}\n\t\tconst isReLayout = renderer.isNeededResize();\n\n\t\twatcher.setStatus(_watcher, applyScrollPos);\n\t\twatcher.attachEvent();\n\n\t\tconst { isConstantSize, isEqualSize } = this.options;\n\n\t\tif (!length) {\n\t\t\tthis._requestAppend({ cache: [] });\n\t\t} else if (isReLayout) {\n\t\t\trenderer.resize();\n\t\t\tthis._setSize(renderer.getViewportSize());\n\n\t\t\tif (isConstantSize) {\n\t\t\t\tthis.layout(true);\n\t\t\t} else {\n\t\t\t\tthis._itemManager.clearOutlines();\n\t\t\t\tthis._postLayout({\n\t\t\t\t\tfromCache: true,\n\t\t\t\t\tgroups: isEqualSize ? items.getGroups() : infinite.getVisibleData(),\n\t\t\t\t\titems: visibleItems,\n\t\t\t\t\tnewItems: visibleItems,\n\t\t\t\t\tisAppend: true,\n\t\t\t\t\tisTrusted: false,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.layout(false);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Clears added card elements and data.\n\t * @ko 추가된 카드 엘리먼트와 데이터를 모두 지운다.\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic clear() {\n\t\tthis._itemManager.clear();\n\t\tthis._renderer.clear();\n\t\tthis._infinite.clear();\n\t\tthis._reset();\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t/**\n\t * Specifies the Loading Bar to use for append or prepend items.\n\t * @ko 아이템을 append 또는 prepend 하기 위해 사용할 로딩 바를 지정한다.\n\t * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko> 로딩 바 HTML 또는 element 또는 selector </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic setLoadingBar(userLoadingBar: {\n\t\tappend?: string | HTMLElement,\n\t\tprepend?: string | HTMLElement,\n\t} | string = {}) {\n\t\tconst loadingBarObj: {\n\t\t\tappend?: string | HTMLElement,\n\t\t\tprepend?: string | HTMLElement,\n\t\t} = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n\t\t\tappend: userLoadingBar,\n\t\t\tprepend: userLoadingBar,\n\t\t};\n\n\t\tthis._status.loadingSize = 0;\n\t\tthis._status.loadingStyle = {};\n\t\tconst loadingBar = this._loadingBar;\n\n\t\tlet isChangeLoadingBar = false;\n\n\t\tfor (const type in loadingBarObj) {\n\t\t\tconst loadingElement = $(loadingBarObj[type as \"append\" | \"prepend\"]!);\n\n\t\t\tif (loadingBar[type as \"append\" | \"prepend\"] !== loadingElement) {\n\t\t\t\tloadingBar[type as \"append\" | \"prepend\"] = loadingElement;\n\t\t\t\tisChangeLoadingBar = true;\n\t\t\t}\n\n\t\t\tif (!hasClass(loadingElement, IGNORE_CLASSNAME)) {\n\t\t\t\taddClass(loadingElement, IGNORE_CLASSNAME);\n\t\t\t}\n\t\t}\n\t\tif (isChangeLoadingBar) {\n\t\t\tthis._renderLoading();\n\t\t}\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t}\n\t/**\n\t * Checks whether a card element or data is being added.\n\t * @ko 카드 엘리먼트 추가 또는 데이터 로딩이 진행 중인지 확인한다\n\t * @return {Boolean} Indicates whether a card element or data is being added <ko>카드 엘리먼트 추가 또는 데이터 로딩 진행 중 여부</ko>\n\t */\n\tpublic isProcessing() {\n\t\treturn this._isProcessing() || this.isLoading();\n\t}\n\t/**\n\t * Checks whether data is loading.\n\t * @ko 데이터 로딩 중인지 확인한다\n\t * @return {Boolean} Indicates whether data is loading <ko>데이터 로딩 진행 중 여부</ko>\n\t */\n\tpublic isLoading() {\n\t\treturn this._getLoadingStatus() > 0;\n\t}\n\t/**\n\t * Returns the element of loading bar.\n\t * @ko 로딩 바의 element를 반환한다.\n\t * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n\t * @return {Element} The element of loading bar. <ko>로딩 바의 element</ko>\n\t */\n\tpublic getLoadingBar(isAppend = this._getLoadingStatus() !== LOADING_PREPEND) {\n\t\treturn this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\t}\n\t/**\n\t * Start loading for append/prepend during loading data.\n\t * @ko 데이터가 로딩되는 동안 append/prepend하길 위해 로딩을 시작한다.\n\t * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n\t * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic startLoading(isAppend?: boolean, userStyle: StyleType = { display: \"block\" }) {\n\t\tif (this.isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\n\t\tthis._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\t\tif (!this._loadingBar[type]) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst next = () => {\n\t\t\tthis._renderLoading(userStyle);\n\t\t\tthis._status.loadingStyle = userStyle;\n\t\t\tif (!isAppend) {\n\t\t\t\tthis._fit();\n\t\t\t} else {\n\t\t\t\tthis._setContainerSize(this._getEdgeValue(\"end\") + this._status.loadingSize);\n\t\t\t}\n\t\t};\n\t\tif (this.options.renderExternal) {\n\t\t\tthis.trigger(\"render\", {\n\t\t\t\tnext,\n\t\t\t});\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * End loading after startLoading() for append/prepend\n\t * @ko  append/prepend하길 위해 startLoading() 호출해선 걸었던 로딩을 끝낸다.\n\t * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic endLoading(userStyle: StyleType = { display: \"none\" }) {\n\t\tif (!this.isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst type = isAppend ? \"append\" : \"prepend\";\n\t\tconst el = this._loadingBar[type];\n\t\tconst status = this._status;\n\t\tconst size = status.loadingSize;\n\n\t\tthis._process(LOADING_APPEND | LOADING_PREPEND, false);\n\t\tstatus.loadingSize = 0;\n\t\tstatus.loadingStyle = {};\n\t\tif (el) {\n\t\t\tconst style: StyleType = assign({\n\t\t\t\t[this.options.horizontal ? \"left\" : \"top\"]: `${-size}px`,\n\t\t\t}, userStyle);\n\n\t\t\tfor (const property in style) {\n\t\t\t\tel.style[property as keyof StyleType] = style[property as keyof StyleType];\n\t\t\t}\n\t\t\tif (!isAppend) {\n\t\t\t\tthis._fitItems(size);\n\t\t\t} else {\n\t\t\t\tthis._setContainerSize(this._getEdgeValue(\"end\"));\n\t\t\t}\n\t\t\tif (this.options.renderExternal) {\n\t\t\t\tthis.trigger(\"render\", {\n\t\t\t\t\tnext: () => { },\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (this.options.useRecycle && !this.isProcessing()) {\n\t\t\tthis._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Retrieves the item via index or the element.\n\t * @ko index 또는 element를 통해 아이템을 가져온다.\n\t * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item에 해당하는 element 또는 해당 item이 있는 group의 index</ko>\n\t * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex를 사용할 경우 해당 group에 있는 Item의 index </ko>\n\t * @return The item containing the content, size and position,etc<ko>content, size, position 등이 담겨있는 item 정보</ko>\n\t * @example\n\n\t ig.getItem(0, 0);\n\t ig.getItem(element);\n\n\t {\n\t  el: HTMLElement,\n\t  content: \"<div>...</div>\",\n\t  size: {width: ..., height: ...},\n\t  rect: {top: ..., left: ..., width: ..., height: ...},\n\t }\n\t */\n\tpublic getItem(groupIndex: HTMLElement | number = 0, itemIndex?: number): IInfiniteGridItem | undefined {\n\t\tif (typeof groupIndex === \"object\") {\n\t\t\tif (!groupIndex) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst items = this.getItems();\n\t\t\tconst length = items.length;\n\n\t\t\tfor (let i = 0; i < length; ++i) {\n\t\t\t\tif (items[i].el === groupIndex) {\n\t\t\t\t\treturn items[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst group = this._itemManager.getGroup(groupIndex);\n\n\t\t\treturn group && group.items[itemIndex || 0];\n\t\t}\n\t}\n\t/**\n\t * Updates the item via index or the element.\n\t * @ko index 또는 element를 통해 아이템을 업데이트한다.\n\t * @param {number | HTMLElement} [groupIndex=0] The element corresponding to item or the index of the group where the item is in position <ko> item에 해당하는 element 또는 해당 item이 있는 group의 index</ko>\n\t * @param {number} [itemIndex] If groupIndex is used, the index of the item in the group <ko> groupIndex를 사용할 경우 해당 group에 있는 Item의 index </ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\telement.innerHTML = \"2\";\n\telement.style.height = \"400px\";\n\tig.updateItem(element);\n\tig.updateItem(0, 0);\n\t */\n\tpublic updateItem(groupIndex?: number, itemIndex?: number) {\n\t\tconst item = this.getItem(groupIndex, itemIndex);\n\n\t\tthis._updateItem(item) && this.layout(false);\n\n\t\treturn this;\n\t}\n\t/**\n\t * Update the currently displayed items.\n\t * @ko 현재보여주는 아이템들을 업데이트한다.\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\telement.innerHTML = \"2\";\n\telement.style.height = \"400px\";\n\n\telement2.innerHTML = \"2\";\n\telement2.style.height = \"400px\";\n\n\tig.updateItems();\n\t */\n\tpublic updateItems() {\n\t\tthis.getItems().forEach(item => {\n\t\t\tthis._updateItem(item);\n\t\t});\n\t\tthis.layout(false);\n\t\treturn this;\n\t}\n\t/**\n\t * Move to some group or item position.\n\t * @ko 해당하는 그룹 또는 아이템의 위치로 이동한다.\n\t * @param {Number} [index] group's index <ko> 그룹의 index</ko>\n\t * @param {Number} [itemIndex=-1] item's index <ko> 그룹의 index</ko>\n\t * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tpublic moveTo(index: number, itemIndex = 0) {\n\t\tif (this.isProcessing()) {\n\t\t\treturn this;\n\t\t}\n\t\tconst data = this._itemManager.getGroup(index);\n\n\t\tif (!data) {\n\t\t\treturn this;\n\t\t}\n\t\tconst infinite = this._infinite;\n\t\tconst outlines = data.outlines;\n\t\tconst items = data.items;\n\t\tconst item = items[itemIndex];\n\t\tconst isResize = outlines.start && (outlines.start.length === 0);\n\t\tconst [startCursor, endCursor] = infinite.getCursors();\n\t\tconst isInCursor = startCursor <= index && index <= endCursor;\n\t\tconst { useRecycle, horizontal } = this.options;\n\n\t\tif (isInCursor || !useRecycle || !isResize) {\n\t\t\tlet pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max(...outlines.start);\n\t\t\tconst fit = Math.min(...outlines.start);\n\n\t\t\tif (fit < 0) {\n\t\t\t\t// base < 0\n\t\t\t\tthis._fitItems(fit, 0);\n\t\t\t\tpos -= fit;\n\t\t\t}\n\t\t\tconst isAppend = index > startCursor;\n\n\t\t\tif (isInCursor || isAppend) {\n\t\t\t\tthis._scrollTo(pos);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._postLayout({\n\t\t\t\tfromCache: true,\n\t\t\t\tgroups: [data],\n\t\t\t\titems,\n\t\t\t\tnewItems: [],\n\t\t\t\tisAppend,\n\t\t\t\tisTrusted: false,\n\t\t\t})!.on(\"renderComplete\", ({ start, end }) => {\n\t\t\t\tconst itemManager = this._itemManager;\n\n\t\t\t\tif (!itemManager) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst scrollPos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n\n\t\t\t\tif (!isInCursor) {\n\t\t\t\t\titemManager.clearOutlines(start, end);\n\t\t\t\t}\n\t\t\t\tthis._scrollTo(scrollPos);\n\t\t\t\tthis._setScrollPos(scrollPos);\n\t\t\t});\n\t\t\treturn this;\n\t\t} else {\n\t\t\tconst isAppend = index > endCursor || index < startCursor - 1;\n\n\t\t\tthis._postCache({\n\t\t\t\tisAppend,\n\t\t\t\tcache: [data],\n\t\t\t\tisTrusted: false,\n\t\t\t})!.on(\"renderComplete\", ({ start, end }) => {\n\t\t\t\tconst itemManager = this._itemManager;\n\n\t\t\t\tif (!itemManager) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst pos = items[itemIndex].rect[horizontal ? \"left\" : \"top\"];\n\n\t\t\t\titemManager.clearOutlines(start, end);\n\t\t\t\tthis._scrollTo(pos);\n\t\t\t\tthis._setScrollPos(pos);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n   * Destroys elements, properties, and events used on a grid layout.\n   * @ko 그리드 레이아웃에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n   */\n\tpublic destroy() {\n\t\tthis._infinite.clear();\n\t\tthis._watcher.destroy();\n\t\tthis._reset();\n\t\tthis._itemManager.clear();\n\t\tthis._renderer.destroy();\n\t}\n\tprivate _relayout(isRelayout: boolean, groups: IInfiniteGridGroup[], items: IInfiniteGridItem[]) {\n\t\tconst renderer = this._renderer;\n\t\tconst { isEqualSize, isConstantSize } = renderer.options;\n\t\tconst layoutGroups = groups.filter(group => {\n\t\t\tconst item = group.items[0];\n\n\t\t\treturn item.orgSize && item.rect.top > DUMMY_POSITION / 10;\n\t\t});\n\n\t\tif (!layoutGroups.length) {\n\t\t\treturn [];\n\t\t}\n\t\tlet outline = layoutGroups[0].outlines.start;\n\n\t\tif (isRelayout) {\n\t\t\toutline = [outline.length ? Math.min(...outline) : 0];\n\t\t\tif (!isConstantSize && items.length) {\n\t\t\t\trenderer.updateSize(items);\n\n\t\t\t\t// update invisible items' size\n\t\t\t\tif (isEqualSize && items[0].size) {\n\t\t\t\t\tItemManager.pluck(layoutGroups, \"items\").forEach(item => {\n\t\t\t\t\t\titem.size = assign({}, items[0].size);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._layout.layout(layoutGroups, outline);\n\t}\n\tprivate _setContainerSize(size: number) {\n\t\tthis._renderer.setContainerSize(Math.max(this._itemManager.getMaxEdgeValue(), size));\n\t}\n\tprivate _appendLoadingBar() {\n\t\tif (!this.options.renderExternal) {\n\t\t\tconst loadingBar = this._loadingBar;\n\t\t\tconst container = this._renderer.container;\n\n\t\t\tfor (const type in loadingBar) {\n\t\t\t\tcontainer.appendChild(loadingBar[type as \"append\" | \"prepend\"]!);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _setSize(size: number) {\n\t\tthis._infinite.setSize(this._renderer.getViewSize());\n\t\tthis._layout.setSize(size);\n\t}\n\tprivate _fitItems(base: number, margin = 0) {\n\t\tbase > 0 && this._watcher.scrollBy(-base);\n\t\tthis._itemManager.fit(base, this.options.horizontal);\n\t\tDOMRenderer.renderItems(this.getItems());\n\t\tthis._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\t\tbase < 0 && this._watcher.scrollBy(-base);\n\t}\n\t// called by visible\n\tprivate _fit(useFit = this.options.useFit) {\n\t\tlet base = this._getEdgeValue(\"start\");\n\t\tconst margin = (this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize) || 0;\n\t\tconst { isConstantSize, isEqualSize, useRecycle } = this.options;\n\n\t\tif (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n\t\t\tif (base < margin) {\n\t\t\t\tthis._fitItems(base - margin, margin);\n\t\t\t}\n\t\t\tbase = 0;\n\t\t} else if (base !== 0 || margin) {\n\t\t\tthis._fitItems(base - margin, margin);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tthis.isLoading() && this._renderLoading();\n\t\treturn base;\n\t}\n\tprivate _getEdgeValue(cursor: CursorType) {\n\t\treturn this._infinite.getEdgeValue(cursor);\n\t}\n\tprivate _isProcessing() {\n\t\treturn (this._status.processingStatus & PROCESSING) > 0;\n\t}\n\tprivate _getLoadingStatus() {\n\t\treturn this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n\t}\n\tprivate _process(status: number, isAdd = true) {\n\t\tif (isAdd) {\n\t\t\tthis._status.processingStatus |= status;\n\t\t} else {\n\t\t\tthis._status.processingStatus -= this._status.processingStatus & status;\n\t\t}\n\t}\n\tprivate _insert({\n\t\telements,\n\t\tisAppend,\n\t\thasChildren,\n\t\tgroupKey = new Date().getTime() + Math.floor(Math.random() * 1000),\n\t}: {\n\t\telements: string | string[] | HTMLElement[] | IJQuery,\n\t\tisAppend?: boolean,\n\t\thasChildren?: boolean,\n\t\tgroupKey?: string | number,\n\t}) {\n\t\tif (this._isProcessing() || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst items = ItemManager.toItems($(elements, true), groupKey);\n\n\t\tthis._insertItems({\n\t\t\titems,\n\t\t\tisAppend,\n\t\t\thasChildren,\n\t\t\tgroupKey,\n\t\t});\n\t}\n\tprivate _insertItems({\n\t\titems,\n\t\tisAppend,\n\t\thasChildren,\n\t\tgroupKey = new Date().getTime() + Math.floor(Math.random() * 1000),\n\t}: {\n\t\titems: IInfiniteGridItem[],\n\t\tisAppend?: boolean,\n\t\thasChildren?: boolean,\n\t\tgroupKey?: string | number,\n\t}) {\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst group = this._itemManager[isAppend ? \"appendGroup\" : \"prependGroup\"]({\n\t\t\tgroupKey,\n\t\t\titems,\n\t\t})!;\n\t\tif (!isAppend) {\n\t\t\tconst infinite = this._infinite;\n\t\t\tconst [startCursor, endCursor] = infinite.getCursors();\n\n\t\t\tinfinite.setCursor(\"start\", startCursor + 1);\n\t\t\tinfinite.setCursor(\"end\", endCursor + 1);\n\t\t}\n\t\tthis._postLayout({\n\t\t\tfromCache: false,\n\t\t\tgroups: [group],\n\t\t\titems: group.items,\n\t\t\tnewItems: group.items,\n\t\t\tisAppend,\n\t\t\thasChildren,\n\t\t\tisTrusted: false,\n\t\t});\n\t}\n\t// add items, and remove items for recycling\n\tprivate _recycle(ranges: Array<{ start: number, end: number }>) {\n\t\tconst { useRecycle, renderExternal } = this.options;\n\t\tif (!useRecycle) {\n\t\t\treturn false;\n\t\t}\n\t\tlet isRecycle = false;\n\t\tranges.forEach(({ start, end }) => {\n\t\t\tif (start === -1 || end === -1 || end < start) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst items = this._itemManager.pluck(\"items\", start, end);\n\n\t\t\tisRecycle = isRecycle || items.some(item => item.mounted);\n\t\t\titems.forEach(item => {\n\t\t\t\titem.mounted = false;\n\t\t\t});\n\t\t\tif (!renderExternal) {\n\t\t\t\tDOMRenderer.removeItems(items);\n\t\t\t}\n\t\t});\n\t\tif (isRecycle) {\n\t\t\tthis._requestGroups = [];\n\t\t\tthis.trigger(\"render\", {\n\t\t\t\tnext: () => { },\n\t\t\t});\n\t\t}\n\t\treturn isRecycle;\n\t}\n\tprivate _renderLoading(userStyle = this._status.loadingStyle) {\n\t\tif (!this.isLoading()) {\n\t\t\treturn;\n\t\t}\n\t\tconst isAppend = this._getLoadingStatus() === LOADING_APPEND;\n\t\tconst el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\tconst style = assign({\n\t\t\tposition: \"absolute\",\n\t\t}, userStyle);\n\n\t\tfor (const property in style) {\n\t\t\tel.style[property as keyof StyleType] = style[property as keyof StyleType];\n\t\t}\n\t\tthis._status.loadingSize = this.options.horizontal ? outerWidth(el) : outerHeight(el);\n\t\tconst posName = this.options.horizontal ? \"left\" : \"top\";\n\n\t\tif (!(posName in style)) {\n\t\t\tconst pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n\n\t\t\tel.style[posName] = `${pos}px`;\n\t\t}\n\t}\n\tprivate _updateItem(item?: IInfiniteGridItem) {\n\t\tif (item && item.el) {\n\t\t\titem.content = item.el.outerHTML;\n\n\t\t\t!this.options.isEqualSize && resetSize(item);\n\t\t\tthis._renderer.updateSize([item]);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate _setScrollPos(pos: number) {\n\t\tthis._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n\t}\n\tprivate _scrollTo(pos: number) {\n\t\tthis._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n\t}\n\tprivate _postCache({\n\t\tcache,\n\t\tisAppend,\n\t\tisTrusted = true,\n\t}: {\n\t\tcache: IInfiniteGridGroup[],\n\t\tisAppend?: boolean,\n\t\tisTrusted?: boolean,\n\t}) {\n\t\tconst { isConstantSize } = this.options;\n\t\tconst items = ItemManager.pluck(cache, \"items\");\n\t\tlet fromCache = true;\n\t\tconst newItems = items.filter(item => {\n\t\t\tif (!item.orgSize || !item.orgSize.width) {\n\t\t\t\tfromCache = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !isConstantSize && item.rect.top < DUMMY_POSITION / 10;\n\t\t});\n\n\t\treturn this._postLayout({\n\t\t\tfromCache,\n\t\t\tgroups: cache,\n\t\t\titems,\n\t\t\tnewItems,\n\t\t\tisAppend,\n\t\t\tisTrusted,\n\t\t});\n\t}\n\tprivate _postLayout({\n\t\tfromCache,\n\t\tgroups,\n\t\titems = ItemManager.pluck(groups, \"items\"),\n\t\tnewItems,\n\t\tisAppend,\n\t\thasChildren,\n\t\tisTrusted,\n\t}: {\n\t\tfromCache: boolean,\n\t\tgroups: IInfiniteGridGroup[],\n\t\titems?: IInfiniteGridItem[],\n\t\tnewItems?: IInfiniteGridItem[],\n\t\tisAppend?: boolean,\n\t\thasChildren?: boolean,\n\t\tisTrusted?: boolean,\n\t}) {\n\t\tthis._process(PROCESSING);\n\n\t\tif (!groups.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst renderExternal = this.options.renderExternal;\n\t\tconst renderer = this._renderer;\n\t\tconst callbackComponent = new Component();\n\n\t\tconst next = () => {\n\t\t\titems.forEach(item => {\n\t\t\t\titem.mounted = true;\n\t\t\t});\n\t\t\tthis._renderManager\n\t\t\t\t.render(callbackComponent, groups, newItems, isAppend)\n\t\t\t\t.on(\"renderComplete\", ({ start, end }) => {\n\t\t\t\t\tthis._setCursor(start, end);\n\t\t\t\t}).on(\"imageError\", e => {\n\t\t\t\t\t/**\n\t\t\t\t\t * This event is fired when an error occurs in the image.\n\t\t\t\t\t * @ko 이미지 로드에 에러가 날 때 발생하는 이벤트.\n\t\t\t\t\t * @event eg.InfiniteGrid#imageError\n\t\t\t\t\t * @param {eg.InfiniteGrid.IErrorCallbackOptions} e The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t\t\t * @example\n\t\t\t\t\tig.on(\"imageError\", e => {\n\t\t\t\t\te.remove();\n\t\t\t\t\te.removeItem();\n\t\t\t\t\te.replace(\"http://...jpg\");\n\t\t\t\t\te.replace(imageElement);\n\t\t\t\t\te.replaceItem(\"item html\");\n\t\t\t\t\t});\n\t\t\t\t\t*/\n\t\t\t\t\tthis.trigger(\"imageError\", assign(e, { element: e.item.el }));\n\t\t\t\t}).on(\"layoutComplete\", ({\n\t\t\t\t\titems: layoutItems,\n\t\t\t\t}) => {\n\t\t\t\t\tthis._process(PROCESSING, false);\n\t\t\t\t\tthis._onLayoutComplete({\n\t\t\t\t\t\titems: layoutItems,\n\t\t\t\t\t\tisAppend,\n\t\t\t\t\t\tfromCache,\n\t\t\t\t\t\tisTrusted,\n\t\t\t\t\t\tuseRecycle: false,\n\t\t\t\t\t});\n\t\t\t\t}).on(\"finish\", ({ remove, layout }) => {\n\t\t\t\t\tremove.forEach(el => this.remove(el, false));\n\t\t\t\t\tif (layout) {\n\t\t\t\t\t\tthis.layout(false);\n\t\t\t\t\t} else if (!this.isProcessing() && this.options.useRecycle) {\n\t\t\t\t\t\tconst scroller = this._watcher;\n\t\t\t\t\t\tconst scrollPos = scroller.getScrollPos();\n\n\t\t\t\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t};\n\n\t\tif (!hasChildren) {\n\t\t\tif (renderExternal) {\n\t\t\t\tif (items.every(item => item.mounted)) {\n\t\t\t\t\tnext();\n\t\t\t\t} else {\n\t\t\t\t\tthis._requestGroups = groups;\n\t\t\t\t\tthis.trigger(\"render\", {\n\t\t\t\t\t\tnext: () => {\n\t\t\t\t\t\t\t!hasChildren && DOMRenderer.renderItems(items);\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn callbackComponent;\n\t\t\t} else {\n\t\t\t\t// If container has children, it does not render first.\n\t\t\t\trenderer.createAndInsert(items, isAppend);\n\t\t\t}\n\t\t}\n\t\tnext();\n\n\t\treturn callbackComponent;\n\t}\n\t// called by visible\n\tprivate _requestAppend({ cache }: { cache?: IInfiniteGridGroup[] }) {\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache && cache.length) {\n\t\t\tthis._postCache({ cache, isAppend: true });\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n\t\t\t * @ko 카드 엘리먼트가 레이아웃의 아래나 오른쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 아래나 오른쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다\n\t\t\t * @event eg.InfiniteGrid#append\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 마지막 그룹의 그룹키</ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n\t\t\t * @param {Function} param.startLoading Start loading for append loading data. <ko> 뒷쪽에 추가되는 데이터 로딩을 시작한다. </ko>\n\t\t\t * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩을 시작할 때 로딩 바에 적용될 사용자 스타일 </ko>\n\t\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n\t\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n\t\t\t */\n\t\t\tthis.trigger(\"append\", {\n\t\t\t\tisTrusted: true,\n\t\t\t\tgroupKey: this.getGroupKeys().pop() || \"\",\n\t\t\t\tstartLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.startLoading(true, userStyle);\n\t\t\t\t},\n\t\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.endLoading(userStyle);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\t// called by visible\n\tprivate _requestPrepend({ cache }: { cache?: IInfiniteGridGroup[] }) {\n\t\tthis._fit(this.options.useFit || !cache || !cache.length);\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache && cache.length) {\n\t\t\tthis._postCache({ cache, isAppend: false });\n\t\t} else {\n\t\t\t/**\n\t\t\t * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n\t\t\t * @ko 카드가 레이아웃의 위나 왼쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 위나 왼쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다.\n\t\t\t * @event eg.InfiniteGrid#prepend\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 첫번째 그룹의 그룹키</ko>\n\t\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n\t\t\t * @param {Function} param.startLoading Start loading for prepend loading data. <ko> 앞쪽에 추가되는 데이터 로딩을 시작한다. </ko>\n\t\t\t * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩을 시작할 때 로딩 바에 적용될 사용자 스타일 </ko>\n\t\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n\t\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n\t\t\t */\n\t\t\tthis.trigger(\"prepend\", {\n\t\t\t\tisTrusted: true,\n\t\t\t\tgroupKey: this.getGroupKeys().shift(),\n\t\t\t\tstartLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.startLoading(false, userStyle);\n\t\t\t\t},\n\t\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\t\tthis.endLoading(userStyle);\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n\tprivate _onResize() {\n\t\tthis.layout(true);\n\t}\n\tprivate _setCursor(start: number, end: number) {\n\t\tconst infinite = this._infinite;\n\t\tconst [startCursor, endCursor] = infinite.getCursors();\n\t\tinfinite.setCursor(\"start\", start);\n\t\tinfinite.setCursor(\"end\", end);\n\n\t\tconst isRecycle = this._recycle([\n\t\t\t{ start: startCursor, end: start - 1 },\n\t\t\t{ start: end + 1, end: endCursor },\n\t\t]);\n\t\tif (!isRecycle) {\n\t\t\tthis._requestGroups = [];\n\t\t\tthis.trigger(\"render\", {\n\t\t\t\tnext: () => { },\n\t\t\t});\n\t\t}\n\t}\n\tprivate _onCheck({\n\t\tisForward,\n\t\tscrollPos,\n\t\thorizontal,\n\t\torgScrollPos,\n\t}: {\n\t\tisForward: boolean,\n\t\tscrollPos: number,\n\t\thorizontal: boolean,\n\t\torgScrollPos: number,\n\t}) {\n\t\t/**\n\t\t * This event is fired when the user scrolls.\n\t\t * @ko 사용자가 스크롤 할 경우 발생하는 이벤트.\n\t\t * @event eg.InfiniteGrid#change\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>스크롤 진행방향이 앞쪽으로 진행하는 지, 뒤쪽으로 진행하는지를 나타낸다.</ko>\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n\t\t * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n\t\t * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n\t\t */\n\t\tthis.trigger(\"change\", {\n\t\t\tisForward,\n\t\t\thorizontal,\n\t\t\tscrollPos,\n\t\t\torgScrollPos,\n\t\t});\n\t\tthis._infinite.scroll(scrollPos);\n\t}\n\tprivate _onLayoutComplete({\n\t\titems,\n\t\tisAppend,\n\t\tisTrusted = false,\n\t\tuseRecycle = this.options.useRecycle,\n\t\tfromCache = false,\n\t\tisLayout = false,\n\t}: {\n\t\titems: IInfiniteGridItem[],\n\t\tisAppend?: boolean,\n\t\tisTrusted?: boolean,\n\t\tuseRecycle: boolean,\n\t\tfromCache: boolean,\n\t\tisLayout?: boolean,\n\t}) {\n\t\tconst viewSize = this._renderer.getViewSize();\n\n\t\tif (!isAppend) {\n\t\t\tthis._fit();\n\t\t} else {\n\t\t\tthis.isLoading() && this._renderLoading();\n\t\t}\n\n\t\tconst watcher = this._watcher;\n\t\tconst scrollPos = watcher.getScrollPos();\n\n\t\t// recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\t\tif (!isLayout && useRecycle && !this.isLoading()) {\n\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t}\n\n\t\tconst size = this._getEdgeValue(\"end\");\n\n\t\tif (isAppend) {\n\t\t\tthis._setContainerSize(size + this._status.loadingSize || 0);\n\t\t\tif (typeof scrollPos === \"number\" && scrollPos > 0) {\n\t\t\t\t!IS_IOS && this._scrollTo(scrollPos);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n\t\t * @ko 레이아웃 배치가 완료됐을 때 발생하는 이벤트. append() 메서드나 prepend() 메서드, layout() 메서드 호출 후 카드의 배치가 완료됐을 때 발생한다\n\t\t * @event eg.InfiniteGrid#layoutComplete\n\t\t *\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {Array} param.target Rearranged card elements<ko>재배치된 카드 엘리먼트들</ko>\n\t\t * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>해당 아이템들이 캐시인지 아닌지 확인한다.</ko>\n\t\t * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>해당 이벤트가 리사이즈 이벤트 또는 layout() 메서드를 통해 호출됐으면 true, 아이템 추가로 호출됐으면 false를 반환한다.</ko>\n\t\t * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>카드 엘리먼트가 append() 메서드로 추가됐는지 확인한다. layout() 메서드가 호출된 후 layoutComplete 이벤트가 발생해도 'true'를 반환한다.</ko>\n\t\t * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend 등 호출 후 스크롤이 생겼는지 확인한다.</ko>\n\t\t * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n\t\t * @param {Number} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n\t\t * @param {Number} param.size The size of container element <ko>컨테이너 엘리먼트의 크기</ko>\n\t\t * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n\t\t * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>데이터 로딩을 위해 append/prepend startLoading() 호출 이후 로딩을 끝낸다.</ko>\n\t\t * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko> 로딩이 끝날 때 로딩 바에 적용될 사용자 스타일 </ko>\n\t\t */\n\t\tthis.trigger(\"layoutComplete\", {\n\t\t\ttarget: items.concat(),\n\t\t\tisAppend: !!isAppend,\n\t\t\tisTrusted,\n\t\t\tfromCache,\n\t\t\tisLayout,\n\t\t\tisScroll: viewSize < watcher.getContainerOffset() + size,\n\t\t\tscrollPos,\n\t\t\torgScrollPos: watcher.getOrgScrollPos(),\n\t\t\tsize,\n\t\t\tendLoading: (userStyle: StyleType) => {\n\t\t\t\tthis.endLoading(userStyle);\n\t\t\t},\n\t\t});\n\t\tthis._infinite.scroll(scrollPos);\n\t}\n\tprivate _reset() {\n\t\tthis._status = {\n\t\t\tprocessingStatus: IDLE,\n\t\t\tloadingSize: 0,\n\t\t\tloadingStyle: {},\n\t\t};\n\t}\n}\n\nexport default InfiniteGrid;\n","import { ALIGN } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\";\nimport { ILayout, IAlign, IRectlProperties, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\n// ALIGN\nconst { START, CENTER, END, JUSTIFY } = ALIGN;\n\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 카드를 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 카드 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>아이템들의 위치의 정렬 (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n  margin: 10,\n  align: \"start\",\n  itemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n  margin: 10,\n  align: \"center\",\n  itemSize: 200,\n  horizontal: true,\n});\n\n</script>\n```\n **/\nclass GridLayout implements ILayout {\n\tpublic options: {\n\t\thorizontal: boolean,\n\t\tmargin: number,\n\t\talign: IAlign[keyof IAlign],\n\t\titemSize: number,\n\t};\n\tprivate _size: number;\n\tprivate _columnSize: number;\n\tprivate _columnLength: number;\n\tprivate _style: IRectlProperties;\n\tconstructor(options: Partial<GridLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\talign: START,\n\t\t\titemSize: 0,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._columnSize = 0;\n\t\tthis._columnLength = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.GridLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, true, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko 아이템을 아웃라인 위에 추가한다.\n\t * @method eg.InfiniteGrid.GridLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100, 200, 300, 400]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, false, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.GridLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst firstItem = (groups.length && groups[0].items.length && groups[0].items[0]) as IInfiniteGridItem;\n\n\t\tthis.checkColumn(firstItem);\n\n\t\t// if outlines' length and columns' length are now same, re-caculate outlines.\n\t\tlet startOutline: number[];\n\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tconst pos = outline.length === 0 ? 0 : Math.min(...outline);\n\n\t\t\t// re-layout items.\n\t\t\tstartOutline = fill(new Array(this._columnLength), pos);\n\t\t} else {\n\t\t\tstartOutline = outline.slice();\n\t\t}\n\t\tgroups.forEach(group => {\n\t\t\tconst items = group.items;\n\t\t\tconst result = this._layout(items, startOutline, true);\n\n\t\t\tgroup.outlines = result;\n\t\t\tstartOutline = result.end;\n\t\t});\n\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko 레이아웃의 가시 사이즈를 설정한다.\n\t * @method eg.InfiniteGrid.GridLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n\t * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\tprivate checkColumn(item: IInfiniteGridItem) {\n\t\tconst { itemSize, margin, horizontal } = this.options;\n\t\tconst sizeName = horizontal ? \"height\" : \"width\";\n\t\tconst columnSize = Math.floor(itemSize || (item && item.size![sizeName]) || 0) || 0;\n\n\t\tthis._columnSize = columnSize;\n\t\tif (!columnSize) {\n\t\t\tthis._columnLength = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis._columnLength = Math.max(Math.floor((this._size + margin) / (columnSize + margin)), 1);\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[], isAppend?: boolean) {\n\t\tconst length = items.length;\n\t\tconst margin = this.options.margin;\n\t\tconst align = this.options.align;\n\t\tconst style = this._style;\n\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst columnSize = this._columnSize;\n\t\tconst columnLength = this._columnLength;\n\n\t\tconst size = this._size;\n\t\tconst viewDist = (size - (columnSize + margin) * columnLength + margin);\n\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst startOutline = outline.slice();\n\t\tconst endOutline = outline.slice();\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline) || 0;\n\t\t\tlet index = endOutline.indexOf(point);\n\t\t\tconst item = items[isAppend ? i : length - 1 - i];\n\t\t\tconst itemSize = item.size;\n\n\t\t\tif (!itemSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst size1 = itemSize[size1Name];\n\t\t\tconst size2 = itemSize[size2Name];\n\t\t\tconst pos1 = isAppend ? point : point - margin - size1;\n\t\t\tconst endPos1 = pos1 + size1 + margin;\n\n\t\t\tif (index === -1) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tlet pos2 = (columnSize + margin) * index;\n\n\t\t\t// ALIGN\n\t\t\tif (align === CENTER) {\n\t\t\t\tpos2 += viewDist / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tpos2 += viewDist + columnSize - size2;\n\t\t\t} else if (align === JUSTIFY) {\n\t\t\t\tif (columnLength <= 1) {\n\t\t\t\t\tpos2 += viewDist / 2;\n\t\t\t\t} else {\n\t\t\t\t\tpos2 = (size - columnSize) / (columnLength - 1) * index;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// tetris\n\t\t\titem.rect = {\n\t\t\t\t[pos1Name as \"top\"]: pos1,\n\t\t\t\t[pos2Name as \"left\"]: pos2,\n\t\t\t};\n\t\t\titem.column = index;\n\t\t\tendOutline[index] = isAppend ? endPos1 : pos1;\n\t\t}\n\t\tif (!isAppend) {\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t}\n\t\t// if append items, startOutline is low, endOutline is high\n\t\t// if prepend items, startOutline is high, endOutline is low\n\t\treturn {\n\t\t\tstart: isAppend ? startOutline : endOutline,\n\t\t\tend: isAppend ? endOutline : startOutline,\n\t\t};\n\t}\n\tprivate _insert(\n\t\titems: IInfiniteGridItem[] = [],\n\t\toutline: number[] = [],\n\t\tisAppend?: boolean,\n\t\tcache?: boolean,\n\t) {\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\tlet startOutline = outline;\n\n\t\tif (!this._columnLength) {\n\t\t\tthis.checkColumn(items[0]);\n\t\t}\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tstartOutline = fill(new Array(this._columnLength), outline.length ? (Math[isAppend ? \"min\" : \"max\"](...outline) || 0) : 0);\n\t\t}\n\n\t\tconst result = this._layout(clone, startOutline, isAppend);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: result,\n\t\t};\n\t}\n}\n\nexport default GridLayout;\n","import { DUMMY_POSITION } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, ISize, IInfiniteGridGroup, IInfiniteGridItem } from \"../types\";\n\nexport type FrameType = number[][];\nexport interface IFrameShape {\n\tleft?: number;\n\ttop?: number;\n\ttype: any;\n\twidth: number;\n\theight: number;\n\tindex?: number;\n}\nexport interface IFrameLayoutInterface {\n\thorizontal: boolean;\n\tmargin: number;\n\tframe: FrameType;\n\tframeFill: boolean;\n\titemSize: number | ISize;\n\t[key: string]: any;\n}\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\nfunction disableFrame(\n\tframe: FrameType,\n\ttype: number,\n\ttop: number,\n\tleft: number,\n\twidth: number,\n\theight: number,\n) {\n\tfor (let i = top; i < top + height; ++i) {\n\t\tfor (let j = left; j < left + width; ++j) {\n\t\t\tif (type !== frame[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe[i][j] = 0;\n\t\t}\n\t}\n}\nfunction searchShapeInFrame(\n\tframe: FrameType,\n\ttype: number,\n\ttop: number,\n\tleft: number,\n\twidth: number,\n\theight: number,\n) {\n\tconst size: IFrameShape = {\n\t\tleft,\n\t\ttop,\n\t\ttype,\n\t\twidth: 1,\n\t\theight: 1,\n\t};\n\n\tfor (let i = left; i < width; ++i) {\n\t\tif (frame[top][i] === type) {\n\t\t\tsize.width = i - left + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfor (let i = top; i < height; ++i) {\n\t\tif (frame[i][left] === type) {\n\t\t\tsize.height = i - top + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t// After finding the shape, it will not find again.\n\tdisableFrame(frame, type, top, left, size.width, size.height);\n\treturn size;\n}\nfunction getShapes(frame: FrameType) {\n\tconst height = frame.length;\n\tconst width = height ? frame[0].length : 0;\n\tconst shapes: IFrameShape[] = [];\n\n\tfor (let i = 0; i < height; ++i) {\n\t\tfor (let j = 0; j < width; ++j) {\n\t\t\tconst type = frame[i][j];\n\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Separate shapes with other numbers.\n\t\t\tshapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n\t\t}\n\t}\n\tshapes.sort((a, b) => (a.type < b.type ? -1 : 1));\n\treturn {\n\t\tshapes,\n\t\twidth,\n\t\theight,\n\t};\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout은 주어진 프레임에 맞춰 카드를 배치하는 레이아웃입니다. 디자이너가 직접 이미지를 배치하는 것과 알고리즘을 사용한 배치의 중간 정도 수준에 해당하는 레이아웃이다.\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko> 다음 프레임이 전 프레임에 이어 붙일 수 있는지 있는지 확인한다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n  margin: 10,\n  itemSize: 200,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n  margin: 10,\n  itemSize: 200,\n  horizontal: true,\n  frame: [\n    [1, 1, 1, 1, 1],\n    [0, 0, 2, 2, 2],\n    [0, 0, 2, 2, 2],\n    [3, 4, 5, 5, 5],\n  ],\n});\n\n</script>\n```\n **/\nclass FrameLayout implements ILayout {\n\tpublic options: IFrameLayoutInterface;\n\tprotected _itemSize: number | ISize;\n\tprotected _shapes: {\n\t\tshapes: IFrameShape[],\n\t\twidth?: number,\n\t\theight?: number,\n\t};\n\tprotected _size: number;\n\tprotected _style: IRectlProperties;\n\n\tconstructor(options: Partial<IFrameLayoutInterface> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\titemSize: 0,\n\t\t\tframe: [],\n\t\t\tframeFill: true,\n\t\t}, options);\n\t\tconst frame = this.options.frame.map(row => row.slice());\n\n\t\tthis._itemSize = this.options.itemSize || 0;\n\t\t// divide frame into shapes.\n\t\tthis._shapes = getShapes(frame);\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.FrameLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, true);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko 레이아웃의 가시 사이즈를 설정한다.\n\t * @method eg.InfiniteGrid.FrameLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n\t * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.FrameLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, true, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko 아이템을 아웃라인 위에 추가한다.\n\t * @method eg.InfiniteGrid.FrameLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, false, cache);\n\t}\n\tprotected _getItemSize() {\n\t\tthis._checkItemSize();\n\n\t\treturn this._itemSize;\n\t}\n\tprotected _checkItemSize() {\n\t\tif (this.options.itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t\treturn;\n\t\t}\n\t\tconst style = this._style;\n\t\tconst size = style.size2;\n\t\tconst margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / this._shapes[size]! - margin;\n\t}\n\tprotected _layout(items: IInfiniteGridItem[], outline: number[] = [], isAppend?: boolean) {\n\t\tconst length = items.length;\n\t\tconst style = this._style;\n\t\tconst { margin, frameFill } = this.options;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst itemSize = this._getItemSize();\n\t\tconst isItemObject = typeof itemSize === \"object\";\n\t\tconst itemSize2 = isItemObject ? (itemSize as ISize)[size2Name] : itemSize as number;\n\t\tconst itemSize1 = isItemObject ? (itemSize as ISize)[size1Name] : itemSize as number;\n\t\tconst shapesSize = this._shapes[size2Name]!;\n\t\tconst shapes = this._shapes.shapes;\n\t\tconst shapesLength = shapes.length;\n\t\tconst startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tconst endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n\t\tlet dist = 0;\n\t\tlet end = 0;\n\n\t\tif (!shapesLength) {\n\t\t\treturn { start: outline, end: outline };\n\t\t}\n\t\tfor (let i = 0; i < length; i += shapesLength) {\n\t\t\tfor (let j = 0; j < shapesLength && i + j < length; ++j) {\n\t\t\t\tconst item = items[i + j];\n\t\t\t\tconst shape = shapes[j];\n\t\t\t\tconst shapePos1 = shape[pos1Name]!;\n\t\t\t\tconst shapePos2 = shape[pos2Name]!;\n\t\t\t\tconst shapeSize1 = shape[size1Name]!;\n\t\t\t\tconst shapeSize2 = shape[size2Name]!;\n\t\t\t\tconst pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n\t\t\t\tconst pos2 = shapePos2 * (itemSize2 + margin);\n\t\t\t\tconst size1 = shapeSize1 * (itemSize1 + margin) - margin;\n\t\t\t\tconst size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n\t\t\t\tfor (let k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n\t\t\t\t\tif (startOutline[k] === DUMMY_POSITION) {\n\t\t\t\t\t\tstartOutline[k] = pos1;\n\t\t\t\t\t}\n\t\t\t\t\tstartOutline[k] = Math.min(startOutline[k], pos1);\n\t\t\t\t\tendOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n\t\t\t\t}\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t} as any;\n\t\t\t}\n\t\t\tend = Math.max(...endOutline);\n\t\t\t// check dist once\n\t\t\tif (i !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// find & fill empty block\n\t\t\tif (!frameFill) {\n\t\t\t\tdist = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist = end;\n\n\t\t\tfor (let j = 0; j < shapesSize; ++j) {\n\t\t\t\tif (startOutline[j] === DUMMY_POSITION) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// the dist between frame's end outline and next frame's start outline\n\t\t\t\t// expect that next frame's start outline is startOutline[j] + end\n\t\t\t\tdist = Math.min(startOutline[j] + end - endOutline[j], dist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tif (startOutline[i] !== DUMMY_POSITION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstartOutline[i] = Math.max(...startOutline);\n\t\t\tendOutline[i] = startOutline[i];\n\t\t}\n\t\t// The target outline is start outline when type is appending\n\t\tconst targetOutline = isAppend ? startOutline : endOutline;\n\t\tconst prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"](...outline);\n\t\tlet prevOutlineDist = isAppend ? 0 : end;\n\n\t\tif (frameFill && outline.length === shapesSize) {\n\t\t\tprevOutlineDist = -DUMMY_POSITION;\n\t\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\t\tif (startOutline[i] === endOutline[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// if appending type is prepend(false), subtract dist from appending group's height.\n\n\t\t\t\tprevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < shapesSize; ++i) {\n\t\t\tstartOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t\tendOutline[i] += prevOutlineEnd - prevOutlineDist;\n\t\t}\n\t\titems.forEach(item => {\n\t\t\titem.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n\t\t});\n\t\treturn {\n\t\t\tstart: startOutline.map(point => parseInt(point, 10)),\n\t\t\tend: endOutline.map(point => parseInt(point, 10)),\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default FrameLayout;\n","import FrameLayout, { IFrameLayoutInterface, IFrameShape } from \"./FrameLayout\";\nimport { fill } from \"../utils\";\nimport { IInfiniteGridItem } from \"../types\";\n\nfunction makeShapeOutline(\n\toutline: number[],\n\titemSize: number,\n\tcolumnLength: number,\n\tisAppend?: boolean,\n) {\n\tconst point = Math[isAppend ? \"min\" : \"max\"](...outline) || 0;\n\n\tif (outline.length !== columnLength) {\n\t\treturn fill(new Array(columnLength), 0);\n\t}\n\treturn outline.map(l => Math.floor((l - point) / itemSize));\n}\nfunction getColumn(item: IInfiniteGridItem) {\n\tif (item.column) {\n\t\treturn item.column;\n\t}\n\tlet column = 1;\n\n\tif (item.el) {\n\t\tcolumn = parseInt(item.el.getAttribute(\"data-column\")!, 10) || 1;\n\t}\n\titem.column = column;\n\treturn column;\n}\nexport interface ISquareLayoutOptions extends IFrameLayoutInterface {\n\tcolumn: number;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout은 바둑판처럼 모든 카드를 정사각형으로 배치하고 중요한 카드는 크기를 N배로 키워서 보여주는 레이아웃이다. 주요 카드를 크게 표시하고, 그 다음에 작은 카드를 배치해 자연스럽게 카드의 관계를 나타낼 수 있습니다.\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. (priority: `column` > `itemSize` > element's size)<ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. (우선순위: `column` > `itemSize` > 엘리먼트의 사이즈) </ko>\n * @param {Boolean} [options.column=0] The number of columns in the layout. If it is 0, the column is returned by `itemSize`.  (priority: `column` > `itemSize` > element's size)<ko> 레이아웃의 열의 개수. 만약 column이 0이면, `itemSize`로 열을 구합니다. (우선순위: `column` > `itemSize` > 엘리먼트의 사이즈) </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\nexport default class SquareLayout extends FrameLayout {\n\tpublic options: ISquareLayoutOptions;\n\n\tconstructor(options: Partial<ISquareLayoutOptions> = {}) {\n\t\tsuper(options);\n\t}\n\tprotected _layout(\n\t\titems: IInfiniteGridItem[],\n\t\toutline: number[] = [],\n\t\tisAppend: boolean = false,\n\t) {\n\t\tconst itemSize = this._getSquareSize(items[0]) as number;\n\t\tconst margin = this.options.margin;\n\t\tconst columnLength = this.options.column ||\n\t\t\tMath.floor((this._size + margin) / (itemSize + margin)) || 1;\n\t\tconst length = items.length;\n\t\tconst endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n\t\tconst pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tconst shapes: IFrameShape[] = [];\n\t\tconst sign = isAppend ? 1 : -1;\n\t\tconst style = this._style;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst pos2Name = style.startPos2;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst point = Math[pointCaculateName](...endOutline);\n\t\t\tlet index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n\t\t\tconst item = items[i];\n\t\t\tconst columnWidth = item.columnWidth;\n\t\t\tconst column = (columnWidth && columnWidth[0] === columnLength &&\n\t\t\t\tcolumnWidth[1]) || getColumn(item);\n\t\t\tlet columnCount = 1;\n\n\t\t\tif (column > 1) {\n\t\t\t\tfor (let j = 1; j < column &&\n\t\t\t\t\t((isAppend && index + j < columnLength) || (!isAppend && index - j >= 0)); ++j) {\n\t\t\t\t\tif ((isAppend && endOutline[index + sign * j] <= point) ||\n\t\t\t\t\t\t(!isAppend && endOutline[index + sign * j] >= point)) {\n\t\t\t\t\t\t++columnCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isAppend) {\n\t\t\t\t\tindex -= columnCount - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.columnWidth = [columnLength, columnCount];\n\t\t\tshapes.push({\n\t\t\t\twidth: columnCount,\n\t\t\t\theight: columnCount,\n\t\t\t\t[pos1Name]: point - (!isAppend ? columnCount : 0),\n\t\t\t\t[pos2Name]: index,\n\t\t\t\ttype: i + 1,\n\t\t\t\tindex: i,\n\t\t\t});\n\t\t\tfor (let j = 0; j < columnCount; ++j) {\n\t\t\t\tendOutline[index + j] = point + sign * columnCount;\n\t\t\t}\n\t\t}\n\t\tthis._shapes = {\n\t\t\tshapes,\n\t\t\t[style.size2]: columnLength,\n\t\t};\n\n\t\tconst result = super._layout(items, outline, isAppend);\n\n\t\tif (!isAppend) {\n\t\t\tshapes.sort((shape1, shape2) => {\n\t\t\t\tconst item1pos1 = shape1[pos1Name]!;\n\t\t\t\tconst item1pos2 = shape1[pos2Name]!;\n\t\t\t\tconst item2pos1 = shape2[pos1Name]!;\n\t\t\t\tconst item2pos2 = shape2[pos2Name]!;\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\titems.sort((a, b) => {\n\t\t\t\tconst item1pos1 = a.rect[pos1Name];\n\t\t\t\tconst item1pos2 = a.rect[pos2Name];\n\t\t\t\tconst item2pos1 = b.rect[pos1Name];\n\t\t\t\tconst item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\tprivate _getSquareSize(item: IInfiniteGridItem) {\n\t\tconst { column, margin, itemSize } = this.options;\n\n\t\tif (column) {\n\t\t\t// if column is in options, caculate itemSize from column.\n\t\t\tthis._itemSize = (this._size + margin) / column - margin;\n\t\t} else if (itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t} else {\n\t\t\tconst sizeName = this._style.size2;\n\t\t\t// if frameSize is 0, caculate frameSize from item.size.\n\t\t\tconst frameSize\n\t\t\t\t= this._shapes[sizeName]\n\t\t\t\t|| Math.floor((this._size + margin) / (item.size![sizeName]! + margin) / getColumn(item));\n\t\t\tthis._itemSize = (this._size + margin) / frameSize - margin;\n\t\t}\n\t\treturn this._itemSize;\n\t}\n}\n","import { assign } from \"../../utils\";\n\nexport interface IBoxModel {\n\toriginWidth: number;\n\toriginHeight: number;\n\twidth: number;\n\theight: number;\n\tleft: number;\n\ttop: number;\n\titems: BoxModel[];\n}\n\nexport default class BoxModel implements IBoxModel {\n\tpublic originWidth: number;\n\tpublic originHeight: number;\n\tpublic width: number;\n\tpublic height: number;\n\tpublic left: number;\n\tpublic top: number;\n\tpublic items: BoxModel[];\n\tconstructor(options: Partial<IBoxModel>) {\n\t\tassign(this, {\n\t\t\toriginWidth: 0,\n\t\t\toriginHeight: 0,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\titems: [],\n\t\t}, options);\n\t}\n\tpublic scaleTo(width: number, height: number) {\n\t\tconst scaleX = this.width ? width / this.width : 0;\n\t\tconst scaleY = this.height ? height / this.height : 0;\n\n\t\tthis.items.forEach(v => {\n\t\t\tif (scaleX !== 0) {\n\t\t\t\tv.left *= scaleX;\n\t\t\t\tv.width *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 0) {\n\t\t\t\tv.top *= scaleY;\n\t\t\t\tv.height *= scaleY;\n\t\t\t}\n\t\t});\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\tpublic push(item: BoxModel) {\n\t\tthis.items.push(item);\n\t}\n\tpublic getOriginSize() {\n\t\treturn this.originWidth * this.originHeight;\n\t}\n\tpublic getSize() {\n\t\treturn this.width * this.height;\n\t}\n\tpublic getOriginRatio() {\n\t\treturn (this.originHeight === 0) ? 0 : this.originWidth / this.originHeight;\n\t}\n\tpublic getRatio() {\n\t\treturn (this.height === 0) ? 0 : this.width / this.height;\n\t}\n}\n","import BoxModel from \"./lib/BoxModel\";\nimport { getStyleNames, assignOptions, toZeroArray, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, ISize, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\nfunction getCost(originLength: number, length: number) {\n\tlet cost = originLength / length;\n\n\tif (cost < 1) {\n\t\tcost = 1 / cost;\n\t}\n\n\treturn cost - 1;\n}\nfunction fitArea(\n\titem: BoxModel,\n\tbestFitArea: BoxModel,\n\titemFitSize: ISize,\n\tcontainerFitSize: ISize,\n\tlayoutVertical: boolean,\n) {\n\titem.height = itemFitSize.height;\n\titem.width = itemFitSize.width;\n\tbestFitArea.height = containerFitSize.height;\n\tbestFitArea.width = containerFitSize.width;\n\n\tif (layoutVertical) {\n\t\titem.top = bestFitArea.top + bestFitArea.height;\n\t\titem.left = bestFitArea.left;\n\t} else {\n\t\titem.left = bestFitArea.left + bestFitArea.width;\n\t\titem.top = bestFitArea.top;\n\t}\n}\n\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout은 카드의 본래 크기에 따른 비중을 해치지 않으면서 중요한 카드는 더 크게 보여 주는 레이아웃이다. 행과 열이 구분돼 이미지를 정돈되게 배치하는 대신 가로세로 일정 공간 내에서 동적으로 카드를 배치한다.\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko> 그룹의 가로 세로 비 </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko> 이미지를 배치할 때 사이즈 가중치 </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko> 이미지를 배치할 때 비율 가중치 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n  horizontal: true,\n  margin: 10,\n  aspectRatio: 1,\n  sizeWeight: 1,\n  ratioWeight: 2,\n});\n\n</script>\n```\n **/\nclass PackingLayout implements ILayout {\n\tpublic options: {\n\t\thorizontal: boolean,\n\t\tmargin: number,\n\t\taspectRatio: number,\n\t\tsizeWeight: number,\n\t\tratioWeight: number,\n\t};\n\tprivate _size: number;\n\tprivate _style: IRectlProperties;\n\tconstructor(options: Partial<PackingLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\taspectRatio: 1,\n\t\t\tsizeWeight: 1,\n\t\t\tratioWeight: 1,\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.PackingLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, true, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko 아이템을 아웃라인 위에 추가한다.\n\t * @method eg.InfiniteGrid.PackingLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, false, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.PackingLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.layout(groups, [100, 200, 300, 400]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, true);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko 레이아웃의 가시 사이즈를 설정한다.\n\t * @method eg.InfiniteGrid.PackingLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n\t * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\tprivate _findBestFitArea(container: BoxModel, item: BoxModel) {\n\t\tif (container.getRatio() === 0) { // 아이템 최초 삽입시 전체영역 지정\n\t\t\tcontainer.originWidth = item.width;\n\t\t\tcontainer.originHeight = item.height;\n\t\t\tcontainer.width = item.width;\n\t\t\tcontainer.height = item.height;\n\t\t\treturn;\n\t\t}\n\n\t\tlet bestFitArea!: BoxModel;\n\t\tlet minCost = 10000000;\n\t\tlet layoutVertical = false;\n\t\tconst itemFitSize: ISize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst containerFitSize: ISize = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t};\n\t\tconst { sizeWeight, ratioWeight } = this.options;\n\n\t\tcontainer.items.forEach(v => {\n\t\t\tconst containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n\t\t\tconst containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n\t\t\tconst width = v.width;\n\t\t\tconst height = v.height;\n\t\t\tlet cost;\n\n\t\t\tfor (let i = 0; i < 2; ++i) {\n\t\t\t\tlet itemWidth;\n\t\t\t\tlet itemHeight;\n\t\t\t\tlet containerWidth;\n\t\t\t\tlet containerHeight;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// 상하에 아이템 추가\n\t\t\t\t\titemWidth = width;\n\t\t\t\t\titemHeight = height * (item.height / (v.originHeight + item.height));\n\t\t\t\t\tcontainerWidth = width;\n\t\t\t\t\tcontainerHeight = height - itemHeight;\n\t\t\t\t} else {\n\t\t\t\t\t// 좌우에 아이템 추가\n\t\t\t\t\titemHeight = height;\n\t\t\t\t\titemWidth = width * (item.width / (v.originWidth + item.width));\n\t\t\t\t\tcontainerHeight = height;\n\t\t\t\t\tcontainerWidth = width - itemWidth;\n\t\t\t\t}\n\n\t\t\t\tconst itemSize = itemWidth * itemHeight;\n\t\t\t\tconst itemRatio = itemWidth / itemHeight;\n\t\t\t\tconst containerSize = containerWidth * containerHeight;\n\t\t\t\tconst containerRatio = containerHeight / containerHeight;\n\n\t\t\t\tcost = getCost(item.getSize(), itemSize) * sizeWeight;\n\t\t\t\tcost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n\t\t\t\tcost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n\t\t\t\tcost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n\t\t\t\tif (cost === Math.min(cost, minCost)) {\n\t\t\t\t\tminCost = cost;\n\t\t\t\t\tbestFitArea = v;\n\t\t\t\t\tlayoutVertical = (i === 0);\n\t\t\t\t\titemFitSize.width = itemWidth;\n\t\t\t\t\titemFitSize.height = itemHeight;\n\t\t\t\t\tcontainerFitSize.width = containerWidth;\n\t\t\t\t\tcontainerFitSize.height = containerHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[] = [], isAppend?: boolean) {\n\t\tconst style = this._style;\n\t\tconst { horizontal, aspectRatio, margin } = this.options;\n\t\tconst pos1Name = style.startPos1;\n\t\tconst containerWidth = this._size * (horizontal ? aspectRatio : 1);\n\t\tconst containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n\t\tconst containerSize1 = horizontal ? containerWidth : containerHeight;\n\t\tconst prevOutline = toZeroArray(outline);\n\t\tconst start = isAppend ? Math.max(...prevOutline) :\n\t\t\tMath.min(...prevOutline) - containerSize1 - margin;\n\t\tconst end = start + containerSize1 + margin;\n\t\tconst container = new BoxModel({});\n\n\t\titems.forEach(item => {\n\t\t\tconst { width, height } = item.orgSize!;\n\t\t\tconst model = new BoxModel({\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toriginWidth: width,\n\t\t\t\toriginHeight: height,\n\t\t\t});\n\n\t\t\tthis._findBestFitArea(container, model);\n\t\t\tcontainer.push(model);\n\t\t\tcontainer.scaleTo(containerWidth + margin, containerHeight + margin);\n\t\t});\n\t\titems.forEach((item, i) => {\n\t\t\tconst boxItem = container.items[i];\n\t\t\tconst width = boxItem.width;\n\t\t\tconst height = boxItem.height;\n\t\t\tconst top = boxItem.top;\n\t\t\tconst left = boxItem.left;\n\n\t\t\titem.rect = { top, left, width: width - margin, height: height - margin };\n\t\t\titem.rect[pos1Name] += start;\n\t\t});\n\n\t\treturn {\n\t\t\tstart: [start],\n\t\t\tend: [end],\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default PackingLayout;\n","/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nfunction single_source_shortest_paths(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\t// Predecessor map for each node that has been encountered.\n\t// node ID => predecessor node ID\n\tconst predecessors: { [key: string]: string } = {};\n\t// Costs of shortest paths from s to all nodes encountered.\n\t// node ID => cost\n\tconst costs: { [key: string]: number } = {};\n\tcosts[s] = 0;\n\n\t// Costs of shortest paths from s to all nodes encountered; differs from\n\t// `costs` in that it provides easy access to the node that currently has\n\t// the known shortest path from s.\n\t// XXX: Do we actually need both `costs` and `open`?\n\tconst open = new BinaryHeap<{ value: string, cost: number }>(x => x.cost);\n\topen.push({ value: s, cost: 0 });\n\n\tlet closest;\n\tlet u;\n\tlet cost_of_s_to_u;\n\tlet adjacent_nodes;\n\tlet cost_of_e;\n\tlet cost_of_s_to_u_plus_cost_of_e;\n\tlet cost_of_s_to_v;\n\tlet first_visit: boolean;\n\n\twhile (open.size()) {\n\t\t// In the nodes remaining in graph that have a known cost from s,\n\t\t// find the node, u, that currently has the shortest path from s.\n\t\tclosest = open.pop();\n\t\tu = closest.value;\n\t\tcost_of_s_to_u = closest.cost;\n\n\t\t// Get nodes adjacent to u...\n\t\tadjacent_nodes = graph(u) || {};\n\n\t\t// ...and explore the edges that connect u to those nodes, updating\n\t\t// the cost of the shortest paths to any or all of those nodes as\n\t\t// necessary. v is the node across the current edge from u.\n\t\tfor (const v in adjacent_nodes) {\n\t\t\t// Get the cost of the edge running from u to v.\n\t\t\tcost_of_e = adjacent_nodes[v];\n\n\t\t\t// Cost of s to u plus the cost of u to v across e--this is *a*\n\t\t\t// cost from s to v that may or may not be less than the current\n\t\t\t// known cost to v.\n\t\t\tcost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n\t\t\t// If we haven't visited v yet OR if the current known cost from s to\n\t\t\t// v is greater than the new cost we just found (cost of s to u plus\n\t\t\t// cost of u to v across e), update v's cost in the cost list and\n\t\t\t// update v's predecessor in the predecessor list (it's now u).\n\t\t\tcost_of_s_to_v = costs[v];\n\t\t\tfirst_visit = (typeof costs[v] === \"undefined\");\n\t\t\tif (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n\t\t\t\tcosts[v] = cost_of_s_to_u_plus_cost_of_e;\n\t\t\t\topen.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });\n\t\t\t\tpredecessors[v] = u;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof costs[d] === \"undefined\") {\n\t\tconst msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n\t\tthrow new Error(msg);\n\t}\n\n\treturn predecessors;\n}\nfunction extract_shortest_path_from_predecessor_list(\n\tpredecessors: { [key: string]: string },\n\td: string,\n) {\n\tconst nodes: string[] = [];\n\tlet u = d;\n\n\twhile (u) {\n\t\tnodes.push(u);\n\t\tu = predecessors[u];\n\t}\n\tnodes.reverse();\n\treturn nodes;\n}\nfunction find_path(\n\tgraph: (x: string) => ({ [key: string]: number }),\n\ts: string,\n\td: string,\n) {\n\tconst predecessors = single_source_shortest_paths(graph, s, d);\n\n\treturn extract_shortest_path_from_predecessor_list(predecessors, d);\n}\n\nclass BinaryHeap<T> {\n\tprivate content: T[];\n\tprivate scoreFunction: (x: T) => number;\n\n\tconstructor(scoreFunction: (x: T) => number) {\n\t\tthis.content = [];\n\t\tthis.scoreFunction = scoreFunction;\n\t}\n\tpublic push(element: T) {\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push(element);\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp(this.content.length - 1);\n\t}\n\tpublic pop() {\n\t\t// Store the first element so we can return it later.\n\t\tconst result = this.content[0];\n\t\t// Get the element at the end of the array.\n\t\tconst end = this.content.pop()!;\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif (this.content.length > 0) {\n\t\t\tthis.content[0] = end;\n\t\t\tthis.sinkDown(0);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic size() {\n\t\treturn this.content.length;\n\t}\n\tpublic bubbleUp(_n: number) {\n\t\tlet n = _n;\n\t\t// Fetch the element that has to be moved.\n\t\tconst element = this.content[n];\n\t\t// When at 0, an element can not go up any further.\n\t\twhile (n > 0) {\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tconst parentN = Math.floor((n + 1) / 2) - 1;\n\t\t\tconst parent = this.content[parentN];\n\n\t\t\t// Swap the elements if the parent is greater.\n\t\t\tif (this.scoreFunction(element) < this.scoreFunction(parent)) {\n\t\t\t\tthis.content[parentN] = element;\n\t\t\t\tthis.content[n] = parent;\n\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\tn = parentN;\n\t\t\t} else {\n\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic sinkDown(n: number) {\n\t\t// Look up the target element and its score.\n\t\tconst length = this.content.length;\n\t\tconst element = this.content[n];\n\t\tconst elemScore = this.scoreFunction(element);\n\t\tlet child1Score;\n\n\t\twhile (true) {\n\t\t\t// Compute the indices of the child elements.\n\t\t\tconst child2N = (n + 1) * 2;\n\t\t\tconst child1N = child2N - 1;\n\t\t\t// This is used to store the new position of the element,\n\t\t\t// if any.\n\t\t\tlet swap: number | null = null;\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif (child1N < length) {\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tconst child1 = this.content[child1N];\n\t\t\t\tchild1Score = this.scoreFunction(child1);\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif (child1Score < elemScore) {\n\t\t\t\t\tswap = child1N;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do the same checks for the other child.\n\t\t\tif (child2N < length) {\n\t\t\t\tconst child2 = this.content[child2N];\n\t\t\t\tconst child2Score = this.scoreFunction(child2);\n\n\t\t\t\tif (child2Score < (swap == null ? elemScore : child1Score)) {\n\t\t\t\t\tswap = child2N;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\tif (swap !== null) {\n\t\t\t\tthis.content[n] = this.content[swap];\n\t\t\t\tthis.content[swap] = element;\n\t\t\t\tn = swap;\n\t\t\t} else {\n\t\t\t\t// Otherwise, we are done.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { find_path };\n","import { find_path } from \"./lib/dijkstra\";\nimport { getStyleNames, assignOptions, cloneItems } from \"../utils\";\nimport { ILayout, IRectlProperties, SizeType, IInfiniteGridItem, IInfiniteGridGroup } from \"../types\";\n\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. 용어의 의미대로 너비가 주어진 사이즈를 기준으로 카드가 가득 차도록 배치하는 레이아웃이다.\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko> 아이템이 조정되는 최소 크기 </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko> 아이템이 조정되는 최대 크기 </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko> 한 줄에 들어가는 아이템의 개수 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n  horizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n  margin: 10,\n  minSize: 100,\n  maxSize: 300,\n  column: 5,\n  horizontal: true,\n});\n\n</script>\n```\n **/\nclass JustifiedLayout implements ILayout {\n\tpublic options: {\n\t\tmargin: number;\n\t\tminSize: number;\n\t\tmaxSize: number;\n\t\tcolumn: number | number[];\n\t\thorizontal: boolean;\n\t};\n\tprivate _style: IRectlProperties;\n\tprivate _size: number;\n\n\tconstructor(options: Partial<JustifiedLayout[\"options\"]> = {}) {\n\t\tthis.options = assignOptions({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\tminSize: 0,\n\t\t\tmaxSize: 0,\n\t\t\tcolumn: [1, 8],\n\t\t}, options);\n\n\t\tthis._style = getStyleNames(this.options.horizontal);\n\t\tthis._size = 0;\n\t}\n\t/**\n\t * Set the viewport size of the layout.\n\t * @ko 레이아웃의 가시 사이즈를 설정한다.\n\t * @method eg.InfiniteGrid.JustifiedLayout#setSize\n\t * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.setSize(800);\n\t */\n\tpublic setSize(size: number) {\n\t\tthis._size = size;\n\t\treturn this;\n\t}\n\t/**\n\t * Adds items at the bottom of a outline.\n\t * @ko 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.JustifiedLayout#append\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic append(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, true, cache);\n\t}\n\t/**\n\t * Adds items at the top of a outline.\n\t * @ko 아이템을 아웃라인 위에 추가한다.\n\t * @method eg.InfiniteGrid.JustifiedLayout#prepend\n\t * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n\t * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n\t * @example\n\t * layout.prepend(items, [100]);\n\t */\n\tpublic prepend(items: IInfiniteGridItem[], outline?: number[], cache?: boolean) {\n\t\treturn this._insert(items, outline, false, cache);\n\t}\n\t/**\n\t * Adds items of groups at the bottom of a outline.\n\t * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n\t * @method eg.InfiniteGrid.JustifiedLayout#layout\n\t * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n\t * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n\t * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * layout.layout(groups, [100]);\n\t */\n\tpublic layout(groups: IInfiniteGridGroup[] = [], outline: number[] = []) {\n\t\tconst length = groups.length;\n\t\tlet point = outline;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tconst group = groups[i];\n\t\t\tconst outlines = this._layout(group.items, point, true);\n\n\t\t\tgroup.outlines = outlines;\n\t\t\tpoint = outlines.end;\n\t\t}\n\t\treturn this;\n\t}\n\tprivate _layout(items: IInfiniteGridItem[], outline: number[], isAppend?: boolean) {\n\t\tconst style = this._style;\n\t\tconst size1Name = style.size1;\n\t\tconst size2Name = style.size2;\n\t\tconst startIndex = 0;\n\t\tconst endIndex = items.length;\n\t\tconst column = this.options.column;\n\t\tconst columns: number[] = (typeof column === \"object\") ? column : [column, column];\n\n\t\tconst graph = (_start: string) => {\n\t\t\tconst results: { [key: string]: number } = {};\n\t\t\tconst start = +_start.replace(/[^0-9]/g, \"\");\n\t\t\tconst length = endIndex + 1;\n\n\t\t\tfor (let i = Math.min(start + columns[0], length - 1); i < length; ++i) {\n\t\t\t\tif (i - start > columns[1]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet cost = this._getCost(items, start, i, size1Name, size2Name);\n\n\t\t\t\tif (cost === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cost < 0 && i === length - 1) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tresults[`${i}`] = Math.pow(cost, 2);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\t// shortest path for items' total height.\n\t\tconst path = find_path(graph, `${startIndex}`, `${endIndex}`);\n\n\t\treturn this._setStyle(items, path, outline, isAppend);\n\t}\n\tprivate _getSize(items: IInfiniteGridItem[], size1Name: SizeType, size2Name: SizeType) {\n\t\tconst margin = this.options.margin;\n\t\tconst size = items.reduce((sum, item) => sum +\n\t\t\t(item.orgSize![size2Name]) / item.orgSize![size1Name], 0);\n\n\t\treturn (this._size - margin * (items.length - 1)) / size;\n\t}\n\tprivate _getCost(\n\t\titems: IInfiniteGridItem[],\n\t\ti: number,\n\t\tj: number,\n\t\tsize1Name: SizeType,\n\t\tsize2Name: SizeType,\n\t) {\n\t\tconst size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\t\tconst min = this.options.minSize || 0;\n\t\tconst max = this.options.maxSize || Infinity;\n\n\t\tif (isFinite(max)) {\n\t\t\t// if this size is not in range, the cost increases sharply.\n\t\t\tif (size < min) {\n\t\t\t\treturn Math.pow(size - min, 2) + Math.pow(max, 2);\n\t\t\t} else if (size > max) {\n\t\t\t\treturn Math.pow(size - max, 2) + Math.pow(max, 2);\n\t\t\t} else {\n\t\t\t\t// if this size in range, the cost is negative or low.\n\t\t\t\treturn Math.min(size - max, min - size);\n\t\t\t}\n\t\t}\n\t\t// if max is infinite type, caculate cost only with \"min\".\n\t\tif (size < min) {\n\t\t\treturn Math.max(Math.pow(min, 2), Math.pow(size, 2));\n\t\t}\n\t\treturn size - min;\n\t}\n\tprivate _setStyle(\n\t\titems: IInfiniteGridItem[],\n\t\tpath: string[],\n\t\toutline: number[] = [],\n\t\tisAppend?: boolean,\n\t) {\n\t\tconst style = this._style;\n\t\t// if direction is vertical\n\t\t// startPos1 : top, endPos1 : bottom\n\t\t// size1 : height\n\t\t// startPos2 : left, endPos2 : right\n\t\t// size2 : width\n\n\t\t// if direction is horizontal\n\t\t// startPos1 : left, endPos1 : right\n\t\t// size1 : width\n\t\t// startPos2 : top, endPos2 : bottom\n\t\t// size2 : height\n\t\tconst pos1Name = style.startPos1;\n\t\tconst size1Name = style.size1;\n\t\tconst pos2Name = style.startPos2;\n\t\tconst size2Name = style.size2;\n\t\tconst length = path.length;\n\t\tconst margin = this.options.margin;\n\t\tconst startPoint = outline[0] || 0;\n\t\tlet endPoint = startPoint;\n\t\tlet height = 0;\n\n\t\tfor (let i = 0; i < length - 1; ++i) {\n\t\t\tconst path1 = parseInt(path[i], 10);\n\t\t\tconst path2 = parseInt(path[i + 1], 10);\n\t\t\t// pathItems(path1 to path2) are in 1 line.\n\t\t\tconst pathItems = items.slice(path1, path2);\n\t\t\tconst pathItemsLength = pathItems.length;\n\t\t\tconst size1 = this._getSize(pathItems, size1Name, size2Name);\n\t\t\tconst pos1 = endPoint;\n\n\t\t\tfor (let j = 0; j < pathItemsLength; ++j) {\n\t\t\t\tconst item = pathItems[j];\n\t\t\t\tconst size2 = item.orgSize![size2Name] / item.orgSize![size1Name] * size1;\n\t\t\t\t// item has margin bottom and right.\n\t\t\t\t// first item has not margin.\n\t\t\t\tconst prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n\t\t\t\tconst pos2 = (prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name]! + margin : 0);\n\n\t\t\t\titem.rect = {\n\t\t\t\t\t[pos1Name]: pos1,\n\t\t\t\t\t[pos2Name]: pos2,\n\t\t\t\t\t[size1Name]: size1,\n\t\t\t\t\t[size2Name]: size2,\n\t\t\t\t} as any;\n\t\t\t}\n\t\t\theight += margin + size1;\n\t\t\tendPoint = startPoint + height;\n\t\t}\n\t\tconst itemsLength = items.length;\n\n\t\tif (isAppend) {\n\t\t\t// previous group's end outline is current group's start outline\n\t\t\treturn {\n\t\t\t\tstart: [startPoint],\n\t\t\t\tend: [endPoint],\n\t\t\t};\n\t\t}\n\t\t// for prepend, only substract height from position.\n\t\t// always start is lower than end.\n\n\t\tfor (let i = 0; i < itemsLength; ++i) {\n\t\t\tconst item = items[i];\n\n\t\t\t// move items as long as height for prepend\n\t\t\titem.rect[pos1Name] -= height;\n\t\t}\n\t\treturn {\n\t\t\tstart: [startPoint - height],\n\t\t\tend: [startPoint], // endPoint - height = startPoint\n\t\t};\n\t}\n\tprivate _insert(items: IInfiniteGridItem[] = [], outline: number[] = [], isAppend?: boolean, cache?: boolean) {\n\t\t// this only needs the size of the item.\n\t\tconst clone = cache ? items : cloneItems(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, isAppend),\n\t\t};\n\t}\n}\n\nexport default JustifiedLayout;\n","/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport GridLayout from \"./layouts/GridLayout\";\nimport FrameLayout from \"./layouts/FrameLayout\";\nimport SquareLayout from \"./layouts/SquareLayout\";\nimport PackingLayout from \"./layouts/PackingLayout\";\nimport JustifiedLayout from \"./layouts/JustifiedLayout\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport ItemManager from \"./ItemManager\";\nimport Infinite from \"./Infinite\";\nexport {\n\tCONTAINER_CLASSNAME, IGNORE_CLASSNAME,\n\tDEFAULT_OPTIONS, INFINITEGRID_METHODS,\n\tINFINITEGRID_EVENTS,\n} from \"./consts\";\nexport { categorize, withInfiniteGridMethods } from \"./utils\";\n\nexport * from \"./types\";\nexport {\n\tGridLayout,\n\tFrameLayout,\n\tSquareLayout,\n\tPackingLayout,\n\tJustifiedLayout,\n\tInfinite,\n\tDOMRenderer,\n\tItemManager,\n\tInfiniteGrid as default,\n};\n"]},"metadata":{},"sourceType":"module"}