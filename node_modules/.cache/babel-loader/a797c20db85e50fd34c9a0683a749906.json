{"ast":null,"code":"import React from 'react';\nconst __reactCreateElement__ = React.createElement;\nconst {\n  useCallback,\n  useEffect,\n  useState,\n  useRef\n} = React;\nimport ResizeObserver from 'resize-observer-polyfill';\nimport trieMemoize from 'trie-memoize';\nimport OneKeyMap from '@essentials/one-key-map';\nimport memoizeOne from '@essentials/memoize-one';\nimport useLayoutEffect from '@react-hook/passive-layout-effect';\nimport useScrollPosition from '@react-hook/window-scroll';\nimport { useWindowSize } from '@react-hook/window-size';\nimport { requestTimeout, clearRequestTimeout } from '@essentials/request-timeout';\nimport createIntervalTree from './IntervalTree';\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n */\n\nexport const useMasonry = ({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = 'div',\n  id,\n  className,\n  style,\n  role = 'grid',\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = 'div',\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender\n}) => {\n  let startIndex = 0;\n  let stopIndex = void 0;\n  const forceUpdate = useForceUpdate();\n  const setItemRef = getRefSetter(positioner, resizeObserver);\n  const itemCount = items.length;\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn\n  } = positioner;\n  const measuredCount = size();\n  const shortestColumnSize = shortestColumn();\n  const children = [];\n  const itemRole = role + 'item';\n  overscanBy = height * overscanBy;\n  const rangeEnd = scrollTop + overscanBy;\n  const needsFreshBatch = shortestColumnSize < rangeEnd && measuredCount < itemCount;\n  range( // We overscan in both directions because users scroll both ways,\n  // though one must admit scrolling down is more common and thus\n  // we only overscan by half the downward overscan amount\n  Math.max(0, scrollTop - overscanBy / 2), rangeEnd, (index, left, top) => {\n    const data = items[index];\n    const key = itemKey(data, index);\n    const phaseTwoStyle = {\n      top,\n      left,\n      width: columnWidth,\n      writingMode: 'horizontal-tb',\n      position: 'absolute'\n    };\n    children.push( /*#__PURE__*/__reactCreateElement__(ItemComponent, {\n      key: key,\n      ref: setItemRef(index),\n      role: itemRole,\n      style: typeof itemStyle === 'object' && itemStyle !== null ? Object.assign(phaseTwoStyle, itemStyle) : phaseTwoStyle\n    }, createRenderElement(RenderComponent, index, data, columnWidth)));\n\n    if (stopIndex === void 0) {\n      startIndex = index;\n      stopIndex = index;\n    } else {\n      startIndex = Math.min(startIndex, index);\n      stopIndex = Math.max(stopIndex, index);\n    }\n  });\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(itemCount - measuredCount, Math.ceil((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate * columnCount));\n    let index = measuredCount;\n    const phaseOneStyle = getCachedSize(columnWidth);\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index];\n      const key = itemKey(data, index);\n      children.push( /*#__PURE__*/__reactCreateElement__(ItemComponent, {\n        key: key,\n        ref: setItemRef(index),\n        role: itemRole,\n        style: typeof itemStyle === 'object' ? Object.assign(phaseOneStyle, itemStyle) : phaseOneStyle\n      }, createRenderElement(RenderComponent, index, data, columnWidth)));\n    }\n  } // Calls the onRender callback if the rendered indices changed\n\n\n  useEffect(() => {\n    if (typeof onRender === 'function' && stopIndex !== void 0) onRender(startIndex, stopIndex, items);\n    didEverMount = '1';\n  }, [startIndex, stopIndex, items, onRender]); // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n\n  useEffect(() => {\n    if (needsFreshBatch) forceUpdate(); // eslint-disable-next-line\n  }, [needsFreshBatch]); // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n\n  const containerStyle = getContainerStyle(isScrolling, estimateHeight(itemCount, itemHeightEstimate));\n  return /*#__PURE__*/__reactCreateElement__(ContainerComponent, {\n    ref: containerRef,\n    key: didEverMount,\n    id: id,\n    role: role,\n    className: className,\n    tabIndex: tabIndex,\n    style: typeof style === 'object' ? assignUserStyle(containerStyle, style) : containerStyle,\n    children: children\n  });\n}; // This is for triggering a remount after SSR has loaded in the client w/ hydrate()\n\nlet didEverMount = '0'; //\n// Render-phase utilities\n// ~5.5x faster than createElement without the memo\n\nconst createRenderElement = /*#__PURE__*/trieMemoize([OneKeyMap, {}, WeakMap, OneKeyMap], (RenderComponent, index, data, columnWidth) => /*#__PURE__*/__reactCreateElement__(RenderComponent, {\n  index: index,\n  data: data,\n  width: columnWidth\n}));\n\nconst getColumns = (width = 0, minimumWidth = 0, gutter = 8, columnCount) => {\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1;\n  const columnWidth = Math.floor((width - gutter * (columnCount - 1)) / columnCount);\n  return [columnWidth, columnCount];\n};\n\nconst getContainerStyle = /*#__PURE__*/memoizeOne((isScrolling, estimateHeight) => ({\n  position: 'relative',\n  width: '100%',\n  maxWidth: '100%',\n  height: Math.ceil(estimateHeight),\n  maxHeight: Math.ceil(estimateHeight),\n  willChange: isScrolling ? 'contents' : void 0,\n  pointerEvents: isScrolling ? 'none' : void 0\n}));\n\nconst cmp2 = (args, pargs) => args[0] === pargs[0] && args[1] === pargs[1];\n\nconst assignUserStyle = /*#__PURE__*/memoizeOne((containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle), cmp2);\n\nconst defaultGetItemKey = (_, i) => i; // the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\n\n\nconst getCachedSize = /*#__PURE__*/memoizeOne(width => ({\n  width,\n  zIndex: -1000,\n  visibility: 'hidden',\n  position: 'absolute',\n  writingMode: 'horizontal-tb'\n}), (args, pargs) => args[0] === pargs[0]);\nconst elementsCache = /*#__PURE__*/new WeakMap();\nconst getRefSetter = /*#__PURE__*/memoizeOne((positioner, resizeObserver) => index => el => {\n  if (el === null) return;\n\n  if (resizeObserver) {\n    resizeObserver.observe(el);\n    elementsCache.set(el, index);\n  }\n\n  if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight);\n}, cmp2); //\n// Components\n\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n */\n\nexport const MasonryScroller = props => {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const {\n    scrollTop,\n    isScrolling\n  } = useScroller(props.offset, props.scrollFps); // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n\n  return useMasonry({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render\n  });\n};\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n */\n\nexport const Masonry = /*#__PURE__*/React.memo(props => {\n  const containerRef = useRef(null);\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight\n  });\n  const containerPos = useContainerPosition(containerRef, windowSize);\n  const nextProps = Object.assign({\n    offset: containerPos.offset,\n    width: containerPos.width || windowSize[0],\n    height: windowSize[1],\n    containerRef\n  }, props);\n  nextProps.positioner = usePositioner(nextProps);\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner);\n  return __reactCreateElement__(MasonryScroller, nextProps);\n});\n/**\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\n * a `columnGutter` prop.\n */\n\nexport const List = props => __reactCreateElement__(Masonry, Object.assign({\n  role: 'list'\n}, props, {\n  columnGutter: props.rowGutter,\n  columnCount: 1,\n  columnWidth: 1\n}));\nconst emptyObj = {};\nconst emptyArr = []; //\n// Hooks\n\nconst useForceUpdate = () => {\n  const setState = useState(emptyObj)[1];\n  return useRef(() => setState({})).current;\n};\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\n\n\nexport const useScroller = (offset = 0, fps = 12) => {\n  const scrollTop = useScrollPosition(fps);\n\n  const _ref_0 = useState(false);\n\n  const setIsScrolling = _ref_0[1];\n  const isScrolling = _ref_0[0];\n  const didMount = useRef('0');\n\n  function _ref() {\n    // This is here to prevent premature bail outs while maintaining high resolution\n    // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n    setIsScrolling(false);\n  }\n\n  useEffect(() => {\n    if (didMount.current === '1') setIsScrolling(true);\n    const to = requestTimeout(_ref, 40 + 1000 / fps);\n    didMount.current = '1';\n    return () => clearRequestTimeout(to);\n  }, [fps, scrollTop]);\n  return {\n    scrollTop: Math.max(0, scrollTop - offset),\n    isScrolling\n  };\n};\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\n\nexport const useContainerPosition = (elementRef, deps = emptyArr) => {\n  const _ref_1 = useState({\n    offset: 0,\n    width: 0\n  });\n\n  const setContainerPosition = _ref_1[1];\n  const containerPosition = _ref_1[0];\n  useLayoutEffect(() => {\n    const {\n      current\n    } = elementRef;\n\n    if (current !== null) {\n      let offset = 0;\n      let el = current;\n\n      do {\n        offset += el.offsetTop || 0;\n        el = el.offsetParent;\n      } while (el);\n\n      if (offset !== containerPosition.offset || current.offsetWidth !== containerPosition.width) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth\n        });\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n  return containerPosition;\n};\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n */\n\nexport const usePositioner = ({\n  width,\n  columnWidth = 200,\n  columnGutter = 0,\n  columnCount\n}, deps = emptyArr) => {\n  const initPositioner = () => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(width, columnWidth, columnGutter, columnCount);\n    return createPositioner(computedColumnCount, computedColumnWidth, columnGutter);\n  };\n\n  const _ref_2 = useState(initPositioner);\n\n  const setPositioner = _ref_2[1];\n  const positioner = _ref_2[0];\n  const didMount = useRef(0); // Create a new positioner when the dependencies change\n\n  useEffect(() => {\n    if (didMount.current) setPositioner(initPositioner());\n    didMount.current = 1; // eslint-disable-next-line\n  }, deps); // Updates the item positions any time a prop potentially affecting their\n  // size changes\n\n  useLayoutEffect(() => {\n    if (didMount.current) {\n      const cacheSize = positioner.size();\n      const nextPositioner = initPositioner();\n      let index = 0;\n\n      for (; index < cacheSize; index++) {\n        const pos = positioner.get(index);\n        nextPositioner.set(index, pos !== void 0 ? pos.height : 0);\n      }\n\n      setPositioner(nextPositioner);\n    } // eslint-disable-next-line\n\n  }, [width, columnWidth, columnGutter, columnCount]);\n  return positioner;\n};\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\n\nexport const useResizeObserver = positioner => {\n  const forceUpdate = useForceUpdate();\n  const resizeObserver = createResizeObserver(positioner, forceUpdate); // Cleans up the resize observers when they change or the\n  // component unmounts\n\n  function _ref2() {\n    return resizeObserver.disconnect();\n  }\n\n  useEffect(() => _ref2, [resizeObserver]);\n  return resizeObserver;\n};\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\n\nexport const createResizeObserver = /*#__PURE__*/trieMemoize([WeakMap], // TODO: figure out a way to test this\n\n/* istanbul ignore next */\n(positioner, updater) => new ResizeObserver(entries => {\n  const updates = [];\n  let i = 0;\n\n  for (; i < entries.length; i++) {\n    const entry = entries[i]; // There are native resize observers that still don't have\n    // the borderBoxSize property. For those we fallback to the\n    // offset height of the target element.\n\n    const height = entry.borderBoxSize !== void 0 ? entry.borderBoxSize.blockSize : entry.target.offsetHeight;\n\n    if (height > 0) {\n      const index = elementsCache.get(entry.target);\n\n      if (index !== void 0) {\n        const position = positioner.get(index);\n        if (position !== void 0 && height !== position.height) updates.push(index, height);\n      }\n    }\n  }\n\n  if (updates.length > 0) {\n    // Updates the size/positions of the cell with the resize\n    // observer updates\n    positioner.update(updates);\n    updater(updates);\n  }\n}));\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\n\nexport function useInfiniteLoader(loadMoreItems, options = emptyObj) {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9\n  } = options;\n  return useCallback((startIndex, stopIndex, items) => {\n    const unloadedRanges = scanForUnloadedRanges(isItemLoaded, minimumBatchSize, items, totalItems, Math.max(0, startIndex - threshold), Math.min(totalItems - 1, stopIndex + threshold)); // The user is responsible for memoizing their loadMoreItems() function\n    // because we don't want to make assumptions about how they want to deal\n    // with `items`\n\n    for (let i = 0; i < unloadedRanges.length - 1; ++i) loadMoreItems(unloadedRanges[i], unloadedRanges[++i], items);\n  }, [loadMoreItems, totalItems, minimumBatchSize, threshold, isItemLoaded]);\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nconst scanForUnloadedRanges = (isItemLoaded = defaultIsItemLoaded, minimumBatchSize = 16, items, totalItems = 9e9, startIndex, stopIndex) => {\n  const unloadedRanges = [];\n  let rangeStartIndex,\n      rangeStopIndex,\n      index = startIndex;\n\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === void 0) rangeStartIndex = index;\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = void 0;\n    }\n  } // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), totalItems - 1);\n\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n  /* istanbul ignore next */\n\n\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0];\n    const firstUnloadedStop = unloadedRanges[1];\n\n    while (firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize && firstUnloadedStart > 0) {\n      const index = firstUnloadedStart - 1;\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n};\n\nconst defaultIsItemLoaded = (index, items) => items[index] !== void 0; //\n// Utilities\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount The number of columns in the grid\n * @param columnWidth The width of each column in the grid\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\n *  between each grid item.\n */\n\n\nexport const createPositioner = (columnCount, columnWidth, columnGutter = 0) => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree(); // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n\n  const columnHeights = new Array(columnCount); // Used for O(1) item access\n\n  const items = []; // Tracks the item indexes within an individual column\n\n  const columnItems = new Array(columnCount);\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0;\n    columnItems[i] = [];\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0; // finds the shortest column and uses it\n\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i;\n      }\n\n      const top = columnHeights[column] || 0;\n      columnHeights[column] = top + height + columnGutter;\n      columnItems[column].push(index);\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column\n      };\n      intervalTree.insert(top, top + height, index);\n    },\n    get: index => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: updates => {\n      const columns = new Array(columnCount);\n      let i = 0,\n          j = 0; // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i];\n        const item = items[index];\n        item.height = updates[++i];\n        intervalTree.remove(index);\n        intervalTree.insert(item.top, item.top + item.height, index);\n        columns[item.column] = columns[item.column] === void 0 ? index : Math.min(index, columns[item.column]);\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue;\n        const itemsInColumn = columnItems[i]; // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n\n        const startIndex = binarySearch(itemsInColumn, columns[i]);\n        const index = columnItems[i][startIndex];\n        const startItem = items[index];\n        columnHeights[i] = startItem.top + startItem.height + columnGutter;\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j];\n          const item = items[index];\n          item.top = columnHeights[i];\n          columnHeights[i] = item.top + item.height + columnGutter;\n          intervalTree.remove(index);\n          intervalTree.insert(item.top, item.top + item.height, index);\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) => intervalTree.search(lo, hi, (index, top) => renderCallback(index, items[index].left, top)),\n    estimateHeight: (itemCount, defaultItemHeight) => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights));\n      return itemCount === intervalTree.size ? tallestColumn : tallestColumn + Math.ceil((itemCount - intervalTree.size) / columnCount) * defaultItemHeight;\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights);\n      return columnHeights[0] || 0;\n    },\n\n    size() {\n      return intervalTree.size;\n    }\n\n  };\n};\n/* istanbul ignore next */\n\nconst binarySearch = (a, y) => {\n  let l = 0;\n  let h = a.length - 1;\n\n  while (l <= h) {\n    const m = l + h >>> 1;\n    const x = a[m];\n    if (x === y) return m;else if (x <= y) l = m + 1;else h = m - 1;\n  }\n\n  return -1;\n};\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  Masonry.displayName = 'Masonry';\n  MasonryScroller.displayName = 'MasonryScroller';\n  List.displayName = 'List';\n}","map":{"version":3,"sources":["C:/Users/Work/Desktop/Wild Code School/Projects/art-gallery-react-project2/bucharest-project2-art-gallery/node_modules/masonic/dist/module/index.js"],"names":["React","__reactCreateElement__","createElement","useCallback","useEffect","useState","useRef","ResizeObserver","trieMemoize","OneKeyMap","memoizeOne","useLayoutEffect","useScrollPosition","useWindowSize","requestTimeout","clearRequestTimeout","createIntervalTree","useMasonry","positioner","resizeObserver","items","as","ContainerComponent","id","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","scrollTop","isScrolling","height","render","RenderComponent","onRender","startIndex","stopIndex","forceUpdate","useForceUpdate","setItemRef","getRefSetter","itemCount","length","columnWidth","columnCount","range","estimateHeight","size","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","rangeEnd","needsFreshBatch","Math","max","index","left","top","data","key","phaseTwoStyle","width","writingMode","position","push","ref","Object","assign","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","WeakMap","getColumns","minimumWidth","gutter","floor","maxWidth","maxHeight","willChange","pointerEvents","cmp2","args","pargs","userStyle","_","i","zIndex","visibility","elementsCache","el","observe","set","get","offsetHeight","MasonryScroller","props","useScroller","offset","scrollFps","Masonry","memo","windowSize","initialWidth","ssrWidth","initialHeight","ssrHeight","containerPos","useContainerPosition","nextProps","usePositioner","useResizeObserver","List","columnGutter","rowGutter","emptyObj","emptyArr","setState","current","fps","_ref_0","setIsScrolling","didMount","_ref","to","elementRef","deps","_ref_1","setContainerPosition","containerPosition","offsetTop","offsetParent","offsetWidth","initPositioner","computedColumnWidth","computedColumnCount","createPositioner","_ref_2","setPositioner","cacheSize","nextPositioner","pos","createResizeObserver","_ref2","disconnect","updater","entries","updates","entry","borderBoxSize","blockSize","target","update","useInfiniteLoader","loadMoreItems","options","isItemLoaded","minimumBatchSize","threshold","totalItems","unloadedRanges","scanForUnloadedRanges","defaultIsItemLoaded","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","intervalTree","columnHeights","Array","columnItems","column","insert","columns","j","item","remove","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","search","defaultItemHeight","tallestColumn","apply","a","y","l","h","m","x","process","env","NODE_ENV","displayName"],"mappings":"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","sourcesContent":["import React from 'react'\nconst __reactCreateElement__ = React.createElement\nconst {useCallback, useEffect, useState, useRef} = React\nimport ResizeObserver from 'resize-observer-polyfill'\nimport trieMemoize from 'trie-memoize'\nimport OneKeyMap from '@essentials/one-key-map'\nimport memoizeOne from '@essentials/memoize-one'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useScrollPosition from '@react-hook/window-scroll'\nimport {useWindowSize} from '@react-hook/window-size'\nimport {requestTimeout, clearRequestTimeout} from '@essentials/request-timeout'\nimport createIntervalTree from './IntervalTree'\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n */\n\nexport const useMasonry = ({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = 'div',\n  id,\n  className,\n  style,\n  role = 'grid',\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = 'div',\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender,\n}) => {\n  let startIndex = 0\n  let stopIndex = void 0\n  const forceUpdate = useForceUpdate()\n  const setItemRef = getRefSetter(positioner, resizeObserver)\n  const itemCount = items.length\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn,\n  } = positioner\n  const measuredCount = size()\n  const shortestColumnSize = shortestColumn()\n  const children = []\n  const itemRole = role + 'item'\n  overscanBy = height * overscanBy\n  const rangeEnd = scrollTop + overscanBy\n  const needsFreshBatch =\n    shortestColumnSize < rangeEnd && measuredCount < itemCount\n  range(\n    // We overscan in both directions because users scroll both ways,\n    // though one must admit scrolling down is more common and thus\n    // we only overscan by half the downward overscan amount\n    Math.max(0, scrollTop - overscanBy / 2),\n    rangeEnd,\n    (index, left, top) => {\n      const data = items[index]\n      const key = itemKey(data, index)\n      const phaseTwoStyle = {\n        top,\n        left,\n        width: columnWidth,\n        writingMode: 'horizontal-tb',\n        position: 'absolute',\n      }\n      children.push(\n        /*#__PURE__*/ __reactCreateElement__(\n          ItemComponent,\n          {\n            key: key,\n            ref: setItemRef(index),\n            role: itemRole,\n            style:\n              typeof itemStyle === 'object' && itemStyle !== null\n                ? Object.assign(phaseTwoStyle, itemStyle)\n                : phaseTwoStyle,\n          },\n          createRenderElement(RenderComponent, index, data, columnWidth)\n        )\n      )\n\n      if (stopIndex === void 0) {\n        startIndex = index\n        stopIndex = index\n      } else {\n        startIndex = Math.min(startIndex, index)\n        stopIndex = Math.max(stopIndex, index)\n      }\n    }\n  )\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(\n      itemCount - measuredCount,\n      Math.ceil(\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\n          columnCount\n      )\n    )\n    let index = measuredCount\n    const phaseOneStyle = getCachedSize(columnWidth)\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index]\n      const key = itemKey(data, index)\n      children.push(\n        /*#__PURE__*/ __reactCreateElement__(\n          ItemComponent,\n          {\n            key: key,\n            ref: setItemRef(index),\n            role: itemRole,\n            style:\n              typeof itemStyle === 'object'\n                ? Object.assign(phaseOneStyle, itemStyle)\n                : phaseOneStyle,\n          },\n          createRenderElement(RenderComponent, index, data, columnWidth)\n        )\n      )\n    }\n  } // Calls the onRender callback if the rendered indices changed\n\n  useEffect(() => {\n    if (typeof onRender === 'function' && stopIndex !== void 0)\n      onRender(startIndex, stopIndex, items)\n    didEverMount = '1'\n  }, [startIndex, stopIndex, items, onRender]) // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n\n  useEffect(() => {\n    if (needsFreshBatch) forceUpdate() // eslint-disable-next-line\n  }, [needsFreshBatch]) // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n\n  const containerStyle = getContainerStyle(\n    isScrolling,\n    estimateHeight(itemCount, itemHeightEstimate)\n  )\n  return /*#__PURE__*/ __reactCreateElement__(ContainerComponent, {\n    ref: containerRef,\n    key: didEverMount,\n    id: id,\n    role: role,\n    className: className,\n    tabIndex: tabIndex,\n    style:\n      typeof style === 'object'\n        ? assignUserStyle(containerStyle, style)\n        : containerStyle,\n    children: children,\n  })\n} // This is for triggering a remount after SSR has loaded in the client w/ hydrate()\n\nlet didEverMount = '0'\n//\n// Render-phase utilities\n// ~5.5x faster than createElement without the memo\nconst createRenderElement = /*#__PURE__*/ trieMemoize(\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\n  (RenderComponent, index, data, columnWidth) =>\n    /*#__PURE__*/ __reactCreateElement__(RenderComponent, {\n      index: index,\n      data: data,\n      width: columnWidth,\n    })\n)\n\nconst getColumns = (width = 0, minimumWidth = 0, gutter = 8, columnCount) => {\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1\n  const columnWidth = Math.floor(\n    (width - gutter * (columnCount - 1)) / columnCount\n  )\n  return [columnWidth, columnCount]\n}\n\nconst getContainerStyle = /*#__PURE__*/ memoizeOne(\n  (isScrolling, estimateHeight) => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    height: Math.ceil(estimateHeight),\n    maxHeight: Math.ceil(estimateHeight),\n    willChange: isScrolling ? 'contents' : void 0,\n    pointerEvents: isScrolling ? 'none' : void 0,\n  })\n)\n\nconst cmp2 = (args, pargs) => args[0] === pargs[0] && args[1] === pargs[1]\n\nconst assignUserStyle = /*#__PURE__*/ memoizeOne(\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\n  cmp2\n)\n\nconst defaultGetItemKey = (_, i) => i // the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\n\nconst getCachedSize = /*#__PURE__*/ memoizeOne(\n  (width) => ({\n    width,\n    zIndex: -1000,\n    visibility: 'hidden',\n    position: 'absolute',\n    writingMode: 'horizontal-tb',\n  }),\n  (args, pargs) => args[0] === pargs[0]\n)\nconst elementsCache = /*#__PURE__*/ new WeakMap()\nconst getRefSetter = /*#__PURE__*/ memoizeOne(\n  (positioner, resizeObserver) => (index) => (el) => {\n    if (el === null) return\n\n    if (resizeObserver) {\n      resizeObserver.observe(el)\n      elementsCache.set(el, index)\n    }\n\n    if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight)\n  },\n  cmp2\n) //\n// Components\n\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n */\n\nexport const MasonryScroller = (props) => {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const {scrollTop, isScrolling} = useScroller(props.offset, props.scrollFps) // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n\n  return useMasonry({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render,\n  })\n}\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n */\n\nexport const Masonry = /*#__PURE__*/ React.memo((props) => {\n  const containerRef = useRef(null)\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight,\n  })\n  const containerPos = useContainerPosition(containerRef, windowSize)\n  const nextProps = Object.assign(\n    {\n      offset: containerPos.offset,\n      width: containerPos.width || windowSize[0],\n      height: windowSize[1],\n      containerRef,\n    },\n    props\n  )\n  nextProps.positioner = usePositioner(nextProps)\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner)\n  return __reactCreateElement__(MasonryScroller, nextProps)\n})\n\n/**\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\n * a `columnGutter` prop.\n */\nexport const List = (props) =>\n  __reactCreateElement__(\n    Masonry,\n    Object.assign(\n      {\n        role: 'list',\n      },\n      props,\n      {\n        columnGutter: props.rowGutter,\n        columnCount: 1,\n        columnWidth: 1,\n      }\n    )\n  )\nconst emptyObj = {}\nconst emptyArr = [] //\n// Hooks\n\nconst useForceUpdate = () => {\n  const setState = useState(emptyObj)[1]\n  return useRef(() => setState({})).current\n}\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\n\nexport const useScroller = (offset = 0, fps = 12) => {\n  const scrollTop = useScrollPosition(fps)\n\n  const _ref_0 = useState(false)\n\n  const setIsScrolling = _ref_0[1]\n  const isScrolling = _ref_0[0]\n  const didMount = useRef('0')\n\n  function _ref() {\n    // This is here to prevent premature bail outs while maintaining high resolution\n    // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n    setIsScrolling(false)\n  }\n\n  useEffect(() => {\n    if (didMount.current === '1') setIsScrolling(true)\n    const to = requestTimeout(_ref, 40 + 1000 / fps)\n    didMount.current = '1'\n    return () => clearRequestTimeout(to)\n  }, [fps, scrollTop])\n  return {\n    scrollTop: Math.max(0, scrollTop - offset),\n    isScrolling,\n  }\n}\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\n\nexport const useContainerPosition = (elementRef, deps = emptyArr) => {\n  const _ref_1 = useState({\n    offset: 0,\n    width: 0,\n  })\n\n  const setContainerPosition = _ref_1[1]\n  const containerPosition = _ref_1[0]\n  useLayoutEffect(() => {\n    const {current} = elementRef\n\n    if (current !== null) {\n      let offset = 0\n      let el = current\n\n      do {\n        offset += el.offsetTop || 0\n        el = el.offsetParent\n      } while (el)\n\n      if (\n        offset !== containerPosition.offset ||\n        current.offsetWidth !== containerPosition.width\n      ) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth,\n        })\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n  return containerPosition\n}\n\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n */\nexport const usePositioner = (\n  {width, columnWidth = 200, columnGutter = 0, columnCount},\n  deps = emptyArr\n) => {\n  const initPositioner = () => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(\n      width,\n      columnWidth,\n      columnGutter,\n      columnCount\n    )\n    return createPositioner(\n      computedColumnCount,\n      computedColumnWidth,\n      columnGutter\n    )\n  }\n\n  const _ref_2 = useState(initPositioner)\n\n  const setPositioner = _ref_2[1]\n  const positioner = _ref_2[0]\n  const didMount = useRef(0) // Create a new positioner when the dependencies change\n\n  useEffect(() => {\n    if (didMount.current) setPositioner(initPositioner())\n    didMount.current = 1 // eslint-disable-next-line\n  }, deps) // Updates the item positions any time a prop potentially affecting their\n  // size changes\n\n  useLayoutEffect(() => {\n    if (didMount.current) {\n      const cacheSize = positioner.size()\n      const nextPositioner = initPositioner()\n      let index = 0\n\n      for (; index < cacheSize; index++) {\n        const pos = positioner.get(index)\n        nextPositioner.set(index, pos !== void 0 ? pos.height : 0)\n      }\n\n      setPositioner(nextPositioner)\n    } // eslint-disable-next-line\n  }, [width, columnWidth, columnGutter, columnCount])\n  return positioner\n}\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport const useResizeObserver = (positioner) => {\n  const forceUpdate = useForceUpdate()\n  const resizeObserver = createResizeObserver(positioner, forceUpdate) // Cleans up the resize observers when they change or the\n  // component unmounts\n\n  function _ref2() {\n    return resizeObserver.disconnect()\n  }\n\n  useEffect(() => _ref2, [resizeObserver])\n  return resizeObserver\n}\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\n\nexport const createResizeObserver = /*#__PURE__*/ trieMemoize(\n  [WeakMap], // TODO: figure out a way to test this\n\n  /* istanbul ignore next */\n  (positioner, updater) =>\n    new ResizeObserver((entries) => {\n      const updates = []\n      let i = 0\n\n      for (; i < entries.length; i++) {\n        const entry = entries[i] // There are native resize observers that still don't have\n        // the borderBoxSize property. For those we fallback to the\n        // offset height of the target element.\n\n        const height =\n          entry.borderBoxSize !== void 0\n            ? entry.borderBoxSize.blockSize\n            : entry.target.offsetHeight\n\n        if (height > 0) {\n          const index = elementsCache.get(entry.target)\n\n          if (index !== void 0) {\n            const position = positioner.get(index)\n            if (position !== void 0 && height !== position.height)\n              updates.push(index, height)\n          }\n        }\n      }\n\n      if (updates.length > 0) {\n        // Updates the size/positions of the cell with the resize\n        // observer updates\n        positioner.update(updates)\n        updater(updates)\n      }\n    })\n)\n\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\nexport function useInfiniteLoader(loadMoreItems, options = emptyObj) {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9,\n  } = options\n  return useCallback(\n    (startIndex, stopIndex, items) => {\n      const unloadedRanges = scanForUnloadedRanges(\n        isItemLoaded,\n        minimumBatchSize,\n        items,\n        totalItems,\n        Math.max(0, startIndex - threshold),\n        Math.min(totalItems - 1, stopIndex + threshold)\n      ) // The user is responsible for memoizing their loadMoreItems() function\n      // because we don't want to make assumptions about how they want to deal\n      // with `items`\n\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\n        loadMoreItems(unloadedRanges[i], unloadedRanges[++i], items)\n    },\n    [loadMoreItems, totalItems, minimumBatchSize, threshold, isItemLoaded]\n  )\n}\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\n\nconst scanForUnloadedRanges = (\n  isItemLoaded = defaultIsItemLoaded,\n  minimumBatchSize = 16,\n  items,\n  totalItems = 9e9,\n  startIndex,\n  stopIndex\n) => {\n  const unloadedRanges = []\n  let rangeStartIndex,\n    rangeStopIndex,\n    index = startIndex\n\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index\n      if (rangeStartIndex === void 0) rangeStartIndex = index\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n      rangeStartIndex = rangeStopIndex = void 0\n    }\n  } // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      totalItems - 1\n    )\n\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index\n      } else {\n        break\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n  } // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n\n  /* istanbul ignore next */\n\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0]\n    const firstUnloadedStop = unloadedRanges[1]\n\n    while (\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\n      firstUnloadedStart > 0\n    ) {\n      const index = firstUnloadedStart - 1\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index\n      } else {\n        break\n      }\n    }\n  }\n\n  return unloadedRanges\n}\n\nconst defaultIsItemLoaded = (index, items) => items[index] !== void 0\n\n//\n// Utilities\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount The number of columns in the grid\n * @param columnWidth The width of each column in the grid\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\n *  between each grid item.\n */\nexport const createPositioner = (\n  columnCount,\n  columnWidth,\n  columnGutter = 0\n) => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree() // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n\n  const columnHeights = new Array(columnCount) // Used for O(1) item access\n\n  const items = [] // Tracks the item indexes within an individual column\n\n  const columnItems = new Array(columnCount)\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0\n    columnItems[i] = []\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0 // finds the shortest column and uses it\n\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i\n      }\n\n      const top = columnHeights[column] || 0\n      columnHeights[column] = top + height + columnGutter\n      columnItems[column].push(index)\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column,\n      }\n      intervalTree.insert(top, top + height, index)\n    },\n    get: (index) => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: (updates) => {\n      const columns = new Array(columnCount)\n      let i = 0,\n        j = 0 // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i]\n        const item = items[index]\n        item.height = updates[++i]\n        intervalTree.remove(index)\n        intervalTree.insert(item.top, item.top + item.height, index)\n        columns[item.column] =\n          columns[item.column] === void 0\n            ? index\n            : Math.min(index, columns[item.column])\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue\n        const itemsInColumn = columnItems[i] // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n\n        const startIndex = binarySearch(itemsInColumn, columns[i])\n        const index = columnItems[i][startIndex]\n        const startItem = items[index]\n        columnHeights[i] = startItem.top + startItem.height + columnGutter\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j]\n          const item = items[index]\n          item.top = columnHeights[i]\n          columnHeights[i] = item.top + item.height + columnGutter\n          intervalTree.remove(index)\n          intervalTree.insert(item.top, item.top + item.height, index)\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) =>\n      intervalTree.search(lo, hi, (index, top) =>\n        renderCallback(index, items[index].left, top)\n      ),\n    estimateHeight: (itemCount, defaultItemHeight) => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights))\n      return itemCount === intervalTree.size\n        ? tallestColumn\n        : tallestColumn +\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\n              defaultItemHeight\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights)\n      return columnHeights[0] || 0\n    },\n\n    size() {\n      return intervalTree.size\n    },\n  }\n}\n\n/* istanbul ignore next */\nconst binarySearch = (a, y) => {\n  let l = 0\n  let h = a.length - 1\n\n  while (l <= h) {\n    const m = (l + h) >>> 1\n    const x = a[m]\n    if (x === y) return m\n    else if (x <= y) l = m + 1\n    else h = m - 1\n  }\n\n  return -1\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  Masonry.displayName = 'Masonry'\n  MasonryScroller.displayName = 'MasonryScroller'\n  List.displayName = 'List'\n}\n"]},"metadata":{},"sourceType":"module"}